<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.hadoop.hbase.regionserver, class: HRegionServer, class: MovedRegionInfo">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="source-line-no">003</span><span id="line-3"> * or more contributor license agreements.  See the NOTICE file</span>
<span class="source-line-no">004</span><span id="line-4"> * distributed with this work for additional information</span>
<span class="source-line-no">005</span><span id="line-5"> * regarding copyright ownership.  The ASF licenses this file</span>
<span class="source-line-no">006</span><span id="line-6"> * to you under the Apache License, Version 2.0 (the</span>
<span class="source-line-no">007</span><span id="line-7"> * "License"); you may not use this file except in compliance</span>
<span class="source-line-no">008</span><span id="line-8"> * with the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">011</span><span id="line-11"> *</span>
<span class="source-line-no">012</span><span id="line-12"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">013</span><span id="line-13"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">014</span><span id="line-14"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">015</span><span id="line-15"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">016</span><span id="line-16"> * limitations under the License.</span>
<span class="source-line-no">017</span><span id="line-17"> */</span>
<span class="source-line-no">018</span><span id="line-18">package org.apache.hadoop.hbase.regionserver;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import static org.apache.hadoop.hbase.ChoreService.CHORE_SERVICE_INITIAL_POOL_SIZE;</span>
<span class="source-line-no">021</span><span id="line-21">import static org.apache.hadoop.hbase.ChoreService.DEFAULT_CHORE_SERVICE_INITIAL_POOL_SIZE;</span>
<span class="source-line-no">022</span><span id="line-22">import static org.apache.hadoop.hbase.HConstants.DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK;</span>
<span class="source-line-no">023</span><span id="line-23">import static org.apache.hadoop.hbase.HConstants.DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER;</span>
<span class="source-line-no">024</span><span id="line-24">import static org.apache.hadoop.hbase.HConstants.DEFAULT_SLOW_LOG_SYS_TABLE_CHORE_DURATION;</span>
<span class="source-line-no">025</span><span id="line-25">import static org.apache.hadoop.hbase.HConstants.HBASE_SPLIT_WAL_COORDINATED_BY_ZK;</span>
<span class="source-line-no">026</span><span id="line-26">import static org.apache.hadoop.hbase.HConstants.HBASE_SPLIT_WAL_MAX_SPLITTER;</span>
<span class="source-line-no">027</span><span id="line-27">import static org.apache.hadoop.hbase.master.waleventtracker.WALEventTrackerTableCreator.WAL_EVENT_TRACKER_ENABLED_DEFAULT;</span>
<span class="source-line-no">028</span><span id="line-28">import static org.apache.hadoop.hbase.master.waleventtracker.WALEventTrackerTableCreator.WAL_EVENT_TRACKER_ENABLED_KEY;</span>
<span class="source-line-no">029</span><span id="line-29">import static org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore.NAMED_QUEUE_CHORE_DURATION_DEFAULT;</span>
<span class="source-line-no">030</span><span id="line-30">import static org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore.NAMED_QUEUE_CHORE_DURATION_KEY;</span>
<span class="source-line-no">031</span><span id="line-31">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_CHORE_DURATION_DEFAULT;</span>
<span class="source-line-no">032</span><span id="line-32">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_CHORE_DURATION_KEY;</span>
<span class="source-line-no">033</span><span id="line-33">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_ENABLED_DEFAULT;</span>
<span class="source-line-no">034</span><span id="line-34">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_ENABLED_KEY;</span>
<span class="source-line-no">035</span><span id="line-35">import static org.apache.hadoop.hbase.util.DNS.UNSAFE_RS_HOSTNAME_KEY;</span>
<span class="source-line-no">036</span><span id="line-36"></span>
<span class="source-line-no">037</span><span id="line-37">import com.google.errorprone.annotations.RestrictedApi;</span>
<span class="source-line-no">038</span><span id="line-38">import io.opentelemetry.api.trace.Span;</span>
<span class="source-line-no">039</span><span id="line-39">import io.opentelemetry.api.trace.StatusCode;</span>
<span class="source-line-no">040</span><span id="line-40">import io.opentelemetry.context.Scope;</span>
<span class="source-line-no">041</span><span id="line-41">import java.io.IOException;</span>
<span class="source-line-no">042</span><span id="line-42">import java.io.PrintWriter;</span>
<span class="source-line-no">043</span><span id="line-43">import java.lang.management.MemoryType;</span>
<span class="source-line-no">044</span><span id="line-44">import java.lang.management.MemoryUsage;</span>
<span class="source-line-no">045</span><span id="line-45">import java.lang.reflect.Constructor;</span>
<span class="source-line-no">046</span><span id="line-46">import java.net.BindException;</span>
<span class="source-line-no">047</span><span id="line-47">import java.net.InetAddress;</span>
<span class="source-line-no">048</span><span id="line-48">import java.net.InetSocketAddress;</span>
<span class="source-line-no">049</span><span id="line-49">import java.time.Duration;</span>
<span class="source-line-no">050</span><span id="line-50">import java.util.ArrayList;</span>
<span class="source-line-no">051</span><span id="line-51">import java.util.Collection;</span>
<span class="source-line-no">052</span><span id="line-52">import java.util.Collections;</span>
<span class="source-line-no">053</span><span id="line-53">import java.util.Comparator;</span>
<span class="source-line-no">054</span><span id="line-54">import java.util.HashSet;</span>
<span class="source-line-no">055</span><span id="line-55">import java.util.Iterator;</span>
<span class="source-line-no">056</span><span id="line-56">import java.util.List;</span>
<span class="source-line-no">057</span><span id="line-57">import java.util.Map;</span>
<span class="source-line-no">058</span><span id="line-58">import java.util.Map.Entry;</span>
<span class="source-line-no">059</span><span id="line-59">import java.util.Objects;</span>
<span class="source-line-no">060</span><span id="line-60">import java.util.Optional;</span>
<span class="source-line-no">061</span><span id="line-61">import java.util.Set;</span>
<span class="source-line-no">062</span><span id="line-62">import java.util.SortedMap;</span>
<span class="source-line-no">063</span><span id="line-63">import java.util.Timer;</span>
<span class="source-line-no">064</span><span id="line-64">import java.util.TimerTask;</span>
<span class="source-line-no">065</span><span id="line-65">import java.util.TreeMap;</span>
<span class="source-line-no">066</span><span id="line-66">import java.util.TreeSet;</span>
<span class="source-line-no">067</span><span id="line-67">import java.util.concurrent.ConcurrentHashMap;</span>
<span class="source-line-no">068</span><span id="line-68">import java.util.concurrent.ConcurrentMap;</span>
<span class="source-line-no">069</span><span id="line-69">import java.util.concurrent.ConcurrentSkipListMap;</span>
<span class="source-line-no">070</span><span id="line-70">import java.util.concurrent.ThreadLocalRandom;</span>
<span class="source-line-no">071</span><span id="line-71">import java.util.concurrent.TimeUnit;</span>
<span class="source-line-no">072</span><span id="line-72">import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="source-line-no">073</span><span id="line-73">import java.util.concurrent.locks.ReentrantReadWriteLock;</span>
<span class="source-line-no">074</span><span id="line-74">import java.util.function.Consumer;</span>
<span class="source-line-no">075</span><span id="line-75">import java.util.stream.Collectors;</span>
<span class="source-line-no">076</span><span id="line-76">import javax.management.MalformedObjectNameException;</span>
<span class="source-line-no">077</span><span id="line-77">import javax.servlet.http.HttpServlet;</span>
<span class="source-line-no">078</span><span id="line-78">import org.apache.commons.lang3.StringUtils;</span>
<span class="source-line-no">079</span><span id="line-79">import org.apache.commons.lang3.SystemUtils;</span>
<span class="source-line-no">080</span><span id="line-80">import org.apache.commons.lang3.mutable.MutableFloat;</span>
<span class="source-line-no">081</span><span id="line-81">import org.apache.hadoop.conf.Configuration;</span>
<span class="source-line-no">082</span><span id="line-82">import org.apache.hadoop.fs.FileSystem;</span>
<span class="source-line-no">083</span><span id="line-83">import org.apache.hadoop.fs.Path;</span>
<span class="source-line-no">084</span><span id="line-84">import org.apache.hadoop.hbase.Abortable;</span>
<span class="source-line-no">085</span><span id="line-85">import org.apache.hadoop.hbase.CacheEvictionStats;</span>
<span class="source-line-no">086</span><span id="line-86">import org.apache.hadoop.hbase.CallQueueTooBigException;</span>
<span class="source-line-no">087</span><span id="line-87">import org.apache.hadoop.hbase.ChoreService;</span>
<span class="source-line-no">088</span><span id="line-88">import org.apache.hadoop.hbase.ClockOutOfSyncException;</span>
<span class="source-line-no">089</span><span id="line-89">import org.apache.hadoop.hbase.CoordinatedStateManager;</span>
<span class="source-line-no">090</span><span id="line-90">import org.apache.hadoop.hbase.DoNotRetryIOException;</span>
<span class="source-line-no">091</span><span id="line-91">import org.apache.hadoop.hbase.FailedCloseWALAfterInitializedErrorException;</span>
<span class="source-line-no">092</span><span id="line-92">import org.apache.hadoop.hbase.HBaseConfiguration;</span>
<span class="source-line-no">093</span><span id="line-93">import org.apache.hadoop.hbase.HBaseInterfaceAudience;</span>
<span class="source-line-no">094</span><span id="line-94">import org.apache.hadoop.hbase.HConstants;</span>
<span class="source-line-no">095</span><span id="line-95">import org.apache.hadoop.hbase.HDFSBlocksDistribution;</span>
<span class="source-line-no">096</span><span id="line-96">import org.apache.hadoop.hbase.HealthCheckChore;</span>
<span class="source-line-no">097</span><span id="line-97">import org.apache.hadoop.hbase.MetaRegionLocationCache;</span>
<span class="source-line-no">098</span><span id="line-98">import org.apache.hadoop.hbase.MetaTableAccessor;</span>
<span class="source-line-no">099</span><span id="line-99">import org.apache.hadoop.hbase.NotServingRegionException;</span>
<span class="source-line-no">100</span><span id="line-100">import org.apache.hadoop.hbase.PleaseHoldException;</span>
<span class="source-line-no">101</span><span id="line-101">import org.apache.hadoop.hbase.ScheduledChore;</span>
<span class="source-line-no">102</span><span id="line-102">import org.apache.hadoop.hbase.Server;</span>
<span class="source-line-no">103</span><span id="line-103">import org.apache.hadoop.hbase.ServerName;</span>
<span class="source-line-no">104</span><span id="line-104">import org.apache.hadoop.hbase.Stoppable;</span>
<span class="source-line-no">105</span><span id="line-105">import org.apache.hadoop.hbase.TableDescriptors;</span>
<span class="source-line-no">106</span><span id="line-106">import org.apache.hadoop.hbase.TableName;</span>
<span class="source-line-no">107</span><span id="line-107">import org.apache.hadoop.hbase.YouAreDeadException;</span>
<span class="source-line-no">108</span><span id="line-108">import org.apache.hadoop.hbase.ZNodeClearer;</span>
<span class="source-line-no">109</span><span id="line-109">import org.apache.hadoop.hbase.client.ClusterConnection;</span>
<span class="source-line-no">110</span><span id="line-110">import org.apache.hadoop.hbase.client.Connection;</span>
<span class="source-line-no">111</span><span id="line-111">import org.apache.hadoop.hbase.client.ConnectionUtils;</span>
<span class="source-line-no">112</span><span id="line-112">import org.apache.hadoop.hbase.client.RegionInfo;</span>
<span class="source-line-no">113</span><span id="line-113">import org.apache.hadoop.hbase.client.RegionInfoBuilder;</span>
<span class="source-line-no">114</span><span id="line-114">import org.apache.hadoop.hbase.client.RegionServerRegistry;</span>
<span class="source-line-no">115</span><span id="line-115">import org.apache.hadoop.hbase.client.RpcRetryingCallerFactory;</span>
<span class="source-line-no">116</span><span id="line-116">import org.apache.hadoop.hbase.client.ServerConnectionUtils;</span>
<span class="source-line-no">117</span><span id="line-117">import org.apache.hadoop.hbase.client.locking.EntityLock;</span>
<span class="source-line-no">118</span><span id="line-118">import org.apache.hadoop.hbase.client.locking.LockServiceClient;</span>
<span class="source-line-no">119</span><span id="line-119">import org.apache.hadoop.hbase.conf.ConfigurationManager;</span>
<span class="source-line-no">120</span><span id="line-120">import org.apache.hadoop.hbase.conf.ConfigurationObserver;</span>
<span class="source-line-no">121</span><span id="line-121">import org.apache.hadoop.hbase.coordination.ZkCoordinatedStateManager;</span>
<span class="source-line-no">122</span><span id="line-122">import org.apache.hadoop.hbase.coprocessor.CoprocessorHost;</span>
<span class="source-line-no">123</span><span id="line-123">import org.apache.hadoop.hbase.exceptions.RegionMovedException;</span>
<span class="source-line-no">124</span><span id="line-124">import org.apache.hadoop.hbase.exceptions.RegionOpeningException;</span>
<span class="source-line-no">125</span><span id="line-125">import org.apache.hadoop.hbase.exceptions.UnknownProtocolException;</span>
<span class="source-line-no">126</span><span id="line-126">import org.apache.hadoop.hbase.executor.ExecutorService;</span>
<span class="source-line-no">127</span><span id="line-127">import org.apache.hadoop.hbase.executor.ExecutorType;</span>
<span class="source-line-no">128</span><span id="line-128">import org.apache.hadoop.hbase.fs.HFileSystem;</span>
<span class="source-line-no">129</span><span id="line-129">import org.apache.hadoop.hbase.http.InfoServer;</span>
<span class="source-line-no">130</span><span id="line-130">import org.apache.hadoop.hbase.io.hfile.BlockCache;</span>
<span class="source-line-no">131</span><span id="line-131">import org.apache.hadoop.hbase.io.hfile.BlockCacheFactory;</span>
<span class="source-line-no">132</span><span id="line-132">import org.apache.hadoop.hbase.io.hfile.CombinedBlockCache;</span>
<span class="source-line-no">133</span><span id="line-133">import org.apache.hadoop.hbase.io.hfile.HFile;</span>
<span class="source-line-no">134</span><span id="line-134">import org.apache.hadoop.hbase.io.hfile.bucket.BucketCache;</span>
<span class="source-line-no">135</span><span id="line-135">import org.apache.hadoop.hbase.io.util.MemorySizeUtil;</span>
<span class="source-line-no">136</span><span id="line-136">import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;</span>
<span class="source-line-no">137</span><span id="line-137">import org.apache.hadoop.hbase.ipc.DecommissionedHostRejectedException;</span>
<span class="source-line-no">138</span><span id="line-138">import org.apache.hadoop.hbase.ipc.NettyRpcClientConfigHelper;</span>
<span class="source-line-no">139</span><span id="line-139">import org.apache.hadoop.hbase.ipc.RpcClient;</span>
<span class="source-line-no">140</span><span id="line-140">import org.apache.hadoop.hbase.ipc.RpcClientFactory;</span>
<span class="source-line-no">141</span><span id="line-141">import org.apache.hadoop.hbase.ipc.RpcControllerFactory;</span>
<span class="source-line-no">142</span><span id="line-142">import org.apache.hadoop.hbase.ipc.RpcServer;</span>
<span class="source-line-no">143</span><span id="line-143">import org.apache.hadoop.hbase.ipc.RpcServerInterface;</span>
<span class="source-line-no">144</span><span id="line-144">import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;</span>
<span class="source-line-no">145</span><span id="line-145">import org.apache.hadoop.hbase.ipc.ServerRpcController;</span>
<span class="source-line-no">146</span><span id="line-146">import org.apache.hadoop.hbase.log.HBaseMarkers;</span>
<span class="source-line-no">147</span><span id="line-147">import org.apache.hadoop.hbase.master.HMaster;</span>
<span class="source-line-no">148</span><span id="line-148">import org.apache.hadoop.hbase.master.LoadBalancer;</span>
<span class="source-line-no">149</span><span id="line-149">import org.apache.hadoop.hbase.mob.MobFileCache;</span>
<span class="source-line-no">150</span><span id="line-150">import org.apache.hadoop.hbase.mob.RSMobFileCleanerChore;</span>
<span class="source-line-no">151</span><span id="line-151">import org.apache.hadoop.hbase.monitoring.TaskMonitor;</span>
<span class="source-line-no">152</span><span id="line-152">import org.apache.hadoop.hbase.namequeues.NamedQueueRecorder;</span>
<span class="source-line-no">153</span><span id="line-153">import org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore;</span>
<span class="source-line-no">154</span><span id="line-154">import org.apache.hadoop.hbase.net.Address;</span>
<span class="source-line-no">155</span><span id="line-155">import org.apache.hadoop.hbase.procedure.RegionServerProcedureManagerHost;</span>
<span class="source-line-no">156</span><span id="line-156">import org.apache.hadoop.hbase.procedure2.RSProcedureCallable;</span>
<span class="source-line-no">157</span><span id="line-157">import org.apache.hadoop.hbase.quotas.FileSystemUtilizationChore;</span>
<span class="source-line-no">158</span><span id="line-158">import org.apache.hadoop.hbase.quotas.QuotaUtil;</span>
<span class="source-line-no">159</span><span id="line-159">import org.apache.hadoop.hbase.quotas.RegionServerRpcQuotaManager;</span>
<span class="source-line-no">160</span><span id="line-160">import org.apache.hadoop.hbase.quotas.RegionServerSpaceQuotaManager;</span>
<span class="source-line-no">161</span><span id="line-161">import org.apache.hadoop.hbase.quotas.RegionSize;</span>
<span class="source-line-no">162</span><span id="line-162">import org.apache.hadoop.hbase.quotas.RegionSizeStore;</span>
<span class="source-line-no">163</span><span id="line-163">import org.apache.hadoop.hbase.regionserver.compactions.CompactionConfiguration;</span>
<span class="source-line-no">164</span><span id="line-164">import org.apache.hadoop.hbase.regionserver.compactions.CompactionLifeCycleTracker;</span>
<span class="source-line-no">165</span><span id="line-165">import org.apache.hadoop.hbase.regionserver.compactions.CompactionProgress;</span>
<span class="source-line-no">166</span><span id="line-166">import org.apache.hadoop.hbase.regionserver.compactions.CompactionRequester;</span>
<span class="source-line-no">167</span><span id="line-167">import org.apache.hadoop.hbase.regionserver.handler.CloseMetaHandler;</span>
<span class="source-line-no">168</span><span id="line-168">import org.apache.hadoop.hbase.regionserver.handler.CloseRegionHandler;</span>
<span class="source-line-no">169</span><span id="line-169">import org.apache.hadoop.hbase.regionserver.handler.RSProcedureHandler;</span>
<span class="source-line-no">170</span><span id="line-170">import org.apache.hadoop.hbase.regionserver.handler.RegionReplicaFlushHandler;</span>
<span class="source-line-no">171</span><span id="line-171">import org.apache.hadoop.hbase.regionserver.http.RSDumpServlet;</span>
<span class="source-line-no">172</span><span id="line-172">import org.apache.hadoop.hbase.regionserver.http.RSStatusServlet;</span>
<span class="source-line-no">173</span><span id="line-173">import org.apache.hadoop.hbase.regionserver.throttle.FlushThroughputControllerFactory;</span>
<span class="source-line-no">174</span><span id="line-174">import org.apache.hadoop.hbase.regionserver.throttle.ThroughputController;</span>
<span class="source-line-no">175</span><span id="line-175">import org.apache.hadoop.hbase.regionserver.wal.WALActionsListener;</span>
<span class="source-line-no">176</span><span id="line-176">import org.apache.hadoop.hbase.regionserver.wal.WALEventTrackerListener;</span>
<span class="source-line-no">177</span><span id="line-177">import org.apache.hadoop.hbase.replication.regionserver.ReplicationLoad;</span>
<span class="source-line-no">178</span><span id="line-178">import org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore;</span>
<span class="source-line-no">179</span><span id="line-179">import org.apache.hadoop.hbase.replication.regionserver.ReplicationSourceInterface;</span>
<span class="source-line-no">180</span><span id="line-180">import org.apache.hadoop.hbase.replication.regionserver.ReplicationStatus;</span>
<span class="source-line-no">181</span><span id="line-181">import org.apache.hadoop.hbase.security.SecurityConstants;</span>
<span class="source-line-no">182</span><span id="line-182">import org.apache.hadoop.hbase.security.Superusers;</span>
<span class="source-line-no">183</span><span id="line-183">import org.apache.hadoop.hbase.security.User;</span>
<span class="source-line-no">184</span><span id="line-184">import org.apache.hadoop.hbase.security.UserProvider;</span>
<span class="source-line-no">185</span><span id="line-185">import org.apache.hadoop.hbase.security.access.AccessChecker;</span>
<span class="source-line-no">186</span><span id="line-186">import org.apache.hadoop.hbase.security.access.ZKPermissionWatcher;</span>
<span class="source-line-no">187</span><span id="line-187">import org.apache.hadoop.hbase.trace.TraceUtil;</span>
<span class="source-line-no">188</span><span id="line-188">import org.apache.hadoop.hbase.unsafe.HBasePlatformDependent;</span>
<span class="source-line-no">189</span><span id="line-189">import org.apache.hadoop.hbase.util.Addressing;</span>
<span class="source-line-no">190</span><span id="line-190">import org.apache.hadoop.hbase.util.Bytes;</span>
<span class="source-line-no">191</span><span id="line-191">import org.apache.hadoop.hbase.util.CommonFSUtils;</span>
<span class="source-line-no">192</span><span id="line-192">import org.apache.hadoop.hbase.util.CompressionTest;</span>
<span class="source-line-no">193</span><span id="line-193">import org.apache.hadoop.hbase.util.CoprocessorConfigurationUtil;</span>
<span class="source-line-no">194</span><span id="line-194">import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;</span>
<span class="source-line-no">195</span><span id="line-195">import org.apache.hadoop.hbase.util.FSTableDescriptors;</span>
<span class="source-line-no">196</span><span id="line-196">import org.apache.hadoop.hbase.util.FSUtils;</span>
<span class="source-line-no">197</span><span id="line-197">import org.apache.hadoop.hbase.util.JvmPauseMonitor;</span>
<span class="source-line-no">198</span><span id="line-198">import org.apache.hadoop.hbase.util.NettyEventLoopGroupConfig;</span>
<span class="source-line-no">199</span><span id="line-199">import org.apache.hadoop.hbase.util.Pair;</span>
<span class="source-line-no">200</span><span id="line-200">import org.apache.hadoop.hbase.util.RetryCounter;</span>
<span class="source-line-no">201</span><span id="line-201">import org.apache.hadoop.hbase.util.RetryCounterFactory;</span>
<span class="source-line-no">202</span><span id="line-202">import org.apache.hadoop.hbase.util.ServerRegionReplicaUtil;</span>
<span class="source-line-no">203</span><span id="line-203">import org.apache.hadoop.hbase.util.Sleeper;</span>
<span class="source-line-no">204</span><span id="line-204">import org.apache.hadoop.hbase.util.Threads;</span>
<span class="source-line-no">205</span><span id="line-205">import org.apache.hadoop.hbase.util.VersionInfo;</span>
<span class="source-line-no">206</span><span id="line-206">import org.apache.hadoop.hbase.wal.AbstractFSWALProvider;</span>
<span class="source-line-no">207</span><span id="line-207">import org.apache.hadoop.hbase.wal.NettyAsyncFSWALConfigHelper;</span>
<span class="source-line-no">208</span><span id="line-208">import org.apache.hadoop.hbase.wal.WAL;</span>
<span class="source-line-no">209</span><span id="line-209">import org.apache.hadoop.hbase.wal.WALFactory;</span>
<span class="source-line-no">210</span><span id="line-210">import org.apache.hadoop.hbase.zookeeper.ClusterStatusTracker;</span>
<span class="source-line-no">211</span><span id="line-211">import org.apache.hadoop.hbase.zookeeper.MasterAddressTracker;</span>
<span class="source-line-no">212</span><span id="line-212">import org.apache.hadoop.hbase.zookeeper.ZKAuthentication;</span>
<span class="source-line-no">213</span><span id="line-213">import org.apache.hadoop.hbase.zookeeper.ZKClusterId;</span>
<span class="source-line-no">214</span><span id="line-214">import org.apache.hadoop.hbase.zookeeper.ZKNodeTracker;</span>
<span class="source-line-no">215</span><span id="line-215">import org.apache.hadoop.hbase.zookeeper.ZKUtil;</span>
<span class="source-line-no">216</span><span id="line-216">import org.apache.hadoop.hbase.zookeeper.ZKWatcher;</span>
<span class="source-line-no">217</span><span id="line-217">import org.apache.hadoop.ipc.RemoteException;</span>
<span class="source-line-no">218</span><span id="line-218">import org.apache.hadoop.util.ReflectionUtils;</span>
<span class="source-line-no">219</span><span id="line-219">import org.apache.yetus.audience.InterfaceAudience;</span>
<span class="source-line-no">220</span><span id="line-220">import org.apache.zookeeper.KeeperException;</span>
<span class="source-line-no">221</span><span id="line-221">import org.slf4j.Logger;</span>
<span class="source-line-no">222</span><span id="line-222">import org.slf4j.LoggerFactory;</span>
<span class="source-line-no">223</span><span id="line-223"></span>
<span class="source-line-no">224</span><span id="line-224">import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;</span>
<span class="source-line-no">225</span><span id="line-225">import org.apache.hbase.thirdparty.com.google.common.base.Throwables;</span>
<span class="source-line-no">226</span><span id="line-226">import org.apache.hbase.thirdparty.com.google.common.cache.Cache;</span>
<span class="source-line-no">227</span><span id="line-227">import org.apache.hbase.thirdparty.com.google.common.cache.CacheBuilder;</span>
<span class="source-line-no">228</span><span id="line-228">import org.apache.hbase.thirdparty.com.google.common.collect.Maps;</span>
<span class="source-line-no">229</span><span id="line-229">import org.apache.hbase.thirdparty.com.google.common.net.InetAddresses;</span>
<span class="source-line-no">230</span><span id="line-230">import org.apache.hbase.thirdparty.com.google.protobuf.BlockingRpcChannel;</span>
<span class="source-line-no">231</span><span id="line-231">import org.apache.hbase.thirdparty.com.google.protobuf.RpcController;</span>
<span class="source-line-no">232</span><span id="line-232">import org.apache.hbase.thirdparty.com.google.protobuf.ServiceException;</span>
<span class="source-line-no">233</span><span id="line-233">import org.apache.hbase.thirdparty.com.google.protobuf.TextFormat;</span>
<span class="source-line-no">234</span><span id="line-234">import org.apache.hbase.thirdparty.com.google.protobuf.UnsafeByteOperations;</span>
<span class="source-line-no">235</span><span id="line-235"></span>
<span class="source-line-no">236</span><span id="line-236">import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;</span>
<span class="source-line-no">237</span><span id="line-237">import org.apache.hadoop.hbase.shaded.protobuf.RequestConverter;</span>
<span class="source-line-no">238</span><span id="line-238">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceCall;</span>
<span class="source-line-no">239</span><span id="line-239">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceRequest;</span>
<span class="source-line-no">240</span><span id="line-240">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceResponse;</span>
<span class="source-line-no">241</span><span id="line-241">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos;</span>
<span class="source-line-no">242</span><span id="line-242">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.RegionLoad;</span>
<span class="source-line-no">243</span><span id="line-243">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.RegionStoreSequenceIds;</span>
<span class="source-line-no">244</span><span id="line-244">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.UserLoad;</span>
<span class="source-line-no">245</span><span id="line-245">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.Coprocessor;</span>
<span class="source-line-no">246</span><span id="line-246">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.NameStringPair;</span>
<span class="source-line-no">247</span><span id="line-247">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionServerInfo;</span>
<span class="source-line-no">248</span><span id="line-248">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier;</span>
<span class="source-line-no">249</span><span id="line-249">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier.RegionSpecifierType;</span>
<span class="source-line-no">250</span><span id="line-250">import org.apache.hadoop.hbase.shaded.protobuf.generated.LockServiceProtos.LockService;</span>
<span class="source-line-no">251</span><span id="line-251">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos;</span>
<span class="source-line-no">252</span><span id="line-252">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.GetLastFlushedSequenceIdRequest;</span>
<span class="source-line-no">253</span><span id="line-253">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.GetLastFlushedSequenceIdResponse;</span>
<span class="source-line-no">254</span><span id="line-254">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerReportRequest;</span>
<span class="source-line-no">255</span><span id="line-255">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStartupRequest;</span>
<span class="source-line-no">256</span><span id="line-256">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStartupResponse;</span>
<span class="source-line-no">257</span><span id="line-257">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStatusService;</span>
<span class="source-line-no">258</span><span id="line-258">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionSpaceUse;</span>
<span class="source-line-no">259</span><span id="line-259">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionSpaceUseReportRequest;</span>
<span class="source-line-no">260</span><span id="line-260">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionStateTransition;</span>
<span class="source-line-no">261</span><span id="line-261">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionStateTransition.TransitionCode;</span>
<span class="source-line-no">262</span><span id="line-262">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportProcedureDoneRequest;</span>
<span class="source-line-no">263</span><span id="line-263">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRSFatalErrorRequest;</span>
<span class="source-line-no">264</span><span id="line-264">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRegionStateTransitionRequest;</span>
<span class="source-line-no">265</span><span id="line-265">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRegionStateTransitionResponse;</span>
<span class="source-line-no">266</span><span id="line-266"></span>
<span class="source-line-no">267</span><span id="line-267">/**</span>
<span class="source-line-no">268</span><span id="line-268"> * HRegionServer makes a set of HRegions available to clients. It checks in with the HMaster. There</span>
<span class="source-line-no">269</span><span id="line-269"> * are many HRegionServers in a single HBase deployment.</span>
<span class="source-line-no">270</span><span id="line-270"> */</span>
<span class="source-line-no">271</span><span id="line-271">@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.TOOLS)</span>
<span class="source-line-no">272</span><span id="line-272">@SuppressWarnings({ "deprecation" })</span>
<span class="source-line-no">273</span><span id="line-273">public class HRegionServer extends Thread</span>
<span class="source-line-no">274</span><span id="line-274">  implements RegionServerServices, LastSequenceId, ConfigurationObserver {</span>
<span class="source-line-no">275</span><span id="line-275">  private static final Logger LOG = LoggerFactory.getLogger(HRegionServer.class);</span>
<span class="source-line-no">276</span><span id="line-276"></span>
<span class="source-line-no">277</span><span id="line-277">  int unitMB = 1024 * 1024;</span>
<span class="source-line-no">278</span><span id="line-278">  int unitKB = 1024;</span>
<span class="source-line-no">279</span><span id="line-279"></span>
<span class="source-line-no">280</span><span id="line-280">  /**</span>
<span class="source-line-no">281</span><span id="line-281">   * For testing only! Set to true to skip notifying region assignment to master .</span>
<span class="source-line-no">282</span><span id="line-282">   */</span>
<span class="source-line-no">283</span><span id="line-283">  @InterfaceAudience.Private</span>
<span class="source-line-no">284</span><span id="line-284">  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "MS_SHOULD_BE_FINAL")</span>
<span class="source-line-no">285</span><span id="line-285">  public static boolean TEST_SKIP_REPORTING_TRANSITION = false;</span>
<span class="source-line-no">286</span><span id="line-286"></span>
<span class="source-line-no">287</span><span id="line-287">  /**</span>
<span class="source-line-no">288</span><span id="line-288">   * A map from RegionName to current action in progress. Boolean value indicates: true - if open</span>
<span class="source-line-no">289</span><span id="line-289">   * region action in progress false - if close region action in progress</span>
<span class="source-line-no">290</span><span id="line-290">   */</span>
<span class="source-line-no">291</span><span id="line-291">  private final ConcurrentMap&lt;byte[], Boolean&gt; regionsInTransitionInRS =</span>
<span class="source-line-no">292</span><span id="line-292">    new ConcurrentSkipListMap&lt;&gt;(Bytes.BYTES_COMPARATOR);</span>
<span class="source-line-no">293</span><span id="line-293"></span>
<span class="source-line-no">294</span><span id="line-294">  /**</span>
<span class="source-line-no">295</span><span id="line-295">   * Used to cache the open/close region procedures which already submitted. See</span>
<span class="source-line-no">296</span><span id="line-296">   * {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">297</span><span id="line-297">   */</span>
<span class="source-line-no">298</span><span id="line-298">  private final ConcurrentMap&lt;Long, Long&gt; submittedRegionProcedures = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">299</span><span id="line-299">  /**</span>
<span class="source-line-no">300</span><span id="line-300">   * Used to cache the open/close region procedures which already executed. See</span>
<span class="source-line-no">301</span><span id="line-301">   * {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">302</span><span id="line-302">   */</span>
<span class="source-line-no">303</span><span id="line-303">  private final Cache&lt;Long, Long&gt; executedRegionProcedures =</span>
<span class="source-line-no">304</span><span id="line-304">    CacheBuilder.newBuilder().expireAfterAccess(600, TimeUnit.SECONDS).build();</span>
<span class="source-line-no">305</span><span id="line-305"></span>
<span class="source-line-no">306</span><span id="line-306">  /**</span>
<span class="source-line-no">307</span><span id="line-307">   * Used to cache the moved-out regions</span>
<span class="source-line-no">308</span><span id="line-308">   */</span>
<span class="source-line-no">309</span><span id="line-309">  private final Cache&lt;String, MovedRegionInfo&gt; movedRegionInfoCache = CacheBuilder.newBuilder()</span>
<span class="source-line-no">310</span><span id="line-310">    .expireAfterWrite(movedRegionCacheExpiredTime(), TimeUnit.MILLISECONDS).build();</span>
<span class="source-line-no">311</span><span id="line-311"></span>
<span class="source-line-no">312</span><span id="line-312">  private MemStoreFlusher cacheFlusher;</span>
<span class="source-line-no">313</span><span id="line-313"></span>
<span class="source-line-no">314</span><span id="line-314">  private HeapMemoryManager hMemManager;</span>
<span class="source-line-no">315</span><span id="line-315"></span>
<span class="source-line-no">316</span><span id="line-316">  /**</span>
<span class="source-line-no">317</span><span id="line-317">   * Cluster connection to be shared by services. Initialized at server startup and closed when</span>
<span class="source-line-no">318</span><span id="line-318">   * server shuts down. Clients must never close it explicitly. Clients hosted by this Server should</span>
<span class="source-line-no">319</span><span id="line-319">   * make use of this clusterConnection rather than create their own; if they create their own,</span>
<span class="source-line-no">320</span><span id="line-320">   * there is no way for the hosting server to shutdown ongoing client RPCs.</span>
<span class="source-line-no">321</span><span id="line-321">   */</span>
<span class="source-line-no">322</span><span id="line-322">  protected ClusterConnection clusterConnection;</span>
<span class="source-line-no">323</span><span id="line-323"></span>
<span class="source-line-no">324</span><span id="line-324">  /**</span>
<span class="source-line-no">325</span><span id="line-325">   * Go here to get table descriptors.</span>
<span class="source-line-no">326</span><span id="line-326">   */</span>
<span class="source-line-no">327</span><span id="line-327">  protected TableDescriptors tableDescriptors;</span>
<span class="source-line-no">328</span><span id="line-328"></span>
<span class="source-line-no">329</span><span id="line-329">  // Replication services. If no replication, this handler will be null.</span>
<span class="source-line-no">330</span><span id="line-330">  private ReplicationSourceService replicationSourceHandler;</span>
<span class="source-line-no">331</span><span id="line-331">  private ReplicationSinkService replicationSinkHandler;</span>
<span class="source-line-no">332</span><span id="line-332"></span>
<span class="source-line-no">333</span><span id="line-333">  // Compactions</span>
<span class="source-line-no">334</span><span id="line-334">  private CompactSplit compactSplitThread;</span>
<span class="source-line-no">335</span><span id="line-335"></span>
<span class="source-line-no">336</span><span id="line-336">  /**</span>
<span class="source-line-no">337</span><span id="line-337">   * Map of regions currently being served by this region server. Key is the encoded region name.</span>
<span class="source-line-no">338</span><span id="line-338">   * All access should be synchronized.</span>
<span class="source-line-no">339</span><span id="line-339">   */</span>
<span class="source-line-no">340</span><span id="line-340">  private final Map&lt;String, HRegion&gt; onlineRegions = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">341</span><span id="line-341">  /**</span>
<span class="source-line-no">342</span><span id="line-342">   * Lock for gating access to {@link #onlineRegions}. TODO: If this map is gated by a lock, does it</span>
<span class="source-line-no">343</span><span id="line-343">   * need to be a ConcurrentHashMap?</span>
<span class="source-line-no">344</span><span id="line-344">   */</span>
<span class="source-line-no">345</span><span id="line-345">  private final ReentrantReadWriteLock onlineRegionsLock = new ReentrantReadWriteLock();</span>
<span class="source-line-no">346</span><span id="line-346"></span>
<span class="source-line-no">347</span><span id="line-347">  /**</span>
<span class="source-line-no">348</span><span id="line-348">   * Map of encoded region names to the DataNode locations they should be hosted on We store the</span>
<span class="source-line-no">349</span><span id="line-349">   * value as Address since InetSocketAddress is required by the HDFS API (create() that takes</span>
<span class="source-line-no">350</span><span id="line-350">   * favored nodes as hints for placing file blocks). We could have used ServerName here as the</span>
<span class="source-line-no">351</span><span id="line-351">   * value class, but we'd need to convert it to InetSocketAddress at some point before the HDFS API</span>
<span class="source-line-no">352</span><span id="line-352">   * call, and it seems a bit weird to store ServerName since ServerName refers to RegionServers and</span>
<span class="source-line-no">353</span><span id="line-353">   * here we really mean DataNode locations. We don't store it as InetSocketAddress here because the</span>
<span class="source-line-no">354</span><span id="line-354">   * conversion on demand from Address to InetSocketAddress will guarantee the resolution results</span>
<span class="source-line-no">355</span><span id="line-355">   * will be fresh when we need it.</span>
<span class="source-line-no">356</span><span id="line-356">   */</span>
<span class="source-line-no">357</span><span id="line-357">  private final Map&lt;String, Address[]&gt; regionFavoredNodesMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">358</span><span id="line-358"></span>
<span class="source-line-no">359</span><span id="line-359">  private LeaseManager leaseManager;</span>
<span class="source-line-no">360</span><span id="line-360"></span>
<span class="source-line-no">361</span><span id="line-361">  // Instance of the hbase executor executorService.</span>
<span class="source-line-no">362</span><span id="line-362">  protected ExecutorService executorService;</span>
<span class="source-line-no">363</span><span id="line-363"></span>
<span class="source-line-no">364</span><span id="line-364">  private volatile boolean dataFsOk;</span>
<span class="source-line-no">365</span><span id="line-365">  private HFileSystem dataFs;</span>
<span class="source-line-no">366</span><span id="line-366">  private HFileSystem walFs;</span>
<span class="source-line-no">367</span><span id="line-367"></span>
<span class="source-line-no">368</span><span id="line-368">  // Set when a report to the master comes back with a message asking us to</span>
<span class="source-line-no">369</span><span id="line-369">  // shutdown. Also set by call to stop when debugging or running unit tests</span>
<span class="source-line-no">370</span><span id="line-370">  // of HRegionServer in isolation.</span>
<span class="source-line-no">371</span><span id="line-371">  private volatile boolean stopped = false;</span>
<span class="source-line-no">372</span><span id="line-372">  // Only for testing</span>
<span class="source-line-no">373</span><span id="line-373">  private boolean isShutdownHookInstalled = false;</span>
<span class="source-line-no">374</span><span id="line-374"></span>
<span class="source-line-no">375</span><span id="line-375">  // Go down hard. Used if file system becomes unavailable and also in</span>
<span class="source-line-no">376</span><span id="line-376">  // debugging and unit tests.</span>
<span class="source-line-no">377</span><span id="line-377">  private AtomicBoolean abortRequested;</span>
<span class="source-line-no">378</span><span id="line-378">  static final String ABORT_TIMEOUT = "hbase.regionserver.abort.timeout";</span>
<span class="source-line-no">379</span><span id="line-379">  // Default abort timeout is 1200 seconds for safe</span>
<span class="source-line-no">380</span><span id="line-380">  private static final long DEFAULT_ABORT_TIMEOUT = 1200000;</span>
<span class="source-line-no">381</span><span id="line-381">  // Will run this task when abort timeout</span>
<span class="source-line-no">382</span><span id="line-382">  static final String ABORT_TIMEOUT_TASK = "hbase.regionserver.abort.timeout.task";</span>
<span class="source-line-no">383</span><span id="line-383"></span>
<span class="source-line-no">384</span><span id="line-384">  // A state before we go into stopped state. At this stage we're closing user</span>
<span class="source-line-no">385</span><span id="line-385">  // space regions.</span>
<span class="source-line-no">386</span><span id="line-386">  private boolean stopping = false;</span>
<span class="source-line-no">387</span><span id="line-387">  private volatile boolean killed = false;</span>
<span class="source-line-no">388</span><span id="line-388">  private volatile boolean shutDown = false;</span>
<span class="source-line-no">389</span><span id="line-389"></span>
<span class="source-line-no">390</span><span id="line-390">  protected final Configuration conf;</span>
<span class="source-line-no">391</span><span id="line-391"></span>
<span class="source-line-no">392</span><span id="line-392">  private Path dataRootDir;</span>
<span class="source-line-no">393</span><span id="line-393">  private Path walRootDir;</span>
<span class="source-line-no">394</span><span id="line-394"></span>
<span class="source-line-no">395</span><span id="line-395">  private final int threadWakeFrequency;</span>
<span class="source-line-no">396</span><span id="line-396">  final int msgInterval;</span>
<span class="source-line-no">397</span><span id="line-397"></span>
<span class="source-line-no">398</span><span id="line-398">  private static final String PERIOD_COMPACTION = "hbase.regionserver.compaction.check.period";</span>
<span class="source-line-no">399</span><span id="line-399">  private final int compactionCheckFrequency;</span>
<span class="source-line-no">400</span><span id="line-400">  private static final String PERIOD_FLUSH = "hbase.regionserver.flush.check.period";</span>
<span class="source-line-no">401</span><span id="line-401">  private final int flushCheckFrequency;</span>
<span class="source-line-no">402</span><span id="line-402"></span>
<span class="source-line-no">403</span><span id="line-403">  // Stub to do region server status calls against the master.</span>
<span class="source-line-no">404</span><span id="line-404">  private volatile RegionServerStatusService.BlockingInterface rssStub;</span>
<span class="source-line-no">405</span><span id="line-405">  private volatile LockService.BlockingInterface lockStub;</span>
<span class="source-line-no">406</span><span id="line-406">  // RPC client. Used to make the stub above that does region server status checking.</span>
<span class="source-line-no">407</span><span id="line-407">  private RpcClient rpcClient;</span>
<span class="source-line-no">408</span><span id="line-408"></span>
<span class="source-line-no">409</span><span id="line-409">  private RpcRetryingCallerFactory rpcRetryingCallerFactory;</span>
<span class="source-line-no">410</span><span id="line-410">  private RpcControllerFactory rpcControllerFactory;</span>
<span class="source-line-no">411</span><span id="line-411"></span>
<span class="source-line-no">412</span><span id="line-412">  private UncaughtExceptionHandler uncaughtExceptionHandler;</span>
<span class="source-line-no">413</span><span id="line-413"></span>
<span class="source-line-no">414</span><span id="line-414">  // Info server. Default access so can be used by unit tests. REGIONSERVER</span>
<span class="source-line-no">415</span><span id="line-415">  // is name of the webapp and the attribute name used stuffing this instance</span>
<span class="source-line-no">416</span><span id="line-416">  // into web context.</span>
<span class="source-line-no">417</span><span id="line-417">  protected InfoServer infoServer;</span>
<span class="source-line-no">418</span><span id="line-418">  private JvmPauseMonitor pauseMonitor;</span>
<span class="source-line-no">419</span><span id="line-419"></span>
<span class="source-line-no">420</span><span id="line-420">  private RSSnapshotVerifier rsSnapshotVerifier;</span>
<span class="source-line-no">421</span><span id="line-421"></span>
<span class="source-line-no">422</span><span id="line-422">  /** region server process name */</span>
<span class="source-line-no">423</span><span id="line-423">  public static final String REGIONSERVER = "regionserver";</span>
<span class="source-line-no">424</span><span id="line-424"></span>
<span class="source-line-no">425</span><span id="line-425">  private MetricsRegionServer metricsRegionServer;</span>
<span class="source-line-no">426</span><span id="line-426">  MetricsRegionServerWrapperImpl metricsRegionServerImpl;</span>
<span class="source-line-no">427</span><span id="line-427"></span>
<span class="source-line-no">428</span><span id="line-428">  /**</span>
<span class="source-line-no">429</span><span id="line-429">   * ChoreService used to schedule tasks that we want to run periodically</span>
<span class="source-line-no">430</span><span id="line-430">   */</span>
<span class="source-line-no">431</span><span id="line-431">  private ChoreService choreService;</span>
<span class="source-line-no">432</span><span id="line-432"></span>
<span class="source-line-no">433</span><span id="line-433">  /**</span>
<span class="source-line-no">434</span><span id="line-434">   * Check for compactions requests.</span>
<span class="source-line-no">435</span><span id="line-435">   */</span>
<span class="source-line-no">436</span><span id="line-436">  private ScheduledChore compactionChecker;</span>
<span class="source-line-no">437</span><span id="line-437"></span>
<span class="source-line-no">438</span><span id="line-438">  /**</span>
<span class="source-line-no">439</span><span id="line-439">   * Check for flushes</span>
<span class="source-line-no">440</span><span id="line-440">   */</span>
<span class="source-line-no">441</span><span id="line-441">  private ScheduledChore periodicFlusher;</span>
<span class="source-line-no">442</span><span id="line-442"></span>
<span class="source-line-no">443</span><span id="line-443">  private volatile WALFactory walFactory;</span>
<span class="source-line-no">444</span><span id="line-444"></span>
<span class="source-line-no">445</span><span id="line-445">  private LogRoller walRoller;</span>
<span class="source-line-no">446</span><span id="line-446"></span>
<span class="source-line-no">447</span><span id="line-447">  // A thread which calls reportProcedureDone</span>
<span class="source-line-no">448</span><span id="line-448">  private RemoteProcedureResultReporter procedureResultReporter;</span>
<span class="source-line-no">449</span><span id="line-449"></span>
<span class="source-line-no">450</span><span id="line-450">  // flag set after we're done setting up server threads</span>
<span class="source-line-no">451</span><span id="line-451">  final AtomicBoolean online = new AtomicBoolean(false);</span>
<span class="source-line-no">452</span><span id="line-452"></span>
<span class="source-line-no">453</span><span id="line-453">  // zookeeper connection and watcher</span>
<span class="source-line-no">454</span><span id="line-454">  protected final ZKWatcher zooKeeper;</span>
<span class="source-line-no">455</span><span id="line-455"></span>
<span class="source-line-no">456</span><span id="line-456">  // master address tracker</span>
<span class="source-line-no">457</span><span id="line-457">  private final MasterAddressTracker masterAddressTracker;</span>
<span class="source-line-no">458</span><span id="line-458"></span>
<span class="source-line-no">459</span><span id="line-459">  /**</span>
<span class="source-line-no">460</span><span id="line-460">   * Cache for the meta region replica's locations. Also tracks their changes to avoid stale cache</span>
<span class="source-line-no">461</span><span id="line-461">   * entries. Used for serving ClientMetaService.</span>
<span class="source-line-no">462</span><span id="line-462">   */</span>
<span class="source-line-no">463</span><span id="line-463">  private final MetaRegionLocationCache metaRegionLocationCache;</span>
<span class="source-line-no">464</span><span id="line-464"></span>
<span class="source-line-no">465</span><span id="line-465">  // Cluster Status Tracker</span>
<span class="source-line-no">466</span><span id="line-466">  protected final ClusterStatusTracker clusterStatusTracker;</span>
<span class="source-line-no">467</span><span id="line-467"></span>
<span class="source-line-no">468</span><span id="line-468">  // Log Splitting Worker</span>
<span class="source-line-no">469</span><span id="line-469">  private SplitLogWorker splitLogWorker;</span>
<span class="source-line-no">470</span><span id="line-470"></span>
<span class="source-line-no">471</span><span id="line-471">  // A sleeper that sleeps for msgInterval.</span>
<span class="source-line-no">472</span><span id="line-472">  protected final Sleeper sleeper;</span>
<span class="source-line-no">473</span><span id="line-473"></span>
<span class="source-line-no">474</span><span id="line-474">  private final int operationTimeout;</span>
<span class="source-line-no">475</span><span id="line-475">  private final int shortOperationTimeout;</span>
<span class="source-line-no">476</span><span id="line-476"></span>
<span class="source-line-no">477</span><span id="line-477">  // Time to pause if master says 'please hold'</span>
<span class="source-line-no">478</span><span id="line-478">  private final long retryPauseTime;</span>
<span class="source-line-no">479</span><span id="line-479"></span>
<span class="source-line-no">480</span><span id="line-480">  private final RegionServerAccounting regionServerAccounting;</span>
<span class="source-line-no">481</span><span id="line-481"></span>
<span class="source-line-no">482</span><span id="line-482">  private NamedQueueServiceChore namedQueueServiceChore = null;</span>
<span class="source-line-no">483</span><span id="line-483"></span>
<span class="source-line-no">484</span><span id="line-484">  // Block cache</span>
<span class="source-line-no">485</span><span id="line-485">  private BlockCache blockCache;</span>
<span class="source-line-no">486</span><span id="line-486">  // The cache for mob files</span>
<span class="source-line-no">487</span><span id="line-487">  private MobFileCache mobFileCache;</span>
<span class="source-line-no">488</span><span id="line-488"></span>
<span class="source-line-no">489</span><span id="line-489">  /** The health check chore. */</span>
<span class="source-line-no">490</span><span id="line-490">  private HealthCheckChore healthCheckChore;</span>
<span class="source-line-no">491</span><span id="line-491"></span>
<span class="source-line-no">492</span><span id="line-492">  /** The nonce manager chore. */</span>
<span class="source-line-no">493</span><span id="line-493">  private ScheduledChore nonceManagerChore;</span>
<span class="source-line-no">494</span><span id="line-494"></span>
<span class="source-line-no">495</span><span id="line-495">  private Map&lt;String, com.google.protobuf.Service&gt; coprocessorServiceHandlers = Maps.newHashMap();</span>
<span class="source-line-no">496</span><span id="line-496"></span>
<span class="source-line-no">497</span><span id="line-497">  /**</span>
<span class="source-line-no">498</span><span id="line-498">   * The server name the Master sees us as. Its made from the hostname the master passes us, port,</span>
<span class="source-line-no">499</span><span id="line-499">   * and server startcode. Gets set after registration against Master.</span>
<span class="source-line-no">500</span><span id="line-500">   */</span>
<span class="source-line-no">501</span><span id="line-501">  protected ServerName serverName;</span>
<span class="source-line-no">502</span><span id="line-502"></span>
<span class="source-line-no">503</span><span id="line-503">  /**</span>
<span class="source-line-no">504</span><span id="line-504">   * hostname specified by hostname config</span>
<span class="source-line-no">505</span><span id="line-505">   */</span>
<span class="source-line-no">506</span><span id="line-506">  protected String useThisHostnameInstead;</span>
<span class="source-line-no">507</span><span id="line-507"></span>
<span class="source-line-no">508</span><span id="line-508">  /**</span>
<span class="source-line-no">509</span><span id="line-509">   * @deprecated since 2.4.0 and will be removed in 4.0.0. Use</span>
<span class="source-line-no">510</span><span id="line-510">   *             {@link HRegionServer#UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY} instead.</span>
<span class="source-line-no">511</span><span id="line-511">   * @see &lt;a href="https://issues.apache.org/jira/browse/HBASE-24667"&gt;HBASE-24667&lt;/a&gt;</span>
<span class="source-line-no">512</span><span id="line-512">   */</span>
<span class="source-line-no">513</span><span id="line-513">  @Deprecated</span>
<span class="source-line-no">514</span><span id="line-514">  @InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.CONFIG)</span>
<span class="source-line-no">515</span><span id="line-515">  final static String RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY =</span>
<span class="source-line-no">516</span><span id="line-516">    "hbase.regionserver.hostname.disable.master.reversedns";</span>
<span class="source-line-no">517</span><span id="line-517"></span>
<span class="source-line-no">518</span><span id="line-518">  /**</span>
<span class="source-line-no">519</span><span id="line-519">   * HBASE-18226: This config and hbase.unsafe.regionserver.hostname are mutually exclusive.</span>
<span class="source-line-no">520</span><span id="line-520">   * Exception will be thrown if both are used.</span>
<span class="source-line-no">521</span><span id="line-521">   */</span>
<span class="source-line-no">522</span><span id="line-522">  @InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.CONFIG)</span>
<span class="source-line-no">523</span><span id="line-523">  final static String UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY =</span>
<span class="source-line-no">524</span><span id="line-524">    "hbase.unsafe.regionserver.hostname.disable.master.reversedns";</span>
<span class="source-line-no">525</span><span id="line-525"></span>
<span class="source-line-no">526</span><span id="line-526">  /**</span>
<span class="source-line-no">527</span><span id="line-527">   * This servers startcode.</span>
<span class="source-line-no">528</span><span id="line-528">   */</span>
<span class="source-line-no">529</span><span id="line-529">  protected final long startcode;</span>
<span class="source-line-no">530</span><span id="line-530"></span>
<span class="source-line-no">531</span><span id="line-531">  /**</span>
<span class="source-line-no">532</span><span id="line-532">   * Unique identifier for the cluster we are a part of.</span>
<span class="source-line-no">533</span><span id="line-533">   */</span>
<span class="source-line-no">534</span><span id="line-534">  protected String clusterId;</span>
<span class="source-line-no">535</span><span id="line-535"></span>
<span class="source-line-no">536</span><span id="line-536">  // chore for refreshing store files for secondary regions</span>
<span class="source-line-no">537</span><span id="line-537">  private StorefileRefresherChore storefileRefresher;</span>
<span class="source-line-no">538</span><span id="line-538"></span>
<span class="source-line-no">539</span><span id="line-539">  private volatile RegionServerCoprocessorHost rsHost;</span>
<span class="source-line-no">540</span><span id="line-540"></span>
<span class="source-line-no">541</span><span id="line-541">  private RegionServerProcedureManagerHost rspmHost;</span>
<span class="source-line-no">542</span><span id="line-542"></span>
<span class="source-line-no">543</span><span id="line-543">  private RegionServerRpcQuotaManager rsQuotaManager;</span>
<span class="source-line-no">544</span><span id="line-544">  private RegionServerSpaceQuotaManager rsSpaceQuotaManager;</span>
<span class="source-line-no">545</span><span id="line-545"></span>
<span class="source-line-no">546</span><span id="line-546">  /**</span>
<span class="source-line-no">547</span><span id="line-547">   * Nonce manager. Nonces are used to make operations like increment and append idempotent in the</span>
<span class="source-line-no">548</span><span id="line-548">   * case where client doesn't receive the response from a successful operation and retries. We</span>
<span class="source-line-no">549</span><span id="line-549">   * track the successful ops for some time via a nonce sent by client and handle duplicate</span>
<span class="source-line-no">550</span><span id="line-550">   * operations (currently, by failing them; in future we might use MVCC to return result). Nonces</span>
<span class="source-line-no">551</span><span id="line-551">   * are also recovered from WAL during, recovery; however, the caveats (from HBASE-3787) are: - WAL</span>
<span class="source-line-no">552</span><span id="line-552">   * recovery is optimized, and under high load we won't read nearly nonce-timeout worth of past</span>
<span class="source-line-no">553</span><span id="line-553">   * records. If we don't read the records, we don't read and recover the nonces. Some WALs within</span>
<span class="source-line-no">554</span><span id="line-554">   * nonce-timeout at recovery may not even be present due to rolling/cleanup. - There's no WAL</span>
<span class="source-line-no">555</span><span id="line-555">   * recovery during normal region move, so nonces will not be transfered. We can have separate</span>
<span class="source-line-no">556</span><span id="line-556">   * additional "Nonce WAL". It will just contain bunch of numbers and won't be flushed on main path</span>
<span class="source-line-no">557</span><span id="line-557">   * - because WAL itself also contains nonces, if we only flush it before memstore flush, for a</span>
<span class="source-line-no">558</span><span id="line-558">   * given nonce we will either see it in the WAL (if it was never flushed to disk, it will be part</span>
<span class="source-line-no">559</span><span id="line-559">   * of recovery), or we'll see it as part of the nonce log (or both occasionally, which doesn't</span>
<span class="source-line-no">560</span><span id="line-560">   * matter). Nonce log file can be deleted after the latest nonce in it expired. It can also be</span>
<span class="source-line-no">561</span><span id="line-561">   * recovered during move.</span>
<span class="source-line-no">562</span><span id="line-562">   */</span>
<span class="source-line-no">563</span><span id="line-563">  final ServerNonceManager nonceManager;</span>
<span class="source-line-no">564</span><span id="line-564"></span>
<span class="source-line-no">565</span><span id="line-565">  private UserProvider userProvider;</span>
<span class="source-line-no">566</span><span id="line-566"></span>
<span class="source-line-no">567</span><span id="line-567">  protected final RSRpcServices rpcServices;</span>
<span class="source-line-no">568</span><span id="line-568"></span>
<span class="source-line-no">569</span><span id="line-569">  private CoordinatedStateManager csm;</span>
<span class="source-line-no">570</span><span id="line-570"></span>
<span class="source-line-no">571</span><span id="line-571">  /**</span>
<span class="source-line-no">572</span><span id="line-572">   * Configuration manager is used to register/deregister and notify the configuration observers</span>
<span class="source-line-no">573</span><span id="line-573">   * when the regionserver is notified that there was a change in the on disk configs.</span>
<span class="source-line-no">574</span><span id="line-574">   */</span>
<span class="source-line-no">575</span><span id="line-575">  protected final ConfigurationManager configurationManager;</span>
<span class="source-line-no">576</span><span id="line-576"></span>
<span class="source-line-no">577</span><span id="line-577">  private BrokenStoreFileCleaner brokenStoreFileCleaner;</span>
<span class="source-line-no">578</span><span id="line-578"></span>
<span class="source-line-no">579</span><span id="line-579">  private RSMobFileCleanerChore rsMobFileCleanerChore;</span>
<span class="source-line-no">580</span><span id="line-580"></span>
<span class="source-line-no">581</span><span id="line-581">  @InterfaceAudience.Private</span>
<span class="source-line-no">582</span><span id="line-582">  CompactedHFilesDischarger compactedFileDischarger;</span>
<span class="source-line-no">583</span><span id="line-583"></span>
<span class="source-line-no">584</span><span id="line-584">  private volatile ThroughputController flushThroughputController;</span>
<span class="source-line-no">585</span><span id="line-585"></span>
<span class="source-line-no">586</span><span id="line-586">  private SecureBulkLoadManager secureBulkLoadManager;</span>
<span class="source-line-no">587</span><span id="line-587"></span>
<span class="source-line-no">588</span><span id="line-588">  private FileSystemUtilizationChore fsUtilizationChore;</span>
<span class="source-line-no">589</span><span id="line-589"></span>
<span class="source-line-no">590</span><span id="line-590">  private final NettyEventLoopGroupConfig eventLoopGroupConfig;</span>
<span class="source-line-no">591</span><span id="line-591"></span>
<span class="source-line-no">592</span><span id="line-592">  /**</span>
<span class="source-line-no">593</span><span id="line-593">   * Provide online slow log responses from ringbuffer</span>
<span class="source-line-no">594</span><span id="line-594">   */</span>
<span class="source-line-no">595</span><span id="line-595">  private NamedQueueRecorder namedQueueRecorder = null;</span>
<span class="source-line-no">596</span><span id="line-596"></span>
<span class="source-line-no">597</span><span id="line-597">  private BootstrapNodeManager bootstrapNodeManager;</span>
<span class="source-line-no">598</span><span id="line-598"></span>
<span class="source-line-no">599</span><span id="line-599">  /**</span>
<span class="source-line-no">600</span><span id="line-600">   * True if this RegionServer is coming up in a cluster where there is no Master; means it needs to</span>
<span class="source-line-no">601</span><span id="line-601">   * just come up and make do without a Master to talk to: e.g. in test or HRegionServer is doing</span>
<span class="source-line-no">602</span><span id="line-602">   * other than its usual duties: e.g. as an hollowed-out host whose only purpose is as a</span>
<span class="source-line-no">603</span><span id="line-603">   * Replication-stream sink; see HBASE-18846 for more. TODO: can this replace</span>
<span class="source-line-no">604</span><span id="line-604">   * {@link #TEST_SKIP_REPORTING_TRANSITION} ?</span>
<span class="source-line-no">605</span><span id="line-605">   */</span>
<span class="source-line-no">606</span><span id="line-606">  private final boolean masterless;</span>
<span class="source-line-no">607</span><span id="line-607">  private static final String MASTERLESS_CONFIG_NAME = "hbase.masterless";</span>
<span class="source-line-no">608</span><span id="line-608"></span>
<span class="source-line-no">609</span><span id="line-609">  /** regionserver codec list **/</span>
<span class="source-line-no">610</span><span id="line-610">  private static final String REGIONSERVER_CODEC = "hbase.regionserver.codecs";</span>
<span class="source-line-no">611</span><span id="line-611"></span>
<span class="source-line-no">612</span><span id="line-612">  // A timer to shutdown the process if abort takes too long</span>
<span class="source-line-no">613</span><span id="line-613">  private Timer abortMonitor;</span>
<span class="source-line-no">614</span><span id="line-614"></span>
<span class="source-line-no">615</span><span id="line-615">  /*</span>
<span class="source-line-no">616</span><span id="line-616">   * Chore that creates replication marker rows.</span>
<span class="source-line-no">617</span><span id="line-617">   */</span>
<span class="source-line-no">618</span><span id="line-618">  private ReplicationMarkerChore replicationMarkerChore;</span>
<span class="source-line-no">619</span><span id="line-619"></span>
<span class="source-line-no">620</span><span id="line-620">  // A timer submit requests to the PrefetchExecutor</span>
<span class="source-line-no">621</span><span id="line-621">  private PrefetchExecutorNotifier prefetchExecutorNotifier;</span>
<span class="source-line-no">622</span><span id="line-622"></span>
<span class="source-line-no">623</span><span id="line-623">  /**</span>
<span class="source-line-no">624</span><span id="line-624">   * Starts a HRegionServer at the default location.</span>
<span class="source-line-no">625</span><span id="line-625">   * &lt;p/&gt;</span>
<span class="source-line-no">626</span><span id="line-626">   * Don't start any services or managers in here in the Constructor. Defer till after we register</span>
<span class="source-line-no">627</span><span id="line-627">   * with the Master as much as possible. See {@link #startServices}.</span>
<span class="source-line-no">628</span><span id="line-628">   */</span>
<span class="source-line-no">629</span><span id="line-629">  public HRegionServer(final Configuration conf) throws IOException {</span>
<span class="source-line-no">630</span><span id="line-630">    super("RegionServer"); // thread name</span>
<span class="source-line-no">631</span><span id="line-631">    final Span span = TraceUtil.createSpan("HRegionServer.cxtor");</span>
<span class="source-line-no">632</span><span id="line-632">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">633</span><span id="line-633">      this.startcode = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">634</span><span id="line-634">      this.conf = conf;</span>
<span class="source-line-no">635</span><span id="line-635">      this.dataFsOk = true;</span>
<span class="source-line-no">636</span><span id="line-636">      this.masterless = conf.getBoolean(MASTERLESS_CONFIG_NAME, false);</span>
<span class="source-line-no">637</span><span id="line-637">      this.eventLoopGroupConfig = setupNetty(this.conf);</span>
<span class="source-line-no">638</span><span id="line-638">      MemorySizeUtil.checkForClusterFreeHeapMemoryLimit(this.conf);</span>
<span class="source-line-no">639</span><span id="line-639">      HFile.checkHFileVersion(this.conf);</span>
<span class="source-line-no">640</span><span id="line-640">      checkCodecs(this.conf);</span>
<span class="source-line-no">641</span><span id="line-641">      this.userProvider = UserProvider.instantiate(conf);</span>
<span class="source-line-no">642</span><span id="line-642">      FSUtils.setupShortCircuitRead(this.conf);</span>
<span class="source-line-no">643</span><span id="line-643"></span>
<span class="source-line-no">644</span><span id="line-644">      // Disable usage of meta replicas in the regionserver</span>
<span class="source-line-no">645</span><span id="line-645">      this.conf.setBoolean(HConstants.USE_META_REPLICAS, false);</span>
<span class="source-line-no">646</span><span id="line-646">      // Config'ed params</span>
<span class="source-line-no">647</span><span id="line-647">      this.threadWakeFrequency = conf.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000);</span>
<span class="source-line-no">648</span><span id="line-648">      this.compactionCheckFrequency = conf.getInt(PERIOD_COMPACTION, this.threadWakeFrequency);</span>
<span class="source-line-no">649</span><span id="line-649">      this.flushCheckFrequency = conf.getInt(PERIOD_FLUSH, this.threadWakeFrequency);</span>
<span class="source-line-no">650</span><span id="line-650">      this.msgInterval = conf.getInt("hbase.regionserver.msginterval", 3 * 1000);</span>
<span class="source-line-no">651</span><span id="line-651"></span>
<span class="source-line-no">652</span><span id="line-652">      this.sleeper = new Sleeper(this.msgInterval, this);</span>
<span class="source-line-no">653</span><span id="line-653"></span>
<span class="source-line-no">654</span><span id="line-654">      boolean isNoncesEnabled = conf.getBoolean(HConstants.HBASE_RS_NONCES_ENABLED, true);</span>
<span class="source-line-no">655</span><span id="line-655">      this.nonceManager = isNoncesEnabled ? new ServerNonceManager(this.conf) : null;</span>
<span class="source-line-no">656</span><span id="line-656"></span>
<span class="source-line-no">657</span><span id="line-657">      this.operationTimeout = conf.getInt(HConstants.HBASE_CLIENT_OPERATION_TIMEOUT,</span>
<span class="source-line-no">658</span><span id="line-658">        HConstants.DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT);</span>
<span class="source-line-no">659</span><span id="line-659"></span>
<span class="source-line-no">660</span><span id="line-660">      this.shortOperationTimeout = conf.getInt(HConstants.HBASE_RPC_SHORTOPERATION_TIMEOUT_KEY,</span>
<span class="source-line-no">661</span><span id="line-661">        HConstants.DEFAULT_HBASE_RPC_SHORTOPERATION_TIMEOUT);</span>
<span class="source-line-no">662</span><span id="line-662"></span>
<span class="source-line-no">663</span><span id="line-663">      this.retryPauseTime = conf.getLong(HConstants.HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME,</span>
<span class="source-line-no">664</span><span id="line-664">        HConstants.DEFAULT_HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME);</span>
<span class="source-line-no">665</span><span id="line-665"></span>
<span class="source-line-no">666</span><span id="line-666">      this.abortRequested = new AtomicBoolean(false);</span>
<span class="source-line-no">667</span><span id="line-667">      this.stopped = false;</span>
<span class="source-line-no">668</span><span id="line-668"></span>
<span class="source-line-no">669</span><span id="line-669">      this.namedQueueRecorder = NamedQueueRecorder.getInstance(this.conf);</span>
<span class="source-line-no">670</span><span id="line-670">      rpcServices = createRpcServices();</span>
<span class="source-line-no">671</span><span id="line-671">      useThisHostnameInstead = getUseThisHostnameInstead(conf);</span>
<span class="source-line-no">672</span><span id="line-672"></span>
<span class="source-line-no">673</span><span id="line-673">      // if use-ip is enabled, we will use ip to expose Master/RS service for client,</span>
<span class="source-line-no">674</span><span id="line-674">      // see HBASE-27304 for details.</span>
<span class="source-line-no">675</span><span id="line-675">      boolean useIp = conf.getBoolean(HConstants.HBASE_SERVER_USEIP_ENABLED_KEY,</span>
<span class="source-line-no">676</span><span id="line-676">        HConstants.HBASE_SERVER_USEIP_ENABLED_DEFAULT);</span>
<span class="source-line-no">677</span><span id="line-677">      String isaHostName =</span>
<span class="source-line-no">678</span><span id="line-678">        useIp ? rpcServices.isa.getAddress().getHostAddress() : rpcServices.isa.getHostName();</span>
<span class="source-line-no">679</span><span id="line-679">      String hostName =</span>
<span class="source-line-no">680</span><span id="line-680">        StringUtils.isBlank(useThisHostnameInstead) ? isaHostName : useThisHostnameInstead;</span>
<span class="source-line-no">681</span><span id="line-681">      serverName = ServerName.valueOf(hostName, this.rpcServices.isa.getPort(), this.startcode);</span>
<span class="source-line-no">682</span><span id="line-682"></span>
<span class="source-line-no">683</span><span id="line-683">      rpcControllerFactory = RpcControllerFactory.instantiate(this.conf);</span>
<span class="source-line-no">684</span><span id="line-684">      rpcRetryingCallerFactory = RpcRetryingCallerFactory.instantiate(this.conf,</span>
<span class="source-line-no">685</span><span id="line-685">        clusterConnection == null ? null : clusterConnection.getConnectionMetrics());</span>
<span class="source-line-no">686</span><span id="line-686"></span>
<span class="source-line-no">687</span><span id="line-687">      // login the zookeeper client principal (if using security)</span>
<span class="source-line-no">688</span><span id="line-688">      ZKAuthentication.loginClient(this.conf, HConstants.ZK_CLIENT_KEYTAB_FILE,</span>
<span class="source-line-no">689</span><span id="line-689">        HConstants.ZK_CLIENT_KERBEROS_PRINCIPAL, hostName);</span>
<span class="source-line-no">690</span><span id="line-690">      // login the server principal (if using secure Hadoop)</span>
<span class="source-line-no">691</span><span id="line-691">      login(userProvider, hostName);</span>
<span class="source-line-no">692</span><span id="line-692">      // init superusers and add the server principal (if using security)</span>
<span class="source-line-no">693</span><span id="line-693">      // or process owner as default super user.</span>
<span class="source-line-no">694</span><span id="line-694">      Superusers.initialize(conf);</span>
<span class="source-line-no">695</span><span id="line-695">      regionServerAccounting = new RegionServerAccounting(conf);</span>
<span class="source-line-no">696</span><span id="line-696"></span>
<span class="source-line-no">697</span><span id="line-697">      boolean isMasterNotCarryTable =</span>
<span class="source-line-no">698</span><span id="line-698">        this instanceof HMaster &amp;&amp; !LoadBalancer.isTablesOnMaster(conf);</span>
<span class="source-line-no">699</span><span id="line-699"></span>
<span class="source-line-no">700</span><span id="line-700">      // no need to instantiate block cache and mob file cache when master not carry table</span>
<span class="source-line-no">701</span><span id="line-701">      if (!isMasterNotCarryTable) {</span>
<span class="source-line-no">702</span><span id="line-702">        blockCache = BlockCacheFactory.createBlockCache(conf);</span>
<span class="source-line-no">703</span><span id="line-703">        mobFileCache = new MobFileCache(conf);</span>
<span class="source-line-no">704</span><span id="line-704">      }</span>
<span class="source-line-no">705</span><span id="line-705"></span>
<span class="source-line-no">706</span><span id="line-706">      rsSnapshotVerifier = new RSSnapshotVerifier(conf);</span>
<span class="source-line-no">707</span><span id="line-707"></span>
<span class="source-line-no">708</span><span id="line-708">      uncaughtExceptionHandler =</span>
<span class="source-line-no">709</span><span id="line-709">        (t, e) -&gt; abort("Uncaught exception in executorService thread " + t.getName(), e);</span>
<span class="source-line-no">710</span><span id="line-710"></span>
<span class="source-line-no">711</span><span id="line-711">      initializeFileSystem();</span>
<span class="source-line-no">712</span><span id="line-712"></span>
<span class="source-line-no">713</span><span id="line-713">      this.configurationManager = new ConfigurationManager();</span>
<span class="source-line-no">714</span><span id="line-714">      setupSignalHandlers();</span>
<span class="source-line-no">715</span><span id="line-715"></span>
<span class="source-line-no">716</span><span id="line-716">      // Some unit tests don't need a cluster, so no zookeeper at all</span>
<span class="source-line-no">717</span><span id="line-717">      // Open connection to zookeeper and set primary watcher</span>
<span class="source-line-no">718</span><span id="line-718">      zooKeeper = new ZKWatcher(conf, getProcessName() + ":" + rpcServices.isa.getPort(), this,</span>
<span class="source-line-no">719</span><span id="line-719">        canCreateBaseZNode());</span>
<span class="source-line-no">720</span><span id="line-720">      // If no master in cluster, skip trying to track one or look for a cluster status.</span>
<span class="source-line-no">721</span><span id="line-721">      if (!this.masterless) {</span>
<span class="source-line-no">722</span><span id="line-722">        if (</span>
<span class="source-line-no">723</span><span id="line-723">          conf.getBoolean(HBASE_SPLIT_WAL_COORDINATED_BY_ZK, DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK)</span>
<span class="source-line-no">724</span><span id="line-724">        ) {</span>
<span class="source-line-no">725</span><span id="line-725">          this.csm = new ZkCoordinatedStateManager(this);</span>
<span class="source-line-no">726</span><span id="line-726">        }</span>
<span class="source-line-no">727</span><span id="line-727"></span>
<span class="source-line-no">728</span><span id="line-728">        masterAddressTracker = new MasterAddressTracker(getZooKeeper(), this);</span>
<span class="source-line-no">729</span><span id="line-729">        masterAddressTracker.start();</span>
<span class="source-line-no">730</span><span id="line-730"></span>
<span class="source-line-no">731</span><span id="line-731">        clusterStatusTracker = new ClusterStatusTracker(zooKeeper, this);</span>
<span class="source-line-no">732</span><span id="line-732">        clusterStatusTracker.start();</span>
<span class="source-line-no">733</span><span id="line-733">      } else {</span>
<span class="source-line-no">734</span><span id="line-734">        masterAddressTracker = null;</span>
<span class="source-line-no">735</span><span id="line-735">        clusterStatusTracker = null;</span>
<span class="source-line-no">736</span><span id="line-736">      }</span>
<span class="source-line-no">737</span><span id="line-737">      this.rpcServices.start(zooKeeper);</span>
<span class="source-line-no">738</span><span id="line-738">      this.metaRegionLocationCache = new MetaRegionLocationCache(zooKeeper);</span>
<span class="source-line-no">739</span><span id="line-739">      // This violates 'no starting stuff in Constructor' but Master depends on the below chore</span>
<span class="source-line-no">740</span><span id="line-740">      // and executor being created and takes a different startup route. Lots of overlap between HRS</span>
<span class="source-line-no">741</span><span id="line-741">      // and M (An M IS A HRS now). Need to refactor so less duplication between M and its super</span>
<span class="source-line-no">742</span><span id="line-742">      // Master expects Constructor to put up web servers. Ugh.</span>
<span class="source-line-no">743</span><span id="line-743">      // class HRS. TODO.</span>
<span class="source-line-no">744</span><span id="line-744">      int choreServiceInitialSize =</span>
<span class="source-line-no">745</span><span id="line-745">        conf.getInt(CHORE_SERVICE_INITIAL_POOL_SIZE, DEFAULT_CHORE_SERVICE_INITIAL_POOL_SIZE);</span>
<span class="source-line-no">746</span><span id="line-746">      this.choreService = new ChoreService(getName(), choreServiceInitialSize, true);</span>
<span class="source-line-no">747</span><span id="line-747">      this.executorService = new ExecutorService(getName());</span>
<span class="source-line-no">748</span><span id="line-748">      putUpWebUI();</span>
<span class="source-line-no">749</span><span id="line-749">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">750</span><span id="line-750">    } catch (Throwable t) {</span>
<span class="source-line-no">751</span><span id="line-751">      // Make sure we log the exception. HRegionServer is often started via reflection and the</span>
<span class="source-line-no">752</span><span id="line-752">      // cause of failed startup is lost.</span>
<span class="source-line-no">753</span><span id="line-753">      TraceUtil.setError(span, t);</span>
<span class="source-line-no">754</span><span id="line-754">      LOG.error("Failed construction RegionServer", t);</span>
<span class="source-line-no">755</span><span id="line-755">      throw t;</span>
<span class="source-line-no">756</span><span id="line-756">    } finally {</span>
<span class="source-line-no">757</span><span id="line-757">      span.end();</span>
<span class="source-line-no">758</span><span id="line-758">    }</span>
<span class="source-line-no">759</span><span id="line-759">  }</span>
<span class="source-line-no">760</span><span id="line-760"></span>
<span class="source-line-no">761</span><span id="line-761">  // HMaster should override this method to load the specific config for master</span>
<span class="source-line-no">762</span><span id="line-762">  protected String getUseThisHostnameInstead(Configuration conf) throws IOException {</span>
<span class="source-line-no">763</span><span id="line-763">    String hostname = conf.get(UNSAFE_RS_HOSTNAME_KEY);</span>
<span class="source-line-no">764</span><span id="line-764">    if (conf.getBoolean(UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY, false)) {</span>
<span class="source-line-no">765</span><span id="line-765">      if (!StringUtils.isBlank(hostname)) {</span>
<span class="source-line-no">766</span><span id="line-766">        String msg = UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " and "</span>
<span class="source-line-no">767</span><span id="line-767">          + UNSAFE_RS_HOSTNAME_KEY + " are mutually exclusive. Do not set "</span>
<span class="source-line-no">768</span><span id="line-768">          + UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " to true while "</span>
<span class="source-line-no">769</span><span id="line-769">          + UNSAFE_RS_HOSTNAME_KEY + " is used";</span>
<span class="source-line-no">770</span><span id="line-770">        throw new IOException(msg);</span>
<span class="source-line-no">771</span><span id="line-771">      } else {</span>
<span class="source-line-no">772</span><span id="line-772">        return rpcServices.isa.getHostName();</span>
<span class="source-line-no">773</span><span id="line-773">      }</span>
<span class="source-line-no">774</span><span id="line-774">    } else {</span>
<span class="source-line-no">775</span><span id="line-775">      return hostname;</span>
<span class="source-line-no">776</span><span id="line-776">    }</span>
<span class="source-line-no">777</span><span id="line-777">  }</span>
<span class="source-line-no">778</span><span id="line-778"></span>
<span class="source-line-no">779</span><span id="line-779">  private void setupSignalHandlers() {</span>
<span class="source-line-no">780</span><span id="line-780">    if (!SystemUtils.IS_OS_WINDOWS) {</span>
<span class="source-line-no">781</span><span id="line-781">      HBasePlatformDependent.handle("HUP", (number, name) -&gt; {</span>
<span class="source-line-no">782</span><span id="line-782">        try {</span>
<span class="source-line-no">783</span><span id="line-783">          updateConfiguration();</span>
<span class="source-line-no">784</span><span id="line-784">        } catch (IOException e) {</span>
<span class="source-line-no">785</span><span id="line-785">          LOG.error("Problem while reloading configuration", e);</span>
<span class="source-line-no">786</span><span id="line-786">        }</span>
<span class="source-line-no">787</span><span id="line-787">      });</span>
<span class="source-line-no">788</span><span id="line-788">    }</span>
<span class="source-line-no">789</span><span id="line-789">  }</span>
<span class="source-line-no">790</span><span id="line-790"></span>
<span class="source-line-no">791</span><span id="line-791">  private static NettyEventLoopGroupConfig setupNetty(Configuration conf) {</span>
<span class="source-line-no">792</span><span id="line-792">    // Initialize netty event loop group at start as we may use it for rpc server, rpc client &amp; WAL.</span>
<span class="source-line-no">793</span><span id="line-793">    NettyEventLoopGroupConfig nelgc = new NettyEventLoopGroupConfig(conf, "RS-EventLoopGroup");</span>
<span class="source-line-no">794</span><span id="line-794">    NettyRpcClientConfigHelper.setEventLoopConfig(conf, nelgc.group(), nelgc.clientChannelClass());</span>
<span class="source-line-no">795</span><span id="line-795">    NettyAsyncFSWALConfigHelper.setEventLoopConfig(conf, nelgc.group(), nelgc.clientChannelClass());</span>
<span class="source-line-no">796</span><span id="line-796">    return nelgc;</span>
<span class="source-line-no">797</span><span id="line-797">  }</span>
<span class="source-line-no">798</span><span id="line-798"></span>
<span class="source-line-no">799</span><span id="line-799">  private void initializeFileSystem() throws IOException {</span>
<span class="source-line-no">800</span><span id="line-800">    // Get fs instance used by this RS. Do we use checksum verification in the hbase? If hbase</span>
<span class="source-line-no">801</span><span id="line-801">    // checksum verification enabled, then automatically switch off hdfs checksum verification.</span>
<span class="source-line-no">802</span><span id="line-802">    boolean useHBaseChecksum = conf.getBoolean(HConstants.HBASE_CHECKSUM_VERIFICATION, true);</span>
<span class="source-line-no">803</span><span id="line-803">    String walDirUri = CommonFSUtils.getDirUri(this.conf,</span>
<span class="source-line-no">804</span><span id="line-804">      new Path(conf.get(CommonFSUtils.HBASE_WAL_DIR, conf.get(HConstants.HBASE_DIR))));</span>
<span class="source-line-no">805</span><span id="line-805">    // set WAL's uri</span>
<span class="source-line-no">806</span><span id="line-806">    if (walDirUri != null) {</span>
<span class="source-line-no">807</span><span id="line-807">      CommonFSUtils.setFsDefault(this.conf, walDirUri);</span>
<span class="source-line-no">808</span><span id="line-808">    }</span>
<span class="source-line-no">809</span><span id="line-809">    // init the WALFs</span>
<span class="source-line-no">810</span><span id="line-810">    this.walFs = new HFileSystem(this.conf, useHBaseChecksum);</span>
<span class="source-line-no">811</span><span id="line-811">    this.walRootDir = CommonFSUtils.getWALRootDir(this.conf);</span>
<span class="source-line-no">812</span><span id="line-812">    // Set 'fs.defaultFS' to match the filesystem on hbase.rootdir else</span>
<span class="source-line-no">813</span><span id="line-813">    // underlying hadoop hdfs accessors will be going against wrong filesystem</span>
<span class="source-line-no">814</span><span id="line-814">    // (unless all is set to defaults).</span>
<span class="source-line-no">815</span><span id="line-815">    String rootDirUri =</span>
<span class="source-line-no">816</span><span id="line-816">      CommonFSUtils.getDirUri(this.conf, new Path(conf.get(HConstants.HBASE_DIR)));</span>
<span class="source-line-no">817</span><span id="line-817">    if (rootDirUri != null) {</span>
<span class="source-line-no">818</span><span id="line-818">      CommonFSUtils.setFsDefault(this.conf, rootDirUri);</span>
<span class="source-line-no">819</span><span id="line-819">    }</span>
<span class="source-line-no">820</span><span id="line-820">    // init the filesystem</span>
<span class="source-line-no">821</span><span id="line-821">    this.dataFs = new HFileSystem(this.conf, useHBaseChecksum);</span>
<span class="source-line-no">822</span><span id="line-822">    this.dataRootDir = CommonFSUtils.getRootDir(this.conf);</span>
<span class="source-line-no">823</span><span id="line-823">    this.tableDescriptors = new FSTableDescriptors(this.dataFs, this.dataRootDir,</span>
<span class="source-line-no">824</span><span id="line-824">      !canUpdateTableDescriptor(), cacheTableDescriptor());</span>
<span class="source-line-no">825</span><span id="line-825">  }</span>
<span class="source-line-no">826</span><span id="line-826"></span>
<span class="source-line-no">827</span><span id="line-827">  protected void login(UserProvider user, String host) throws IOException {</span>
<span class="source-line-no">828</span><span id="line-828">    user.login(SecurityConstants.REGIONSERVER_KRB_KEYTAB_FILE,</span>
<span class="source-line-no">829</span><span id="line-829">      SecurityConstants.REGIONSERVER_KRB_PRINCIPAL, host);</span>
<span class="source-line-no">830</span><span id="line-830">  }</span>
<span class="source-line-no">831</span><span id="line-831"></span>
<span class="source-line-no">832</span><span id="line-832">  /**</span>
<span class="source-line-no">833</span><span id="line-833">   * Wait for an active Master. See override in Master superclass for how it is used.</span>
<span class="source-line-no">834</span><span id="line-834">   */</span>
<span class="source-line-no">835</span><span id="line-835">  protected void waitForMasterActive() {</span>
<span class="source-line-no">836</span><span id="line-836">  }</span>
<span class="source-line-no">837</span><span id="line-837"></span>
<span class="source-line-no">838</span><span id="line-838">  protected String getProcessName() {</span>
<span class="source-line-no">839</span><span id="line-839">    return REGIONSERVER;</span>
<span class="source-line-no">840</span><span id="line-840">  }</span>
<span class="source-line-no">841</span><span id="line-841"></span>
<span class="source-line-no">842</span><span id="line-842">  protected boolean canCreateBaseZNode() {</span>
<span class="source-line-no">843</span><span id="line-843">    return this.masterless;</span>
<span class="source-line-no">844</span><span id="line-844">  }</span>
<span class="source-line-no">845</span><span id="line-845"></span>
<span class="source-line-no">846</span><span id="line-846">  protected boolean canUpdateTableDescriptor() {</span>
<span class="source-line-no">847</span><span id="line-847">    return false;</span>
<span class="source-line-no">848</span><span id="line-848">  }</span>
<span class="source-line-no">849</span><span id="line-849"></span>
<span class="source-line-no">850</span><span id="line-850">  protected boolean cacheTableDescriptor() {</span>
<span class="source-line-no">851</span><span id="line-851">    return false;</span>
<span class="source-line-no">852</span><span id="line-852">  }</span>
<span class="source-line-no">853</span><span id="line-853"></span>
<span class="source-line-no">854</span><span id="line-854">  protected RSRpcServices createRpcServices() throws IOException {</span>
<span class="source-line-no">855</span><span id="line-855">    return new RSRpcServices(this);</span>
<span class="source-line-no">856</span><span id="line-856">  }</span>
<span class="source-line-no">857</span><span id="line-857"></span>
<span class="source-line-no">858</span><span id="line-858">  protected void configureInfoServer() {</span>
<span class="source-line-no">859</span><span id="line-859">    infoServer.addUnprivilegedServlet("rs-status", "/rs-status", RSStatusServlet.class);</span>
<span class="source-line-no">860</span><span id="line-860">    infoServer.setAttribute(REGIONSERVER, this);</span>
<span class="source-line-no">861</span><span id="line-861">  }</span>
<span class="source-line-no">862</span><span id="line-862"></span>
<span class="source-line-no">863</span><span id="line-863">  protected Class&lt;? extends HttpServlet&gt; getDumpServlet() {</span>
<span class="source-line-no">864</span><span id="line-864">    return RSDumpServlet.class;</span>
<span class="source-line-no">865</span><span id="line-865">  }</span>
<span class="source-line-no">866</span><span id="line-866"></span>
<span class="source-line-no">867</span><span id="line-867">  /**</span>
<span class="source-line-no">868</span><span id="line-868">   * Used by {@link RSDumpServlet} to generate debugging information.</span>
<span class="source-line-no">869</span><span id="line-869">   */</span>
<span class="source-line-no">870</span><span id="line-870">  public void dumpRowLocks(final PrintWriter out) {</span>
<span class="source-line-no">871</span><span id="line-871">    StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">872</span><span id="line-872">    for (HRegion region : getRegions()) {</span>
<span class="source-line-no">873</span><span id="line-873">      if (region.getLockedRows().size() &gt; 0) {</span>
<span class="source-line-no">874</span><span id="line-874">        for (HRegion.RowLockContext rowLockContext : region.getLockedRows().values()) {</span>
<span class="source-line-no">875</span><span id="line-875">          sb.setLength(0);</span>
<span class="source-line-no">876</span><span id="line-876">          sb.append(region.getTableDescriptor().getTableName()).append(",")</span>
<span class="source-line-no">877</span><span id="line-877">            .append(region.getRegionInfo().getEncodedName()).append(",");</span>
<span class="source-line-no">878</span><span id="line-878">          sb.append(rowLockContext.toString());</span>
<span class="source-line-no">879</span><span id="line-879">          out.println(sb);</span>
<span class="source-line-no">880</span><span id="line-880">        }</span>
<span class="source-line-no">881</span><span id="line-881">      }</span>
<span class="source-line-no">882</span><span id="line-882">    }</span>
<span class="source-line-no">883</span><span id="line-883">  }</span>
<span class="source-line-no">884</span><span id="line-884"></span>
<span class="source-line-no">885</span><span id="line-885">  @Override</span>
<span class="source-line-no">886</span><span id="line-886">  public boolean registerService(com.google.protobuf.Service instance) {</span>
<span class="source-line-no">887</span><span id="line-887">    /*</span>
<span class="source-line-no">888</span><span id="line-888">     * No stacking of instances is allowed for a single executorService name</span>
<span class="source-line-no">889</span><span id="line-889">     */</span>
<span class="source-line-no">890</span><span id="line-890">    com.google.protobuf.Descriptors.ServiceDescriptor serviceDesc = instance.getDescriptorForType();</span>
<span class="source-line-no">891</span><span id="line-891">    String serviceName = CoprocessorRpcUtils.getServiceName(serviceDesc);</span>
<span class="source-line-no">892</span><span id="line-892">    if (coprocessorServiceHandlers.containsKey(serviceName)) {</span>
<span class="source-line-no">893</span><span id="line-893">      LOG.error("Coprocessor executorService " + serviceName</span>
<span class="source-line-no">894</span><span id="line-894">        + " already registered, rejecting request from " + instance);</span>
<span class="source-line-no">895</span><span id="line-895">      return false;</span>
<span class="source-line-no">896</span><span id="line-896">    }</span>
<span class="source-line-no">897</span><span id="line-897"></span>
<span class="source-line-no">898</span><span id="line-898">    coprocessorServiceHandlers.put(serviceName, instance);</span>
<span class="source-line-no">899</span><span id="line-899">    if (LOG.isDebugEnabled()) {</span>
<span class="source-line-no">900</span><span id="line-900">      LOG.debug(</span>
<span class="source-line-no">901</span><span id="line-901">        "Registered regionserver coprocessor executorService: executorService=" + serviceName);</span>
<span class="source-line-no">902</span><span id="line-902">    }</span>
<span class="source-line-no">903</span><span id="line-903">    return true;</span>
<span class="source-line-no">904</span><span id="line-904">  }</span>
<span class="source-line-no">905</span><span id="line-905"></span>
<span class="source-line-no">906</span><span id="line-906">  protected ClusterConnection createClusterConnection() throws IOException {</span>
<span class="source-line-no">907</span><span id="line-907">    // Create a cluster connection that when appropriate, can short-circuit and go directly to the</span>
<span class="source-line-no">908</span><span id="line-908">    // local server if the request is to the local server bypassing RPC. Can be used for both local</span>
<span class="source-line-no">909</span><span id="line-909">    // and remote invocations.</span>
<span class="source-line-no">910</span><span id="line-910">    return ServerConnectionUtils.createShortCircuitConnection(conf, userProvider.getCurrent(),</span>
<span class="source-line-no">911</span><span id="line-911">      serverName, rpcServices, rpcServices, new RegionServerRegistry(this));</span>
<span class="source-line-no">912</span><span id="line-912">  }</span>
<span class="source-line-no">913</span><span id="line-913"></span>
<span class="source-line-no">914</span><span id="line-914">  /**</span>
<span class="source-line-no">915</span><span id="line-915">   * Run test on configured codecs to make sure supporting libs are in place.</span>
<span class="source-line-no">916</span><span id="line-916">   * @param c configuration object</span>
<span class="source-line-no">917</span><span id="line-917">   * @throws IOException if compression test fails for any regionserver codec</span>
<span class="source-line-no">918</span><span id="line-918">   */</span>
<span class="source-line-no">919</span><span id="line-919">  private static void checkCodecs(final Configuration c) throws IOException {</span>
<span class="source-line-no">920</span><span id="line-920">    // check to see if the codec list is available:</span>
<span class="source-line-no">921</span><span id="line-921">    String[] codecs = c.getStrings(REGIONSERVER_CODEC, (String[]) null);</span>
<span class="source-line-no">922</span><span id="line-922">    if (codecs == null) {</span>
<span class="source-line-no">923</span><span id="line-923">      return;</span>
<span class="source-line-no">924</span><span id="line-924">    }</span>
<span class="source-line-no">925</span><span id="line-925">    for (String codec : codecs) {</span>
<span class="source-line-no">926</span><span id="line-926">      if (!CompressionTest.testCompression(codec)) {</span>
<span class="source-line-no">927</span><span id="line-927">        throw new IOException(</span>
<span class="source-line-no">928</span><span id="line-928">          "Compression codec " + codec + " not supported, aborting RS construction");</span>
<span class="source-line-no">929</span><span id="line-929">      }</span>
<span class="source-line-no">930</span><span id="line-930">    }</span>
<span class="source-line-no">931</span><span id="line-931">  }</span>
<span class="source-line-no">932</span><span id="line-932"></span>
<span class="source-line-no">933</span><span id="line-933">  public String getClusterId() {</span>
<span class="source-line-no">934</span><span id="line-934">    return this.clusterId;</span>
<span class="source-line-no">935</span><span id="line-935">  }</span>
<span class="source-line-no">936</span><span id="line-936"></span>
<span class="source-line-no">937</span><span id="line-937">  /**</span>
<span class="source-line-no">938</span><span id="line-938">   * Setup our cluster connection if not already initialized.</span>
<span class="source-line-no">939</span><span id="line-939">   */</span>
<span class="source-line-no">940</span><span id="line-940">  protected synchronized void setupClusterConnection() throws IOException {</span>
<span class="source-line-no">941</span><span id="line-941">    if (clusterConnection == null) {</span>
<span class="source-line-no">942</span><span id="line-942">      clusterConnection = createClusterConnection();</span>
<span class="source-line-no">943</span><span id="line-943">    }</span>
<span class="source-line-no">944</span><span id="line-944">  }</span>
<span class="source-line-no">945</span><span id="line-945"></span>
<span class="source-line-no">946</span><span id="line-946">  /**</span>
<span class="source-line-no">947</span><span id="line-947">   * All initialization needed before we go register with Master.&lt;br&gt;</span>
<span class="source-line-no">948</span><span id="line-948">   * Do bare minimum. Do bulk of initializations AFTER we've connected to the Master.&lt;br&gt;</span>
<span class="source-line-no">949</span><span id="line-949">   * In here we just put up the RpcServer, setup Connection, and ZooKeeper.</span>
<span class="source-line-no">950</span><span id="line-950">   */</span>
<span class="source-line-no">951</span><span id="line-951">  private void preRegistrationInitialization() {</span>
<span class="source-line-no">952</span><span id="line-952">    final Span span = TraceUtil.createSpan("HRegionServer.preRegistrationInitialization");</span>
<span class="source-line-no">953</span><span id="line-953">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">954</span><span id="line-954">      initializeZooKeeper();</span>
<span class="source-line-no">955</span><span id="line-955">      setupClusterConnection();</span>
<span class="source-line-no">956</span><span id="line-956">      if (!(this instanceof HMaster)) {</span>
<span class="source-line-no">957</span><span id="line-957">        bootstrapNodeManager = new BootstrapNodeManager(clusterConnection, masterAddressTracker);</span>
<span class="source-line-no">958</span><span id="line-958">      }</span>
<span class="source-line-no">959</span><span id="line-959">      // Setup RPC client for master communication</span>
<span class="source-line-no">960</span><span id="line-960">      this.rpcClient = RpcClientFactory.createClient(conf, clusterId,</span>
<span class="source-line-no">961</span><span id="line-961">        new InetSocketAddress(this.rpcServices.isa.getAddress(), 0),</span>
<span class="source-line-no">962</span><span id="line-962">        clusterConnection.getConnectionMetrics(), Collections.emptyMap());</span>
<span class="source-line-no">963</span><span id="line-963">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">964</span><span id="line-964">    } catch (Throwable t) {</span>
<span class="source-line-no">965</span><span id="line-965">      // Call stop if error or process will stick around for ever since server</span>
<span class="source-line-no">966</span><span id="line-966">      // puts up non-daemon threads.</span>
<span class="source-line-no">967</span><span id="line-967">      TraceUtil.setError(span, t);</span>
<span class="source-line-no">968</span><span id="line-968">      this.rpcServices.stop();</span>
<span class="source-line-no">969</span><span id="line-969">      abort("Initialization of RS failed.  Hence aborting RS.", t);</span>
<span class="source-line-no">970</span><span id="line-970">    } finally {</span>
<span class="source-line-no">971</span><span id="line-971">      span.end();</span>
<span class="source-line-no">972</span><span id="line-972">    }</span>
<span class="source-line-no">973</span><span id="line-973">  }</span>
<span class="source-line-no">974</span><span id="line-974"></span>
<span class="source-line-no">975</span><span id="line-975">  /**</span>
<span class="source-line-no">976</span><span id="line-976">   * Bring up connection to zk ensemble and then wait until a master for this cluster and then after</span>
<span class="source-line-no">977</span><span id="line-977">   * that, wait until cluster 'up' flag has been set. This is the order in which master does things.</span>
<span class="source-line-no">978</span><span id="line-978">   * &lt;p&gt;</span>
<span class="source-line-no">979</span><span id="line-979">   * Finally open long-living server short-circuit connection.</span>
<span class="source-line-no">980</span><span id="line-980">   */</span>
<span class="source-line-no">981</span><span id="line-981">  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RV_RETURN_VALUE_IGNORED_BAD_PRACTICE",</span>
<span class="source-line-no">982</span><span id="line-982">      justification = "cluster Id znode read would give us correct response")</span>
<span class="source-line-no">983</span><span id="line-983">  private void initializeZooKeeper() throws IOException, InterruptedException {</span>
<span class="source-line-no">984</span><span id="line-984">    // Nothing to do in here if no Master in the mix.</span>
<span class="source-line-no">985</span><span id="line-985">    if (this.masterless) {</span>
<span class="source-line-no">986</span><span id="line-986">      return;</span>
<span class="source-line-no">987</span><span id="line-987">    }</span>
<span class="source-line-no">988</span><span id="line-988"></span>
<span class="source-line-no">989</span><span id="line-989">    // Create the master address tracker, register with zk, and start it. Then</span>
<span class="source-line-no">990</span><span id="line-990">    // block until a master is available. No point in starting up if no master</span>
<span class="source-line-no">991</span><span id="line-991">    // running.</span>
<span class="source-line-no">992</span><span id="line-992">    blockAndCheckIfStopped(this.masterAddressTracker);</span>
<span class="source-line-no">993</span><span id="line-993"></span>
<span class="source-line-no">994</span><span id="line-994">    // Wait on cluster being up. Master will set this flag up in zookeeper</span>
<span class="source-line-no">995</span><span id="line-995">    // when ready.</span>
<span class="source-line-no">996</span><span id="line-996">    blockAndCheckIfStopped(this.clusterStatusTracker);</span>
<span class="source-line-no">997</span><span id="line-997"></span>
<span class="source-line-no">998</span><span id="line-998">    // If we are HMaster then the cluster id should have already been set.</span>
<span class="source-line-no">999</span><span id="line-999">    if (clusterId == null) {</span>
<span class="source-line-no">1000</span><span id="line-1000">      // Retrieve clusterId</span>
<span class="source-line-no">1001</span><span id="line-1001">      // Since cluster status is now up</span>
<span class="source-line-no">1002</span><span id="line-1002">      // ID should have already been set by HMaster</span>
<span class="source-line-no">1003</span><span id="line-1003">      try {</span>
<span class="source-line-no">1004</span><span id="line-1004">        clusterId = ZKClusterId.readClusterIdZNode(this.zooKeeper);</span>
<span class="source-line-no">1005</span><span id="line-1005">        if (clusterId == null) {</span>
<span class="source-line-no">1006</span><span id="line-1006">          this.abort("Cluster ID has not been set");</span>
<span class="source-line-no">1007</span><span id="line-1007">        }</span>
<span class="source-line-no">1008</span><span id="line-1008">        LOG.info("ClusterId : " + clusterId);</span>
<span class="source-line-no">1009</span><span id="line-1009">      } catch (KeeperException e) {</span>
<span class="source-line-no">1010</span><span id="line-1010">        this.abort("Failed to retrieve Cluster ID", e);</span>
<span class="source-line-no">1011</span><span id="line-1011">      }</span>
<span class="source-line-no">1012</span><span id="line-1012">    }</span>
<span class="source-line-no">1013</span><span id="line-1013"></span>
<span class="source-line-no">1014</span><span id="line-1014">    waitForMasterActive();</span>
<span class="source-line-no">1015</span><span id="line-1015">    if (isStopped() || isAborted()) {</span>
<span class="source-line-no">1016</span><span id="line-1016">      return; // No need for further initialization</span>
<span class="source-line-no">1017</span><span id="line-1017">    }</span>
<span class="source-line-no">1018</span><span id="line-1018"></span>
<span class="source-line-no">1019</span><span id="line-1019">    // watch for snapshots and other procedures</span>
<span class="source-line-no">1020</span><span id="line-1020">    try {</span>
<span class="source-line-no">1021</span><span id="line-1021">      rspmHost = new RegionServerProcedureManagerHost();</span>
<span class="source-line-no">1022</span><span id="line-1022">      rspmHost.loadProcedures(conf);</span>
<span class="source-line-no">1023</span><span id="line-1023">      rspmHost.initialize(this);</span>
<span class="source-line-no">1024</span><span id="line-1024">    } catch (KeeperException e) {</span>
<span class="source-line-no">1025</span><span id="line-1025">      this.abort("Failed to reach coordination cluster when creating procedure handler.", e);</span>
<span class="source-line-no">1026</span><span id="line-1026">    }</span>
<span class="source-line-no">1027</span><span id="line-1027">  }</span>
<span class="source-line-no">1028</span><span id="line-1028"></span>
<span class="source-line-no">1029</span><span id="line-1029">  /**</span>
<span class="source-line-no">1030</span><span id="line-1030">   * Utilty method to wait indefinitely on a znode availability while checking if the region server</span>
<span class="source-line-no">1031</span><span id="line-1031">   * is shut down</span>
<span class="source-line-no">1032</span><span id="line-1032">   * @param tracker znode tracker to use</span>
<span class="source-line-no">1033</span><span id="line-1033">   * @throws IOException          any IO exception, plus if the RS is stopped</span>
<span class="source-line-no">1034</span><span id="line-1034">   * @throws InterruptedException if the waiting thread is interrupted</span>
<span class="source-line-no">1035</span><span id="line-1035">   */</span>
<span class="source-line-no">1036</span><span id="line-1036">  private void blockAndCheckIfStopped(ZKNodeTracker tracker)</span>
<span class="source-line-no">1037</span><span id="line-1037">    throws IOException, InterruptedException {</span>
<span class="source-line-no">1038</span><span id="line-1038">    while (tracker.blockUntilAvailable(this.msgInterval, false) == null) {</span>
<span class="source-line-no">1039</span><span id="line-1039">      if (this.stopped) {</span>
<span class="source-line-no">1040</span><span id="line-1040">        throw new IOException("Received the shutdown message while waiting.");</span>
<span class="source-line-no">1041</span><span id="line-1041">      }</span>
<span class="source-line-no">1042</span><span id="line-1042">    }</span>
<span class="source-line-no">1043</span><span id="line-1043">  }</span>
<span class="source-line-no">1044</span><span id="line-1044"></span>
<span class="source-line-no">1045</span><span id="line-1045">  /** Returns True if the cluster is up. */</span>
<span class="source-line-no">1046</span><span id="line-1046">  @Override</span>
<span class="source-line-no">1047</span><span id="line-1047">  public boolean isClusterUp() {</span>
<span class="source-line-no">1048</span><span id="line-1048">    return this.masterless</span>
<span class="source-line-no">1049</span><span id="line-1049">      || (this.clusterStatusTracker != null &amp;&amp; this.clusterStatusTracker.isClusterUp());</span>
<span class="source-line-no">1050</span><span id="line-1050">  }</span>
<span class="source-line-no">1051</span><span id="line-1051"></span>
<span class="source-line-no">1052</span><span id="line-1052">  private void initializeReplicationMarkerChore() {</span>
<span class="source-line-no">1053</span><span id="line-1053">    boolean replicationMarkerEnabled =</span>
<span class="source-line-no">1054</span><span id="line-1054">      conf.getBoolean(REPLICATION_MARKER_ENABLED_KEY, REPLICATION_MARKER_ENABLED_DEFAULT);</span>
<span class="source-line-no">1055</span><span id="line-1055">    // If replication or replication marker is not enabled then return immediately.</span>
<span class="source-line-no">1056</span><span id="line-1056">    if (replicationMarkerEnabled) {</span>
<span class="source-line-no">1057</span><span id="line-1057">      int period = conf.getInt(REPLICATION_MARKER_CHORE_DURATION_KEY,</span>
<span class="source-line-no">1058</span><span id="line-1058">        REPLICATION_MARKER_CHORE_DURATION_DEFAULT);</span>
<span class="source-line-no">1059</span><span id="line-1059">      replicationMarkerChore = new ReplicationMarkerChore(this, this, period);</span>
<span class="source-line-no">1060</span><span id="line-1060">    }</span>
<span class="source-line-no">1061</span><span id="line-1061">  }</span>
<span class="source-line-no">1062</span><span id="line-1062"></span>
<span class="source-line-no">1063</span><span id="line-1063">  /**</span>
<span class="source-line-no">1064</span><span id="line-1064">   * The HRegionServer sticks in this loop until closed.</span>
<span class="source-line-no">1065</span><span id="line-1065">   */</span>
<span class="source-line-no">1066</span><span id="line-1066">  @Override</span>
<span class="source-line-no">1067</span><span id="line-1067">  public void run() {</span>
<span class="source-line-no">1068</span><span id="line-1068">    if (isStopped()) {</span>
<span class="source-line-no">1069</span><span id="line-1069">      LOG.info("Skipping run; stopped");</span>
<span class="source-line-no">1070</span><span id="line-1070">      return;</span>
<span class="source-line-no">1071</span><span id="line-1071">    }</span>
<span class="source-line-no">1072</span><span id="line-1072">    try {</span>
<span class="source-line-no">1073</span><span id="line-1073">      installShutdownHook();</span>
<span class="source-line-no">1074</span><span id="line-1074">      // Do pre-registration initializations; zookeeper, lease threads, etc.</span>
<span class="source-line-no">1075</span><span id="line-1075">      preRegistrationInitialization();</span>
<span class="source-line-no">1076</span><span id="line-1076">    } catch (Throwable e) {</span>
<span class="source-line-no">1077</span><span id="line-1077">      abort("Fatal exception during initialization", e);</span>
<span class="source-line-no">1078</span><span id="line-1078">    }</span>
<span class="source-line-no">1079</span><span id="line-1079"></span>
<span class="source-line-no">1080</span><span id="line-1080">    try {</span>
<span class="source-line-no">1081</span><span id="line-1081">      if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">1082</span><span id="line-1082">        // Initialize the RegionServerCoprocessorHost now that our ephemeral</span>
<span class="source-line-no">1083</span><span id="line-1083">        // node was created, in case any coprocessors want to use ZooKeeper</span>
<span class="source-line-no">1084</span><span id="line-1084">        this.rsHost = new RegionServerCoprocessorHost(this, this.conf);</span>
<span class="source-line-no">1085</span><span id="line-1085"></span>
<span class="source-line-no">1086</span><span id="line-1086">        // Try and register with the Master; tell it we are here. Break if server is stopped or</span>
<span class="source-line-no">1087</span><span id="line-1087">        // the clusterup flag is down or hdfs went wacky. Once registered successfully, go ahead and</span>
<span class="source-line-no">1088</span><span id="line-1088">        // start up all Services. Use RetryCounter to get backoff in case Master is struggling to</span>
<span class="source-line-no">1089</span><span id="line-1089">        // come up.</span>
<span class="source-line-no">1090</span><span id="line-1090">        LOG.debug("About to register with Master.");</span>
<span class="source-line-no">1091</span><span id="line-1091">        TraceUtil.trace(() -&gt; {</span>
<span class="source-line-no">1092</span><span id="line-1092">          RetryCounterFactory rcf =</span>
<span class="source-line-no">1093</span><span id="line-1093">            new RetryCounterFactory(Integer.MAX_VALUE, this.sleeper.getPeriod(), 1000 * 60 * 5);</span>
<span class="source-line-no">1094</span><span id="line-1094">          RetryCounter rc = rcf.create();</span>
<span class="source-line-no">1095</span><span id="line-1095">          while (keepLooping()) {</span>
<span class="source-line-no">1096</span><span id="line-1096">            RegionServerStartupResponse w = reportForDuty();</span>
<span class="source-line-no">1097</span><span id="line-1097">            if (w == null) {</span>
<span class="source-line-no">1098</span><span id="line-1098">              long sleepTime = rc.getBackoffTimeAndIncrementAttempts();</span>
<span class="source-line-no">1099</span><span id="line-1099">              LOG.warn("reportForDuty failed; sleeping {} ms and then retrying.", sleepTime);</span>
<span class="source-line-no">1100</span><span id="line-1100">              this.sleeper.sleep(sleepTime);</span>
<span class="source-line-no">1101</span><span id="line-1101">            } else {</span>
<span class="source-line-no">1102</span><span id="line-1102">              handleReportForDutyResponse(w);</span>
<span class="source-line-no">1103</span><span id="line-1103">              break;</span>
<span class="source-line-no">1104</span><span id="line-1104">            }</span>
<span class="source-line-no">1105</span><span id="line-1105">          }</span>
<span class="source-line-no">1106</span><span id="line-1106">        }, "HRegionServer.registerWithMaster");</span>
<span class="source-line-no">1107</span><span id="line-1107">      }</span>
<span class="source-line-no">1108</span><span id="line-1108"></span>
<span class="source-line-no">1109</span><span id="line-1109">      if (!isStopped() &amp;&amp; isHealthy()) {</span>
<span class="source-line-no">1110</span><span id="line-1110">        TraceUtil.trace(() -&gt; {</span>
<span class="source-line-no">1111</span><span id="line-1111">          // start the snapshot handler and other procedure handlers,</span>
<span class="source-line-no">1112</span><span id="line-1112">          // since the server is ready to run</span>
<span class="source-line-no">1113</span><span id="line-1113">          if (this.rspmHost != null) {</span>
<span class="source-line-no">1114</span><span id="line-1114">            this.rspmHost.start();</span>
<span class="source-line-no">1115</span><span id="line-1115">          }</span>
<span class="source-line-no">1116</span><span id="line-1116">          // Start the Quota Manager</span>
<span class="source-line-no">1117</span><span id="line-1117">          if (this.rsQuotaManager != null) {</span>
<span class="source-line-no">1118</span><span id="line-1118">            rsQuotaManager.start(getRpcServer().getScheduler());</span>
<span class="source-line-no">1119</span><span id="line-1119">          }</span>
<span class="source-line-no">1120</span><span id="line-1120">          if (this.rsSpaceQuotaManager != null) {</span>
<span class="source-line-no">1121</span><span id="line-1121">            this.rsSpaceQuotaManager.start();</span>
<span class="source-line-no">1122</span><span id="line-1122">          }</span>
<span class="source-line-no">1123</span><span id="line-1123">        }, "HRegionServer.startup");</span>
<span class="source-line-no">1124</span><span id="line-1124">      }</span>
<span class="source-line-no">1125</span><span id="line-1125"></span>
<span class="source-line-no">1126</span><span id="line-1126">      // We registered with the Master. Go into run mode.</span>
<span class="source-line-no">1127</span><span id="line-1127">      long lastMsg = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">1128</span><span id="line-1128">      long oldRequestCount = -1;</span>
<span class="source-line-no">1129</span><span id="line-1129">      // The main run loop.</span>
<span class="source-line-no">1130</span><span id="line-1130">      while (!isStopped() &amp;&amp; isHealthy()) {</span>
<span class="source-line-no">1131</span><span id="line-1131">        if (!isClusterUp()) {</span>
<span class="source-line-no">1132</span><span id="line-1132">          if (onlineRegions.isEmpty()) {</span>
<span class="source-line-no">1133</span><span id="line-1133">            stop("Exiting; cluster shutdown set and not carrying any regions");</span>
<span class="source-line-no">1134</span><span id="line-1134">          } else if (!this.stopping) {</span>
<span class="source-line-no">1135</span><span id="line-1135">            this.stopping = true;</span>
<span class="source-line-no">1136</span><span id="line-1136">            LOG.info("Closing user regions");</span>
<span class="source-line-no">1137</span><span id="line-1137">            closeUserRegions(this.abortRequested.get());</span>
<span class="source-line-no">1138</span><span id="line-1138">          } else {</span>
<span class="source-line-no">1139</span><span id="line-1139">            boolean allUserRegionsOffline = areAllUserRegionsOffline();</span>
<span class="source-line-no">1140</span><span id="line-1140">            if (allUserRegionsOffline) {</span>
<span class="source-line-no">1141</span><span id="line-1141">              // Set stopped if no more write requests tp meta tables</span>
<span class="source-line-no">1142</span><span id="line-1142">              // since last time we went around the loop. Any open</span>
<span class="source-line-no">1143</span><span id="line-1143">              // meta regions will be closed on our way out.</span>
<span class="source-line-no">1144</span><span id="line-1144">              if (oldRequestCount == getWriteRequestCount()) {</span>
<span class="source-line-no">1145</span><span id="line-1145">                stop("Stopped; only catalog regions remaining online");</span>
<span class="source-line-no">1146</span><span id="line-1146">                break;</span>
<span class="source-line-no">1147</span><span id="line-1147">              }</span>
<span class="source-line-no">1148</span><span id="line-1148">              oldRequestCount = getWriteRequestCount();</span>
<span class="source-line-no">1149</span><span id="line-1149">            } else {</span>
<span class="source-line-no">1150</span><span id="line-1150">              // Make sure all regions have been closed -- some regions may</span>
<span class="source-line-no">1151</span><span id="line-1151">              // have not got it because we were splitting at the time of</span>
<span class="source-line-no">1152</span><span id="line-1152">              // the call to closeUserRegions.</span>
<span class="source-line-no">1153</span><span id="line-1153">              closeUserRegions(this.abortRequested.get());</span>
<span class="source-line-no">1154</span><span id="line-1154">            }</span>
<span class="source-line-no">1155</span><span id="line-1155">            LOG.debug("Waiting on " + getOnlineRegionsAsPrintableString());</span>
<span class="source-line-no">1156</span><span id="line-1156">          }</span>
<span class="source-line-no">1157</span><span id="line-1157">        }</span>
<span class="source-line-no">1158</span><span id="line-1158">        long now = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">1159</span><span id="line-1159">        if ((now - lastMsg) &gt;= msgInterval) {</span>
<span class="source-line-no">1160</span><span id="line-1160">          tryRegionServerReport(lastMsg, now);</span>
<span class="source-line-no">1161</span><span id="line-1161">          lastMsg = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">1162</span><span id="line-1162">        }</span>
<span class="source-line-no">1163</span><span id="line-1163">        if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">1164</span><span id="line-1164">          this.sleeper.sleep();</span>
<span class="source-line-no">1165</span><span id="line-1165">        }</span>
<span class="source-line-no">1166</span><span id="line-1166">      } // for</span>
<span class="source-line-no">1167</span><span id="line-1167">    } catch (Throwable t) {</span>
<span class="source-line-no">1168</span><span id="line-1168">      if (!rpcServices.checkOOME(t)) {</span>
<span class="source-line-no">1169</span><span id="line-1169">        String prefix = t instanceof YouAreDeadException ? "" : "Unhandled: ";</span>
<span class="source-line-no">1170</span><span id="line-1170">        abort(prefix + t.getMessage(), t);</span>
<span class="source-line-no">1171</span><span id="line-1171">      }</span>
<span class="source-line-no">1172</span><span id="line-1172">    }</span>
<span class="source-line-no">1173</span><span id="line-1173"></span>
<span class="source-line-no">1174</span><span id="line-1174">    final Span span = TraceUtil.createSpan("HRegionServer exiting main loop");</span>
<span class="source-line-no">1175</span><span id="line-1175">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">1176</span><span id="line-1176">      if (this.leaseManager != null) {</span>
<span class="source-line-no">1177</span><span id="line-1177">        this.leaseManager.closeAfterLeasesExpire();</span>
<span class="source-line-no">1178</span><span id="line-1178">      }</span>
<span class="source-line-no">1179</span><span id="line-1179">      if (this.splitLogWorker != null) {</span>
<span class="source-line-no">1180</span><span id="line-1180">        splitLogWorker.stop();</span>
<span class="source-line-no">1181</span><span id="line-1181">      }</span>
<span class="source-line-no">1182</span><span id="line-1182">      if (this.infoServer != null) {</span>
<span class="source-line-no">1183</span><span id="line-1183">        LOG.info("Stopping infoServer");</span>
<span class="source-line-no">1184</span><span id="line-1184">        try {</span>
<span class="source-line-no">1185</span><span id="line-1185">          this.infoServer.stop();</span>
<span class="source-line-no">1186</span><span id="line-1186">        } catch (Exception e) {</span>
<span class="source-line-no">1187</span><span id="line-1187">          LOG.error("Failed to stop infoServer", e);</span>
<span class="source-line-no">1188</span><span id="line-1188">        }</span>
<span class="source-line-no">1189</span><span id="line-1189">      }</span>
<span class="source-line-no">1190</span><span id="line-1190">      // Send cache a shutdown.</span>
<span class="source-line-no">1191</span><span id="line-1191">      if (blockCache != null) {</span>
<span class="source-line-no">1192</span><span id="line-1192">        blockCache.shutdown();</span>
<span class="source-line-no">1193</span><span id="line-1193">      }</span>
<span class="source-line-no">1194</span><span id="line-1194">      if (mobFileCache != null) {</span>
<span class="source-line-no">1195</span><span id="line-1195">        mobFileCache.shutdown();</span>
<span class="source-line-no">1196</span><span id="line-1196">      }</span>
<span class="source-line-no">1197</span><span id="line-1197"></span>
<span class="source-line-no">1198</span><span id="line-1198">      // Send interrupts to wake up threads if sleeping so they notice shutdown.</span>
<span class="source-line-no">1199</span><span id="line-1199">      // TODO: Should we check they are alive? If OOME could have exited already</span>
<span class="source-line-no">1200</span><span id="line-1200">      if (this.hMemManager != null) {</span>
<span class="source-line-no">1201</span><span id="line-1201">        this.hMemManager.stop();</span>
<span class="source-line-no">1202</span><span id="line-1202">      }</span>
<span class="source-line-no">1203</span><span id="line-1203">      if (this.cacheFlusher != null) {</span>
<span class="source-line-no">1204</span><span id="line-1204">        this.cacheFlusher.interruptIfNecessary();</span>
<span class="source-line-no">1205</span><span id="line-1205">      }</span>
<span class="source-line-no">1206</span><span id="line-1206">      if (this.compactSplitThread != null) {</span>
<span class="source-line-no">1207</span><span id="line-1207">        this.compactSplitThread.interruptIfNecessary();</span>
<span class="source-line-no">1208</span><span id="line-1208">      }</span>
<span class="source-line-no">1209</span><span id="line-1209"></span>
<span class="source-line-no">1210</span><span id="line-1210">      // Stop the snapshot and other procedure handlers, forcefully killing all running tasks</span>
<span class="source-line-no">1211</span><span id="line-1211">      if (rspmHost != null) {</span>
<span class="source-line-no">1212</span><span id="line-1212">        rspmHost.stop(this.abortRequested.get() || this.killed);</span>
<span class="source-line-no">1213</span><span id="line-1213">      }</span>
<span class="source-line-no">1214</span><span id="line-1214"></span>
<span class="source-line-no">1215</span><span id="line-1215">      if (this.killed) {</span>
<span class="source-line-no">1216</span><span id="line-1216">        // Just skip out w/o closing regions. Used when testing.</span>
<span class="source-line-no">1217</span><span id="line-1217">      } else if (abortRequested.get()) {</span>
<span class="source-line-no">1218</span><span id="line-1218">        if (this.dataFsOk) {</span>
<span class="source-line-no">1219</span><span id="line-1219">          closeUserRegions(abortRequested.get()); // Don't leave any open file handles</span>
<span class="source-line-no">1220</span><span id="line-1220">        }</span>
<span class="source-line-no">1221</span><span id="line-1221">        LOG.info("aborting server " + this.serverName);</span>
<span class="source-line-no">1222</span><span id="line-1222">      } else {</span>
<span class="source-line-no">1223</span><span id="line-1223">        closeUserRegions(abortRequested.get());</span>
<span class="source-line-no">1224</span><span id="line-1224">        LOG.info("stopping server " + this.serverName);</span>
<span class="source-line-no">1225</span><span id="line-1225">      }</span>
<span class="source-line-no">1226</span><span id="line-1226"></span>
<span class="source-line-no">1227</span><span id="line-1227">      if (this.clusterConnection != null &amp;&amp; !clusterConnection.isClosed()) {</span>
<span class="source-line-no">1228</span><span id="line-1228">        try {</span>
<span class="source-line-no">1229</span><span id="line-1229">          this.clusterConnection.close();</span>
<span class="source-line-no">1230</span><span id="line-1230">        } catch (IOException e) {</span>
<span class="source-line-no">1231</span><span id="line-1231">          // Although the {@link Closeable} interface throws an {@link</span>
<span class="source-line-no">1232</span><span id="line-1232">          // IOException}, in reality, the implementation would never do that.</span>
<span class="source-line-no">1233</span><span id="line-1233">          LOG.warn("Attempt to close server's short circuit ClusterConnection failed.", e);</span>
<span class="source-line-no">1234</span><span id="line-1234">        }</span>
<span class="source-line-no">1235</span><span id="line-1235">      }</span>
<span class="source-line-no">1236</span><span id="line-1236"></span>
<span class="source-line-no">1237</span><span id="line-1237">      // Closing the compactSplit thread before closing meta regions</span>
<span class="source-line-no">1238</span><span id="line-1238">      if (!this.killed &amp;&amp; containsMetaTableRegions()) {</span>
<span class="source-line-no">1239</span><span id="line-1239">        if (!abortRequested.get() || this.dataFsOk) {</span>
<span class="source-line-no">1240</span><span id="line-1240">          if (this.compactSplitThread != null) {</span>
<span class="source-line-no">1241</span><span id="line-1241">            this.compactSplitThread.join();</span>
<span class="source-line-no">1242</span><span id="line-1242">            this.compactSplitThread = null;</span>
<span class="source-line-no">1243</span><span id="line-1243">          }</span>
<span class="source-line-no">1244</span><span id="line-1244">          closeMetaTableRegions(abortRequested.get());</span>
<span class="source-line-no">1245</span><span id="line-1245">        }</span>
<span class="source-line-no">1246</span><span id="line-1246">      }</span>
<span class="source-line-no">1247</span><span id="line-1247"></span>
<span class="source-line-no">1248</span><span id="line-1248">      if (!this.killed &amp;&amp; this.dataFsOk) {</span>
<span class="source-line-no">1249</span><span id="line-1249">        waitOnAllRegionsToClose(abortRequested.get());</span>
<span class="source-line-no">1250</span><span id="line-1250">        LOG.info("stopping server " + this.serverName + "; all regions closed.");</span>
<span class="source-line-no">1251</span><span id="line-1251">      }</span>
<span class="source-line-no">1252</span><span id="line-1252"></span>
<span class="source-line-no">1253</span><span id="line-1253">      // Stop the quota manager</span>
<span class="source-line-no">1254</span><span id="line-1254">      if (rsQuotaManager != null) {</span>
<span class="source-line-no">1255</span><span id="line-1255">        rsQuotaManager.stop();</span>
<span class="source-line-no">1256</span><span id="line-1256">      }</span>
<span class="source-line-no">1257</span><span id="line-1257">      if (rsSpaceQuotaManager != null) {</span>
<span class="source-line-no">1258</span><span id="line-1258">        rsSpaceQuotaManager.stop();</span>
<span class="source-line-no">1259</span><span id="line-1259">        rsSpaceQuotaManager = null;</span>
<span class="source-line-no">1260</span><span id="line-1260">      }</span>
<span class="source-line-no">1261</span><span id="line-1261"></span>
<span class="source-line-no">1262</span><span id="line-1262">      // flag may be changed when closing regions throws exception.</span>
<span class="source-line-no">1263</span><span id="line-1263">      if (this.dataFsOk) {</span>
<span class="source-line-no">1264</span><span id="line-1264">        shutdownWAL(!abortRequested.get());</span>
<span class="source-line-no">1265</span><span id="line-1265">      }</span>
<span class="source-line-no">1266</span><span id="line-1266"></span>
<span class="source-line-no">1267</span><span id="line-1267">      // Make sure the proxy is down.</span>
<span class="source-line-no">1268</span><span id="line-1268">      if (this.rssStub != null) {</span>
<span class="source-line-no">1269</span><span id="line-1269">        this.rssStub = null;</span>
<span class="source-line-no">1270</span><span id="line-1270">      }</span>
<span class="source-line-no">1271</span><span id="line-1271">      if (this.lockStub != null) {</span>
<span class="source-line-no">1272</span><span id="line-1272">        this.lockStub = null;</span>
<span class="source-line-no">1273</span><span id="line-1273">      }</span>
<span class="source-line-no">1274</span><span id="line-1274">      if (this.rpcClient != null) {</span>
<span class="source-line-no">1275</span><span id="line-1275">        this.rpcClient.close();</span>
<span class="source-line-no">1276</span><span id="line-1276">      }</span>
<span class="source-line-no">1277</span><span id="line-1277">      if (this.leaseManager != null) {</span>
<span class="source-line-no">1278</span><span id="line-1278">        this.leaseManager.close();</span>
<span class="source-line-no">1279</span><span id="line-1279">      }</span>
<span class="source-line-no">1280</span><span id="line-1280">      if (this.pauseMonitor != null) {</span>
<span class="source-line-no">1281</span><span id="line-1281">        this.pauseMonitor.stop();</span>
<span class="source-line-no">1282</span><span id="line-1282">      }</span>
<span class="source-line-no">1283</span><span id="line-1283"></span>
<span class="source-line-no">1284</span><span id="line-1284">      if (!killed) {</span>
<span class="source-line-no">1285</span><span id="line-1285">        stopServiceThreads();</span>
<span class="source-line-no">1286</span><span id="line-1286">      }</span>
<span class="source-line-no">1287</span><span id="line-1287"></span>
<span class="source-line-no">1288</span><span id="line-1288">      if (this.rpcServices != null) {</span>
<span class="source-line-no">1289</span><span id="line-1289">        this.rpcServices.stop();</span>
<span class="source-line-no">1290</span><span id="line-1290">      }</span>
<span class="source-line-no">1291</span><span id="line-1291"></span>
<span class="source-line-no">1292</span><span id="line-1292">      try {</span>
<span class="source-line-no">1293</span><span id="line-1293">        deleteMyEphemeralNode();</span>
<span class="source-line-no">1294</span><span id="line-1294">      } catch (KeeperException.NoNodeException nn) {</span>
<span class="source-line-no">1295</span><span id="line-1295">        // pass</span>
<span class="source-line-no">1296</span><span id="line-1296">      } catch (KeeperException e) {</span>
<span class="source-line-no">1297</span><span id="line-1297">        LOG.warn("Failed deleting my ephemeral node", e);</span>
<span class="source-line-no">1298</span><span id="line-1298">      }</span>
<span class="source-line-no">1299</span><span id="line-1299">      // We may have failed to delete the znode at the previous step, but</span>
<span class="source-line-no">1300</span><span id="line-1300">      // we delete the file anyway: a second attempt to delete the znode is likely to fail again.</span>
<span class="source-line-no">1301</span><span id="line-1301">      ZNodeClearer.deleteMyEphemeralNodeOnDisk();</span>
<span class="source-line-no">1302</span><span id="line-1302"></span>
<span class="source-line-no">1303</span><span id="line-1303">      if (this.zooKeeper != null) {</span>
<span class="source-line-no">1304</span><span id="line-1304">        this.zooKeeper.close();</span>
<span class="source-line-no">1305</span><span id="line-1305">      }</span>
<span class="source-line-no">1306</span><span id="line-1306">      this.shutDown = true;</span>
<span class="source-line-no">1307</span><span id="line-1307">      LOG.info("Exiting; stopping=" + this.serverName + "; zookeeper connection closed.");</span>
<span class="source-line-no">1308</span><span id="line-1308">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">1309</span><span id="line-1309">    } finally {</span>
<span class="source-line-no">1310</span><span id="line-1310">      span.end();</span>
<span class="source-line-no">1311</span><span id="line-1311">    }</span>
<span class="source-line-no">1312</span><span id="line-1312">  }</span>
<span class="source-line-no">1313</span><span id="line-1313"></span>
<span class="source-line-no">1314</span><span id="line-1314">  /**</span>
<span class="source-line-no">1315</span><span id="line-1315">   * This method is called when HMaster and HRegionServer are started. Please see to HBASE-26977 for</span>
<span class="source-line-no">1316</span><span id="line-1316">   * details.</span>
<span class="source-line-no">1317</span><span id="line-1317">   */</span>
<span class="source-line-no">1318</span><span id="line-1318">  private void installShutdownHook() {</span>
<span class="source-line-no">1319</span><span id="line-1319">    ShutdownHook.install(conf, dataFs, this, Thread.currentThread());</span>
<span class="source-line-no">1320</span><span id="line-1320">    isShutdownHookInstalled = true;</span>
<span class="source-line-no">1321</span><span id="line-1321">  }</span>
<span class="source-line-no">1322</span><span id="line-1322"></span>
<span class="source-line-no">1323</span><span id="line-1323">  /**</span>
<span class="source-line-no">1324</span><span id="line-1324">   * This method is used for testing.</span>
<span class="source-line-no">1325</span><span id="line-1325">   */</span>
<span class="source-line-no">1326</span><span id="line-1326">  public boolean isShutdownHookInstalled() {</span>
<span class="source-line-no">1327</span><span id="line-1327">    return isShutdownHookInstalled;</span>
<span class="source-line-no">1328</span><span id="line-1328">  }</span>
<span class="source-line-no">1329</span><span id="line-1329"></span>
<span class="source-line-no">1330</span><span id="line-1330">  private boolean containsMetaTableRegions() {</span>
<span class="source-line-no">1331</span><span id="line-1331">    return onlineRegions.containsKey(RegionInfoBuilder.FIRST_META_REGIONINFO.getEncodedName());</span>
<span class="source-line-no">1332</span><span id="line-1332">  }</span>
<span class="source-line-no">1333</span><span id="line-1333"></span>
<span class="source-line-no">1334</span><span id="line-1334">  private boolean areAllUserRegionsOffline() {</span>
<span class="source-line-no">1335</span><span id="line-1335">    if (getNumberOfOnlineRegions() &gt; 2) {</span>
<span class="source-line-no">1336</span><span id="line-1336">      return false;</span>
<span class="source-line-no">1337</span><span id="line-1337">    }</span>
<span class="source-line-no">1338</span><span id="line-1338">    boolean allUserRegionsOffline = true;</span>
<span class="source-line-no">1339</span><span id="line-1339">    for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1340</span><span id="line-1340">      if (!e.getValue().getRegionInfo().isMetaRegion()) {</span>
<span class="source-line-no">1341</span><span id="line-1341">        allUserRegionsOffline = false;</span>
<span class="source-line-no">1342</span><span id="line-1342">        break;</span>
<span class="source-line-no">1343</span><span id="line-1343">      }</span>
<span class="source-line-no">1344</span><span id="line-1344">    }</span>
<span class="source-line-no">1345</span><span id="line-1345">    return allUserRegionsOffline;</span>
<span class="source-line-no">1346</span><span id="line-1346">  }</span>
<span class="source-line-no">1347</span><span id="line-1347"></span>
<span class="source-line-no">1348</span><span id="line-1348">  /** Returns Current write count for all online regions. */</span>
<span class="source-line-no">1349</span><span id="line-1349">  private long getWriteRequestCount() {</span>
<span class="source-line-no">1350</span><span id="line-1350">    long writeCount = 0;</span>
<span class="source-line-no">1351</span><span id="line-1351">    for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1352</span><span id="line-1352">      writeCount += e.getValue().getWriteRequestsCount();</span>
<span class="source-line-no">1353</span><span id="line-1353">    }</span>
<span class="source-line-no">1354</span><span id="line-1354">    return writeCount;</span>
<span class="source-line-no">1355</span><span id="line-1355">  }</span>
<span class="source-line-no">1356</span><span id="line-1356"></span>
<span class="source-line-no">1357</span><span id="line-1357">  @InterfaceAudience.Private</span>
<span class="source-line-no">1358</span><span id="line-1358">  protected void tryRegionServerReport(long reportStartTime, long reportEndTime)</span>
<span class="source-line-no">1359</span><span id="line-1359">    throws IOException {</span>
<span class="source-line-no">1360</span><span id="line-1360">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">1361</span><span id="line-1361">    if (rss == null) {</span>
<span class="source-line-no">1362</span><span id="line-1362">      // the current server could be stopping.</span>
<span class="source-line-no">1363</span><span id="line-1363">      return;</span>
<span class="source-line-no">1364</span><span id="line-1364">    }</span>
<span class="source-line-no">1365</span><span id="line-1365">    ClusterStatusProtos.ServerLoad sl = buildServerLoad(reportStartTime, reportEndTime);</span>
<span class="source-line-no">1366</span><span id="line-1366">    final Span span = TraceUtil.createSpan("HRegionServer.tryRegionServerReport");</span>
<span class="source-line-no">1367</span><span id="line-1367">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">1368</span><span id="line-1368">      RegionServerReportRequest.Builder request = RegionServerReportRequest.newBuilder();</span>
<span class="source-line-no">1369</span><span id="line-1369">      request.setServer(ProtobufUtil.toServerName(this.serverName));</span>
<span class="source-line-no">1370</span><span id="line-1370">      request.setLoad(sl);</span>
<span class="source-line-no">1371</span><span id="line-1371">      rss.regionServerReport(null, request.build());</span>
<span class="source-line-no">1372</span><span id="line-1372">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">1373</span><span id="line-1373">    } catch (ServiceException se) {</span>
<span class="source-line-no">1374</span><span id="line-1374">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">1375</span><span id="line-1375">      if (ioe instanceof YouAreDeadException) {</span>
<span class="source-line-no">1376</span><span id="line-1376">        // This will be caught and handled as a fatal error in run()</span>
<span class="source-line-no">1377</span><span id="line-1377">        TraceUtil.setError(span, ioe);</span>
<span class="source-line-no">1378</span><span id="line-1378">        throw ioe;</span>
<span class="source-line-no">1379</span><span id="line-1379">      }</span>
<span class="source-line-no">1380</span><span id="line-1380">      if (rssStub == rss) {</span>
<span class="source-line-no">1381</span><span id="line-1381">        rssStub = null;</span>
<span class="source-line-no">1382</span><span id="line-1382">      }</span>
<span class="source-line-no">1383</span><span id="line-1383">      TraceUtil.setError(span, se);</span>
<span class="source-line-no">1384</span><span id="line-1384">      // Couldn't connect to the master, get location from zk and reconnect</span>
<span class="source-line-no">1385</span><span id="line-1385">      // Method blocks until new master is found or we are stopped</span>
<span class="source-line-no">1386</span><span id="line-1386">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">1387</span><span id="line-1387">    } finally {</span>
<span class="source-line-no">1388</span><span id="line-1388">      span.end();</span>
<span class="source-line-no">1389</span><span id="line-1389">    }</span>
<span class="source-line-no">1390</span><span id="line-1390">  }</span>
<span class="source-line-no">1391</span><span id="line-1391"></span>
<span class="source-line-no">1392</span><span id="line-1392">  /**</span>
<span class="source-line-no">1393</span><span id="line-1393">   * Reports the given map of Regions and their size on the filesystem to the active Master.</span>
<span class="source-line-no">1394</span><span id="line-1394">   * @param regionSizeStore The store containing region sizes</span>
<span class="source-line-no">1395</span><span id="line-1395">   * @return false if FileSystemUtilizationChore should pause reporting to master. true otherwise</span>
<span class="source-line-no">1396</span><span id="line-1396">   */</span>
<span class="source-line-no">1397</span><span id="line-1397">  public boolean reportRegionSizesForQuotas(RegionSizeStore regionSizeStore) {</span>
<span class="source-line-no">1398</span><span id="line-1398">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">1399</span><span id="line-1399">    if (rss == null) {</span>
<span class="source-line-no">1400</span><span id="line-1400">      // the current server could be stopping.</span>
<span class="source-line-no">1401</span><span id="line-1401">      LOG.trace("Skipping Region size report to HMaster as stub is null");</span>
<span class="source-line-no">1402</span><span id="line-1402">      return true;</span>
<span class="source-line-no">1403</span><span id="line-1403">    }</span>
<span class="source-line-no">1404</span><span id="line-1404">    try {</span>
<span class="source-line-no">1405</span><span id="line-1405">      buildReportAndSend(rss, regionSizeStore);</span>
<span class="source-line-no">1406</span><span id="line-1406">    } catch (ServiceException se) {</span>
<span class="source-line-no">1407</span><span id="line-1407">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">1408</span><span id="line-1408">      if (ioe instanceof PleaseHoldException) {</span>
<span class="source-line-no">1409</span><span id="line-1409">        LOG.trace("Failed to report region sizes to Master because it is initializing."</span>
<span class="source-line-no">1410</span><span id="line-1410">          + " This will be retried.", ioe);</span>
<span class="source-line-no">1411</span><span id="line-1411">        // The Master is coming up. Will retry the report later. Avoid re-creating the stub.</span>
<span class="source-line-no">1412</span><span id="line-1412">        return true;</span>
<span class="source-line-no">1413</span><span id="line-1413">      }</span>
<span class="source-line-no">1414</span><span id="line-1414">      if (rssStub == rss) {</span>
<span class="source-line-no">1415</span><span id="line-1415">        rssStub = null;</span>
<span class="source-line-no">1416</span><span id="line-1416">      }</span>
<span class="source-line-no">1417</span><span id="line-1417">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">1418</span><span id="line-1418">      if (ioe instanceof DoNotRetryIOException) {</span>
<span class="source-line-no">1419</span><span id="line-1419">        DoNotRetryIOException doNotRetryEx = (DoNotRetryIOException) ioe;</span>
<span class="source-line-no">1420</span><span id="line-1420">        if (doNotRetryEx.getCause() != null) {</span>
<span class="source-line-no">1421</span><span id="line-1421">          Throwable t = doNotRetryEx.getCause();</span>
<span class="source-line-no">1422</span><span id="line-1422">          if (t instanceof UnsupportedOperationException) {</span>
<span class="source-line-no">1423</span><span id="line-1423">            LOG.debug("master doesn't support ReportRegionSpaceUse, pause before retrying");</span>
<span class="source-line-no">1424</span><span id="line-1424">            return false;</span>
<span class="source-line-no">1425</span><span id="line-1425">          }</span>
<span class="source-line-no">1426</span><span id="line-1426">        }</span>
<span class="source-line-no">1427</span><span id="line-1427">      }</span>
<span class="source-line-no">1428</span><span id="line-1428">      LOG.debug("Failed to report region sizes to Master. This will be retried.", ioe);</span>
<span class="source-line-no">1429</span><span id="line-1429">    }</span>
<span class="source-line-no">1430</span><span id="line-1430">    return true;</span>
<span class="source-line-no">1431</span><span id="line-1431">  }</span>
<span class="source-line-no">1432</span><span id="line-1432"></span>
<span class="source-line-no">1433</span><span id="line-1433">  /**</span>
<span class="source-line-no">1434</span><span id="line-1434">   * Builds the region size report and sends it to the master. Upon successful sending of the</span>
<span class="source-line-no">1435</span><span id="line-1435">   * report, the region sizes that were sent are marked as sent.</span>
<span class="source-line-no">1436</span><span id="line-1436">   * @param rss             The stub to send to the Master</span>
<span class="source-line-no">1437</span><span id="line-1437">   * @param regionSizeStore The store containing region sizes</span>
<span class="source-line-no">1438</span><span id="line-1438">   */</span>
<span class="source-line-no">1439</span><span id="line-1439">  private void buildReportAndSend(RegionServerStatusService.BlockingInterface rss,</span>
<span class="source-line-no">1440</span><span id="line-1440">    RegionSizeStore regionSizeStore) throws ServiceException {</span>
<span class="source-line-no">1441</span><span id="line-1441">    RegionSpaceUseReportRequest request =</span>
<span class="source-line-no">1442</span><span id="line-1442">      buildRegionSpaceUseReportRequest(Objects.requireNonNull(regionSizeStore));</span>
<span class="source-line-no">1443</span><span id="line-1443">    rss.reportRegionSpaceUse(null, request);</span>
<span class="source-line-no">1444</span><span id="line-1444">    // Record the number of size reports sent</span>
<span class="source-line-no">1445</span><span id="line-1445">    if (metricsRegionServer != null) {</span>
<span class="source-line-no">1446</span><span id="line-1446">      metricsRegionServer.incrementNumRegionSizeReportsSent(regionSizeStore.size());</span>
<span class="source-line-no">1447</span><span id="line-1447">    }</span>
<span class="source-line-no">1448</span><span id="line-1448">  }</span>
<span class="source-line-no">1449</span><span id="line-1449"></span>
<span class="source-line-no">1450</span><span id="line-1450">  /**</span>
<span class="source-line-no">1451</span><span id="line-1451">   * Builds a {@link RegionSpaceUseReportRequest} protobuf message from the region size map.</span>
<span class="source-line-no">1452</span><span id="line-1452">   * @param regionSizes The size in bytes of regions</span>
<span class="source-line-no">1453</span><span id="line-1453">   * @return The corresponding protocol buffer message.</span>
<span class="source-line-no">1454</span><span id="line-1454">   */</span>
<span class="source-line-no">1455</span><span id="line-1455">  RegionSpaceUseReportRequest buildRegionSpaceUseReportRequest(RegionSizeStore regionSizes) {</span>
<span class="source-line-no">1456</span><span id="line-1456">    RegionSpaceUseReportRequest.Builder request = RegionSpaceUseReportRequest.newBuilder();</span>
<span class="source-line-no">1457</span><span id="line-1457">    for (Entry&lt;RegionInfo, RegionSize&gt; entry : regionSizes) {</span>
<span class="source-line-no">1458</span><span id="line-1458">      request.addSpaceUse(convertRegionSize(entry.getKey(), entry.getValue().getSize()));</span>
<span class="source-line-no">1459</span><span id="line-1459">    }</span>
<span class="source-line-no">1460</span><span id="line-1460">    return request.build();</span>
<span class="source-line-no">1461</span><span id="line-1461">  }</span>
<span class="source-line-no">1462</span><span id="line-1462"></span>
<span class="source-line-no">1463</span><span id="line-1463">  /**</span>
<span class="source-line-no">1464</span><span id="line-1464">   * Converts a pair of {@link RegionInfo} and {@code long} into a {@link RegionSpaceUse} protobuf</span>
<span class="source-line-no">1465</span><span id="line-1465">   * message.</span>
<span class="source-line-no">1466</span><span id="line-1466">   * @param regionInfo  The RegionInfo</span>
<span class="source-line-no">1467</span><span id="line-1467">   * @param sizeInBytes The size in bytes of the Region</span>
<span class="source-line-no">1468</span><span id="line-1468">   * @return The protocol buffer</span>
<span class="source-line-no">1469</span><span id="line-1469">   */</span>
<span class="source-line-no">1470</span><span id="line-1470">  RegionSpaceUse convertRegionSize(RegionInfo regionInfo, Long sizeInBytes) {</span>
<span class="source-line-no">1471</span><span id="line-1471">    return RegionSpaceUse.newBuilder()</span>
<span class="source-line-no">1472</span><span id="line-1472">      .setRegionInfo(ProtobufUtil.toRegionInfo(Objects.requireNonNull(regionInfo)))</span>
<span class="source-line-no">1473</span><span id="line-1473">      .setRegionSize(Objects.requireNonNull(sizeInBytes)).build();</span>
<span class="source-line-no">1474</span><span id="line-1474">  }</span>
<span class="source-line-no">1475</span><span id="line-1475"></span>
<span class="source-line-no">1476</span><span id="line-1476">  private ClusterStatusProtos.ServerLoad buildServerLoad(long reportStartTime, long reportEndTime)</span>
<span class="source-line-no">1477</span><span id="line-1477">    throws IOException {</span>
<span class="source-line-no">1478</span><span id="line-1478">    // We're getting the MetricsRegionServerWrapper here because the wrapper computes requests</span>
<span class="source-line-no">1479</span><span id="line-1479">    // per second, and other metrics As long as metrics are part of ServerLoad it's best to use</span>
<span class="source-line-no">1480</span><span id="line-1480">    // the wrapper to compute those numbers in one place.</span>
<span class="source-line-no">1481</span><span id="line-1481">    // In the long term most of these should be moved off of ServerLoad and the heart beat.</span>
<span class="source-line-no">1482</span><span id="line-1482">    // Instead they should be stored in an HBase table so that external visibility into HBase is</span>
<span class="source-line-no">1483</span><span id="line-1483">    // improved; Additionally the load balancer will be able to take advantage of a more complete</span>
<span class="source-line-no">1484</span><span id="line-1484">    // history.</span>
<span class="source-line-no">1485</span><span id="line-1485">    MetricsRegionServerWrapper regionServerWrapper = metricsRegionServer.getRegionServerWrapper();</span>
<span class="source-line-no">1486</span><span id="line-1486">    Collection&lt;HRegion&gt; regions = getOnlineRegionsLocalContext();</span>
<span class="source-line-no">1487</span><span id="line-1487">    long usedMemory = -1L;</span>
<span class="source-line-no">1488</span><span id="line-1488">    long maxMemory = -1L;</span>
<span class="source-line-no">1489</span><span id="line-1489">    final MemoryUsage usage = MemorySizeUtil.safeGetHeapMemoryUsage();</span>
<span class="source-line-no">1490</span><span id="line-1490">    if (usage != null) {</span>
<span class="source-line-no">1491</span><span id="line-1491">      usedMemory = usage.getUsed();</span>
<span class="source-line-no">1492</span><span id="line-1492">      maxMemory = usage.getMax();</span>
<span class="source-line-no">1493</span><span id="line-1493">    }</span>
<span class="source-line-no">1494</span><span id="line-1494"></span>
<span class="source-line-no">1495</span><span id="line-1495">    ClusterStatusProtos.ServerLoad.Builder serverLoad = ClusterStatusProtos.ServerLoad.newBuilder();</span>
<span class="source-line-no">1496</span><span id="line-1496">    serverLoad.setNumberOfRequests((int) regionServerWrapper.getRequestsPerSecond());</span>
<span class="source-line-no">1497</span><span id="line-1497">    serverLoad.setTotalNumberOfRequests(regionServerWrapper.getTotalRequestCount());</span>
<span class="source-line-no">1498</span><span id="line-1498">    serverLoad.setUsedHeapMB((int) (usedMemory / 1024 / 1024));</span>
<span class="source-line-no">1499</span><span id="line-1499">    serverLoad.setMaxHeapMB((int) (maxMemory / 1024 / 1024));</span>
<span class="source-line-no">1500</span><span id="line-1500">    Set&lt;String&gt; coprocessors = getWAL(null).getCoprocessorHost().getCoprocessors();</span>
<span class="source-line-no">1501</span><span id="line-1501">    Coprocessor.Builder coprocessorBuilder = Coprocessor.newBuilder();</span>
<span class="source-line-no">1502</span><span id="line-1502">    for (String coprocessor : coprocessors) {</span>
<span class="source-line-no">1503</span><span id="line-1503">      serverLoad.addCoprocessors(coprocessorBuilder.setName(coprocessor).build());</span>
<span class="source-line-no">1504</span><span id="line-1504">    }</span>
<span class="source-line-no">1505</span><span id="line-1505">    RegionLoad.Builder regionLoadBldr = RegionLoad.newBuilder();</span>
<span class="source-line-no">1506</span><span id="line-1506">    RegionSpecifier.Builder regionSpecifier = RegionSpecifier.newBuilder();</span>
<span class="source-line-no">1507</span><span id="line-1507">    for (HRegion region : regions) {</span>
<span class="source-line-no">1508</span><span id="line-1508">      if (region.getCoprocessorHost() != null) {</span>
<span class="source-line-no">1509</span><span id="line-1509">        Set&lt;String&gt; regionCoprocessors = region.getCoprocessorHost().getCoprocessors();</span>
<span class="source-line-no">1510</span><span id="line-1510">        for (String regionCoprocessor : regionCoprocessors) {</span>
<span class="source-line-no">1511</span><span id="line-1511">          serverLoad.addCoprocessors(coprocessorBuilder.setName(regionCoprocessor).build());</span>
<span class="source-line-no">1512</span><span id="line-1512">        }</span>
<span class="source-line-no">1513</span><span id="line-1513">      }</span>
<span class="source-line-no">1514</span><span id="line-1514">      serverLoad.addRegionLoads(createRegionLoad(region, regionLoadBldr, regionSpecifier));</span>
<span class="source-line-no">1515</span><span id="line-1515">      for (String coprocessor : getWAL(region.getRegionInfo()).getCoprocessorHost()</span>
<span class="source-line-no">1516</span><span id="line-1516">        .getCoprocessors()) {</span>
<span class="source-line-no">1517</span><span id="line-1517">        serverLoad.addCoprocessors(coprocessorBuilder.setName(coprocessor).build());</span>
<span class="source-line-no">1518</span><span id="line-1518">      }</span>
<span class="source-line-no">1519</span><span id="line-1519">    }</span>
<span class="source-line-no">1520</span><span id="line-1520">    computeIfPersistentBucketCache(bc -&gt; {</span>
<span class="source-line-no">1521</span><span id="line-1521">      bc.getRegionCachedInfo().forEach((regionName, prefetchSize) -&gt; {</span>
<span class="source-line-no">1522</span><span id="line-1522">        serverLoad.putRegionCachedInfo(regionName, roundSize(prefetchSize, unitMB));</span>
<span class="source-line-no">1523</span><span id="line-1523">      });</span>
<span class="source-line-no">1524</span><span id="line-1524">    });</span>
<span class="source-line-no">1525</span><span id="line-1525">    serverLoad.setReportStartTime(reportStartTime);</span>
<span class="source-line-no">1526</span><span id="line-1526">    serverLoad.setReportEndTime(reportEndTime);</span>
<span class="source-line-no">1527</span><span id="line-1527">    if (this.infoServer != null) {</span>
<span class="source-line-no">1528</span><span id="line-1528">      serverLoad.setInfoServerPort(this.infoServer.getPort());</span>
<span class="source-line-no">1529</span><span id="line-1529">    } else {</span>
<span class="source-line-no">1530</span><span id="line-1530">      serverLoad.setInfoServerPort(-1);</span>
<span class="source-line-no">1531</span><span id="line-1531">    }</span>
<span class="source-line-no">1532</span><span id="line-1532">    MetricsUserAggregateSource userSource =</span>
<span class="source-line-no">1533</span><span id="line-1533">      metricsRegionServer.getMetricsUserAggregate().getSource();</span>
<span class="source-line-no">1534</span><span id="line-1534">    if (userSource != null) {</span>
<span class="source-line-no">1535</span><span id="line-1535">      Map&lt;String, MetricsUserSource&gt; userMetricMap = userSource.getUserSources();</span>
<span class="source-line-no">1536</span><span id="line-1536">      for (Entry&lt;String, MetricsUserSource&gt; entry : userMetricMap.entrySet()) {</span>
<span class="source-line-no">1537</span><span id="line-1537">        serverLoad.addUserLoads(createUserLoad(entry.getKey(), entry.getValue()));</span>
<span class="source-line-no">1538</span><span id="line-1538">      }</span>
<span class="source-line-no">1539</span><span id="line-1539">    }</span>
<span class="source-line-no">1540</span><span id="line-1540"></span>
<span class="source-line-no">1541</span><span id="line-1541">    // for the replicationLoad purpose. Only need to get from one executorService</span>
<span class="source-line-no">1542</span><span id="line-1542">    // either source or sink will get the same info</span>
<span class="source-line-no">1543</span><span id="line-1543">    ReplicationSourceService rsources = getReplicationSourceService();</span>
<span class="source-line-no">1544</span><span id="line-1544">    if (rsources != null) {</span>
<span class="source-line-no">1545</span><span id="line-1545">      // always refresh first to get the latest value</span>
<span class="source-line-no">1546</span><span id="line-1546">      ReplicationLoad rLoad = rsources.refreshAndGetReplicationLoad();</span>
<span class="source-line-no">1547</span><span id="line-1547">      if (rLoad != null) {</span>
<span class="source-line-no">1548</span><span id="line-1548">        serverLoad.setReplLoadSink(rLoad.getReplicationLoadSink());</span>
<span class="source-line-no">1549</span><span id="line-1549">        for (ClusterStatusProtos.ReplicationLoadSource rLS : rLoad</span>
<span class="source-line-no">1550</span><span id="line-1550">          .getReplicationLoadSourceEntries()) {</span>
<span class="source-line-no">1551</span><span id="line-1551">          serverLoad.addReplLoadSource(rLS);</span>
<span class="source-line-no">1552</span><span id="line-1552">        }</span>
<span class="source-line-no">1553</span><span id="line-1553"></span>
<span class="source-line-no">1554</span><span id="line-1554">      }</span>
<span class="source-line-no">1555</span><span id="line-1555">    }</span>
<span class="source-line-no">1556</span><span id="line-1556"></span>
<span class="source-line-no">1557</span><span id="line-1557">    TaskMonitor.get().getTasks().forEach(task -&gt; serverLoad.addTasks(ClusterStatusProtos.ServerTask</span>
<span class="source-line-no">1558</span><span id="line-1558">      .newBuilder().setDescription(task.getDescription())</span>
<span class="source-line-no">1559</span><span id="line-1559">      .setStatus(task.getStatus() != null ? task.getStatus() : "")</span>
<span class="source-line-no">1560</span><span id="line-1560">      .setState(ClusterStatusProtos.ServerTask.State.valueOf(task.getState().name()))</span>
<span class="source-line-no">1561</span><span id="line-1561">      .setStartTime(task.getStartTime()).setCompletionTime(task.getCompletionTimestamp()).build()));</span>
<span class="source-line-no">1562</span><span id="line-1562"></span>
<span class="source-line-no">1563</span><span id="line-1563">    return serverLoad.build();</span>
<span class="source-line-no">1564</span><span id="line-1564">  }</span>
<span class="source-line-no">1565</span><span id="line-1565"></span>
<span class="source-line-no">1566</span><span id="line-1566">  private String getOnlineRegionsAsPrintableString() {</span>
<span class="source-line-no">1567</span><span id="line-1567">    StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">1568</span><span id="line-1568">    for (Region r : this.onlineRegions.values()) {</span>
<span class="source-line-no">1569</span><span id="line-1569">      if (sb.length() &gt; 0) {</span>
<span class="source-line-no">1570</span><span id="line-1570">        sb.append(", ");</span>
<span class="source-line-no">1571</span><span id="line-1571">      }</span>
<span class="source-line-no">1572</span><span id="line-1572">      sb.append(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">1573</span><span id="line-1573">    }</span>
<span class="source-line-no">1574</span><span id="line-1574">    return sb.toString();</span>
<span class="source-line-no">1575</span><span id="line-1575">  }</span>
<span class="source-line-no">1576</span><span id="line-1576"></span>
<span class="source-line-no">1577</span><span id="line-1577">  /**</span>
<span class="source-line-no">1578</span><span id="line-1578">   * Wait on regions close.</span>
<span class="source-line-no">1579</span><span id="line-1579">   */</span>
<span class="source-line-no">1580</span><span id="line-1580">  private void waitOnAllRegionsToClose(final boolean abort) {</span>
<span class="source-line-no">1581</span><span id="line-1581">    // Wait till all regions are closed before going out.</span>
<span class="source-line-no">1582</span><span id="line-1582">    int lastCount = -1;</span>
<span class="source-line-no">1583</span><span id="line-1583">    long previousLogTime = 0;</span>
<span class="source-line-no">1584</span><span id="line-1584">    Set&lt;String&gt; closedRegions = new HashSet&lt;&gt;();</span>
<span class="source-line-no">1585</span><span id="line-1585">    boolean interrupted = false;</span>
<span class="source-line-no">1586</span><span id="line-1586">    try {</span>
<span class="source-line-no">1587</span><span id="line-1587">      while (!onlineRegions.isEmpty()) {</span>
<span class="source-line-no">1588</span><span id="line-1588">        int count = getNumberOfOnlineRegions();</span>
<span class="source-line-no">1589</span><span id="line-1589">        // Only print a message if the count of regions has changed.</span>
<span class="source-line-no">1590</span><span id="line-1590">        if (count != lastCount) {</span>
<span class="source-line-no">1591</span><span id="line-1591">          // Log every second at most</span>
<span class="source-line-no">1592</span><span id="line-1592">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">1593</span><span id="line-1593">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">1594</span><span id="line-1594">            lastCount = count;</span>
<span class="source-line-no">1595</span><span id="line-1595">            LOG.info("Waiting on " + count + " regions to close");</span>
<span class="source-line-no">1596</span><span id="line-1596">            // Only print out regions still closing if a small number else will</span>
<span class="source-line-no">1597</span><span id="line-1597">            // swamp the log.</span>
<span class="source-line-no">1598</span><span id="line-1598">            if (count &lt; 10 &amp;&amp; LOG.isDebugEnabled()) {</span>
<span class="source-line-no">1599</span><span id="line-1599">              LOG.debug("Online Regions=" + this.onlineRegions);</span>
<span class="source-line-no">1600</span><span id="line-1600">            }</span>
<span class="source-line-no">1601</span><span id="line-1601">          }</span>
<span class="source-line-no">1602</span><span id="line-1602">        }</span>
<span class="source-line-no">1603</span><span id="line-1603">        // Ensure all user regions have been sent a close. Use this to</span>
<span class="source-line-no">1604</span><span id="line-1604">        // protect against the case where an open comes in after we start the</span>
<span class="source-line-no">1605</span><span id="line-1605">        // iterator of onlineRegions to close all user regions.</span>
<span class="source-line-no">1606</span><span id="line-1606">        for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1607</span><span id="line-1607">          RegionInfo hri = e.getValue().getRegionInfo();</span>
<span class="source-line-no">1608</span><span id="line-1608">          if (</span>
<span class="source-line-no">1609</span><span id="line-1609">            !this.regionsInTransitionInRS.containsKey(hri.getEncodedNameAsBytes())</span>
<span class="source-line-no">1610</span><span id="line-1610">              &amp;&amp; !closedRegions.contains(hri.getEncodedName())</span>
<span class="source-line-no">1611</span><span id="line-1611">          ) {</span>
<span class="source-line-no">1612</span><span id="line-1612">            closedRegions.add(hri.getEncodedName());</span>
<span class="source-line-no">1613</span><span id="line-1613">            // Don't update zk with this close transition; pass false.</span>
<span class="source-line-no">1614</span><span id="line-1614">            closeRegionIgnoreErrors(hri, abort);</span>
<span class="source-line-no">1615</span><span id="line-1615">          }</span>
<span class="source-line-no">1616</span><span id="line-1616">        }</span>
<span class="source-line-no">1617</span><span id="line-1617">        // No regions in RIT, we could stop waiting now.</span>
<span class="source-line-no">1618</span><span id="line-1618">        if (this.regionsInTransitionInRS.isEmpty()) {</span>
<span class="source-line-no">1619</span><span id="line-1619">          if (!onlineRegions.isEmpty()) {</span>
<span class="source-line-no">1620</span><span id="line-1620">            LOG.info("We were exiting though online regions are not empty,"</span>
<span class="source-line-no">1621</span><span id="line-1621">              + " because some regions failed closing");</span>
<span class="source-line-no">1622</span><span id="line-1622">          }</span>
<span class="source-line-no">1623</span><span id="line-1623">          break;</span>
<span class="source-line-no">1624</span><span id="line-1624">        } else {</span>
<span class="source-line-no">1625</span><span id="line-1625">          LOG.debug("Waiting on {}", this.regionsInTransitionInRS.keySet().stream()</span>
<span class="source-line-no">1626</span><span id="line-1626">            .map(e -&gt; Bytes.toString(e)).collect(Collectors.joining(", ")));</span>
<span class="source-line-no">1627</span><span id="line-1627">        }</span>
<span class="source-line-no">1628</span><span id="line-1628">        if (sleepInterrupted(200)) {</span>
<span class="source-line-no">1629</span><span id="line-1629">          interrupted = true;</span>
<span class="source-line-no">1630</span><span id="line-1630">        }</span>
<span class="source-line-no">1631</span><span id="line-1631">      }</span>
<span class="source-line-no">1632</span><span id="line-1632">    } finally {</span>
<span class="source-line-no">1633</span><span id="line-1633">      if (interrupted) {</span>
<span class="source-line-no">1634</span><span id="line-1634">        Thread.currentThread().interrupt();</span>
<span class="source-line-no">1635</span><span id="line-1635">      }</span>
<span class="source-line-no">1636</span><span id="line-1636">    }</span>
<span class="source-line-no">1637</span><span id="line-1637">  }</span>
<span class="source-line-no">1638</span><span id="line-1638"></span>
<span class="source-line-no">1639</span><span id="line-1639">  private static boolean sleepInterrupted(long millis) {</span>
<span class="source-line-no">1640</span><span id="line-1640">    boolean interrupted = false;</span>
<span class="source-line-no">1641</span><span id="line-1641">    try {</span>
<span class="source-line-no">1642</span><span id="line-1642">      Thread.sleep(millis);</span>
<span class="source-line-no">1643</span><span id="line-1643">    } catch (InterruptedException e) {</span>
<span class="source-line-no">1644</span><span id="line-1644">      LOG.warn("Interrupted while sleeping");</span>
<span class="source-line-no">1645</span><span id="line-1645">      interrupted = true;</span>
<span class="source-line-no">1646</span><span id="line-1646">    }</span>
<span class="source-line-no">1647</span><span id="line-1647">    return interrupted;</span>
<span class="source-line-no">1648</span><span id="line-1648">  }</span>
<span class="source-line-no">1649</span><span id="line-1649"></span>
<span class="source-line-no">1650</span><span id="line-1650">  private void shutdownWAL(final boolean close) {</span>
<span class="source-line-no">1651</span><span id="line-1651">    if (this.walFactory != null) {</span>
<span class="source-line-no">1652</span><span id="line-1652">      try {</span>
<span class="source-line-no">1653</span><span id="line-1653">        if (close) {</span>
<span class="source-line-no">1654</span><span id="line-1654">          walFactory.close();</span>
<span class="source-line-no">1655</span><span id="line-1655">        } else {</span>
<span class="source-line-no">1656</span><span id="line-1656">          walFactory.shutdown();</span>
<span class="source-line-no">1657</span><span id="line-1657">        }</span>
<span class="source-line-no">1658</span><span id="line-1658">      } catch (Throwable e) {</span>
<span class="source-line-no">1659</span><span id="line-1659">        e = e instanceof RemoteException ? ((RemoteException) e).unwrapRemoteException() : e;</span>
<span class="source-line-no">1660</span><span id="line-1660">        LOG.error("Shutdown / close of WAL failed: " + e);</span>
<span class="source-line-no">1661</span><span id="line-1661">        LOG.debug("Shutdown / close exception details:", e);</span>
<span class="source-line-no">1662</span><span id="line-1662">      }</span>
<span class="source-line-no">1663</span><span id="line-1663">    }</span>
<span class="source-line-no">1664</span><span id="line-1664">  }</span>
<span class="source-line-no">1665</span><span id="line-1665"></span>
<span class="source-line-no">1666</span><span id="line-1666">  /**</span>
<span class="source-line-no">1667</span><span id="line-1667">   * get NamedQueue Provider to add different logs to ringbuffer</span>
<span class="source-line-no">1668</span><span id="line-1668">   */</span>
<span class="source-line-no">1669</span><span id="line-1669">  public NamedQueueRecorder getNamedQueueRecorder() {</span>
<span class="source-line-no">1670</span><span id="line-1670">    return this.namedQueueRecorder;</span>
<span class="source-line-no">1671</span><span id="line-1671">  }</span>
<span class="source-line-no">1672</span><span id="line-1672"></span>
<span class="source-line-no">1673</span><span id="line-1673">  /*</span>
<span class="source-line-no">1674</span><span id="line-1674">   * Run init. Sets up wal and starts up all server threads.</span>
<span class="source-line-no">1675</span><span id="line-1675">   * @param c Extra configuration.</span>
<span class="source-line-no">1676</span><span id="line-1676">   */</span>
<span class="source-line-no">1677</span><span id="line-1677">  protected void handleReportForDutyResponse(final RegionServerStartupResponse c)</span>
<span class="source-line-no">1678</span><span id="line-1678">    throws IOException {</span>
<span class="source-line-no">1679</span><span id="line-1679">    try {</span>
<span class="source-line-no">1680</span><span id="line-1680">      boolean updateRootDir = false;</span>
<span class="source-line-no">1681</span><span id="line-1681">      for (NameStringPair e : c.getMapEntriesList()) {</span>
<span class="source-line-no">1682</span><span id="line-1682">        String key = e.getName();</span>
<span class="source-line-no">1683</span><span id="line-1683">        // The hostname the master sees us as.</span>
<span class="source-line-no">1684</span><span id="line-1684">        if (key.equals(HConstants.KEY_FOR_HOSTNAME_SEEN_BY_MASTER)) {</span>
<span class="source-line-no">1685</span><span id="line-1685">          String hostnameFromMasterPOV = e.getValue();</span>
<span class="source-line-no">1686</span><span id="line-1686">          this.serverName = ServerName.valueOf(hostnameFromMasterPOV,</span>
<span class="source-line-no">1687</span><span id="line-1687">            rpcServices.getSocketAddress().getPort(), this.startcode);</span>
<span class="source-line-no">1688</span><span id="line-1688">          String expectedHostName = rpcServices.getSocketAddress().getHostName();</span>
<span class="source-line-no">1689</span><span id="line-1689">          // if Master use-ip is enabled, RegionServer use-ip will be enabled by default even if it</span>
<span class="source-line-no">1690</span><span id="line-1690">          // is set to disable. so we will use the ip of the RegionServer to compare with the</span>
<span class="source-line-no">1691</span><span id="line-1691">          // hostname passed by the Master, see HBASE-27304 for details.</span>
<span class="source-line-no">1692</span><span id="line-1692">          if (</span>
<span class="source-line-no">1693</span><span id="line-1693">            StringUtils.isBlank(useThisHostnameInstead) &amp;&amp; getActiveMaster().isPresent()</span>
<span class="source-line-no">1694</span><span id="line-1694">              &amp;&amp; InetAddresses.isInetAddress(getActiveMaster().get().getHostname())</span>
<span class="source-line-no">1695</span><span id="line-1695">          ) {</span>
<span class="source-line-no">1696</span><span id="line-1696">            expectedHostName = rpcServices.getSocketAddress().getAddress().getHostAddress();</span>
<span class="source-line-no">1697</span><span id="line-1697">          }</span>
<span class="source-line-no">1698</span><span id="line-1698">          boolean isHostnameConsist = StringUtils.isBlank(useThisHostnameInstead)</span>
<span class="source-line-no">1699</span><span id="line-1699">            ? hostnameFromMasterPOV.equals(expectedHostName)</span>
<span class="source-line-no">1700</span><span id="line-1700">            : hostnameFromMasterPOV.equals(useThisHostnameInstead);</span>
<span class="source-line-no">1701</span><span id="line-1701">          if (!isHostnameConsist) {</span>
<span class="source-line-no">1702</span><span id="line-1702">            String msg = "Master passed us a different hostname to use; was="</span>
<span class="source-line-no">1703</span><span id="line-1703">              + (StringUtils.isBlank(useThisHostnameInstead)</span>
<span class="source-line-no">1704</span><span id="line-1704">                ? rpcServices.getSocketAddress().getHostName()</span>
<span class="source-line-no">1705</span><span id="line-1705">                : this.useThisHostnameInstead)</span>
<span class="source-line-no">1706</span><span id="line-1706">              + ", but now=" + hostnameFromMasterPOV;</span>
<span class="source-line-no">1707</span><span id="line-1707">            LOG.error(msg);</span>
<span class="source-line-no">1708</span><span id="line-1708">            throw new IOException(msg);</span>
<span class="source-line-no">1709</span><span id="line-1709">          }</span>
<span class="source-line-no">1710</span><span id="line-1710">          continue;</span>
<span class="source-line-no">1711</span><span id="line-1711">        }</span>
<span class="source-line-no">1712</span><span id="line-1712"></span>
<span class="source-line-no">1713</span><span id="line-1713">        String value = e.getValue();</span>
<span class="source-line-no">1714</span><span id="line-1714">        if (key.equals(HConstants.HBASE_DIR)) {</span>
<span class="source-line-no">1715</span><span id="line-1715">          if (value != null &amp;&amp; !value.equals(conf.get(HConstants.HBASE_DIR))) {</span>
<span class="source-line-no">1716</span><span id="line-1716">            updateRootDir = true;</span>
<span class="source-line-no">1717</span><span id="line-1717">          }</span>
<span class="source-line-no">1718</span><span id="line-1718">        }</span>
<span class="source-line-no">1719</span><span id="line-1719"></span>
<span class="source-line-no">1720</span><span id="line-1720">        if (LOG.isDebugEnabled()) {</span>
<span class="source-line-no">1721</span><span id="line-1721">          LOG.debug("Config from master: " + key + "=" + value);</span>
<span class="source-line-no">1722</span><span id="line-1722">        }</span>
<span class="source-line-no">1723</span><span id="line-1723">        this.conf.set(key, value);</span>
<span class="source-line-no">1724</span><span id="line-1724">      }</span>
<span class="source-line-no">1725</span><span id="line-1725">      // Set our ephemeral znode up in zookeeper now we have a name.</span>
<span class="source-line-no">1726</span><span id="line-1726">      createMyEphemeralNode();</span>
<span class="source-line-no">1727</span><span id="line-1727"></span>
<span class="source-line-no">1728</span><span id="line-1728">      if (updateRootDir) {</span>
<span class="source-line-no">1729</span><span id="line-1729">        // initialize file system by the config fs.defaultFS and hbase.rootdir from master</span>
<span class="source-line-no">1730</span><span id="line-1730">        initializeFileSystem();</span>
<span class="source-line-no">1731</span><span id="line-1731">      }</span>
<span class="source-line-no">1732</span><span id="line-1732"></span>
<span class="source-line-no">1733</span><span id="line-1733">      // hack! Maps DFSClient =&gt; RegionServer for logs. HDFS made this</span>
<span class="source-line-no">1734</span><span id="line-1734">      // config param for task trackers, but we can piggyback off of it.</span>
<span class="source-line-no">1735</span><span id="line-1735">      if (this.conf.get("mapreduce.task.attempt.id") == null) {</span>
<span class="source-line-no">1736</span><span id="line-1736">        this.conf.set("mapreduce.task.attempt.id", "hb_rs_" + this.serverName.toString());</span>
<span class="source-line-no">1737</span><span id="line-1737">      }</span>
<span class="source-line-no">1738</span><span id="line-1738"></span>
<span class="source-line-no">1739</span><span id="line-1739">      // Save it in a file, this will allow to see if we crash</span>
<span class="source-line-no">1740</span><span id="line-1740">      ZNodeClearer.writeMyEphemeralNodeOnDisk(getMyEphemeralNodePath());</span>
<span class="source-line-no">1741</span><span id="line-1741"></span>
<span class="source-line-no">1742</span><span id="line-1742">      // This call sets up an initialized replication and WAL. Later we start it up.</span>
<span class="source-line-no">1743</span><span id="line-1743">      setupWALAndReplication();</span>
<span class="source-line-no">1744</span><span id="line-1744">      // Init in here rather than in constructor after thread name has been set</span>
<span class="source-line-no">1745</span><span id="line-1745">      final MetricsTable metricsTable =</span>
<span class="source-line-no">1746</span><span id="line-1746">        new MetricsTable(new MetricsTableWrapperAggregateImpl(this));</span>
<span class="source-line-no">1747</span><span id="line-1747">      this.metricsRegionServerImpl = new MetricsRegionServerWrapperImpl(this);</span>
<span class="source-line-no">1748</span><span id="line-1748">      this.metricsRegionServer =</span>
<span class="source-line-no">1749</span><span id="line-1749">        new MetricsRegionServer(metricsRegionServerImpl, conf, metricsTable);</span>
<span class="source-line-no">1750</span><span id="line-1750">      // Now that we have a metrics source, start the pause monitor</span>
<span class="source-line-no">1751</span><span id="line-1751">      this.pauseMonitor = new JvmPauseMonitor(conf, getMetrics().getMetricsSource());</span>
<span class="source-line-no">1752</span><span id="line-1752">      pauseMonitor.start();</span>
<span class="source-line-no">1753</span><span id="line-1753"></span>
<span class="source-line-no">1754</span><span id="line-1754">      // There is a rare case where we do NOT want services to start. Check config.</span>
<span class="source-line-no">1755</span><span id="line-1755">      if (getConfiguration().getBoolean("hbase.regionserver.workers", true)) {</span>
<span class="source-line-no">1756</span><span id="line-1756">        startServices();</span>
<span class="source-line-no">1757</span><span id="line-1757">      }</span>
<span class="source-line-no">1758</span><span id="line-1758">      // In here we start up the replication Service. Above we initialized it. TODO. Reconcile.</span>
<span class="source-line-no">1759</span><span id="line-1759">      // or make sense of it.</span>
<span class="source-line-no">1760</span><span id="line-1760">      startReplicationService();</span>
<span class="source-line-no">1761</span><span id="line-1761"></span>
<span class="source-line-no">1762</span><span id="line-1762">      // Set up ZK</span>
<span class="source-line-no">1763</span><span id="line-1763">      LOG.info(</span>
<span class="source-line-no">1764</span><span id="line-1764">        "Serving as " + this.serverName + ", RpcServer on " + rpcServices.isa + ", sessionid=0x"</span>
<span class="source-line-no">1765</span><span id="line-1765">          + Long.toHexString(this.zooKeeper.getRecoverableZooKeeper().getSessionId()));</span>
<span class="source-line-no">1766</span><span id="line-1766"></span>
<span class="source-line-no">1767</span><span id="line-1767">      // Wake up anyone waiting for this server to online</span>
<span class="source-line-no">1768</span><span id="line-1768">      synchronized (online) {</span>
<span class="source-line-no">1769</span><span id="line-1769">        online.set(true);</span>
<span class="source-line-no">1770</span><span id="line-1770">        online.notifyAll();</span>
<span class="source-line-no">1771</span><span id="line-1771">      }</span>
<span class="source-line-no">1772</span><span id="line-1772">    } catch (Throwable e) {</span>
<span class="source-line-no">1773</span><span id="line-1773">      stop("Failed initialization");</span>
<span class="source-line-no">1774</span><span id="line-1774">      throw convertThrowableToIOE(cleanup(e, "Failed init"), "Region server startup failed");</span>
<span class="source-line-no">1775</span><span id="line-1775">    } finally {</span>
<span class="source-line-no">1776</span><span id="line-1776">      sleeper.skipSleepCycle();</span>
<span class="source-line-no">1777</span><span id="line-1777">    }</span>
<span class="source-line-no">1778</span><span id="line-1778">  }</span>
<span class="source-line-no">1779</span><span id="line-1779"></span>
<span class="source-line-no">1780</span><span id="line-1780">  protected void initializeMemStoreChunkCreator() {</span>
<span class="source-line-no">1781</span><span id="line-1781">    if (MemStoreLAB.isEnabled(conf)) {</span>
<span class="source-line-no">1782</span><span id="line-1782">      // MSLAB is enabled. So initialize MemStoreChunkPool</span>
<span class="source-line-no">1783</span><span id="line-1783">      // By this time, the MemstoreFlusher is already initialized. We can get the global limits from</span>
<span class="source-line-no">1784</span><span id="line-1784">      // it.</span>
<span class="source-line-no">1785</span><span id="line-1785">      Pair&lt;Long, MemoryType&gt; pair = MemorySizeUtil.getGlobalMemStoreSize(conf);</span>
<span class="source-line-no">1786</span><span id="line-1786">      long globalMemStoreSize = pair.getFirst();</span>
<span class="source-line-no">1787</span><span id="line-1787">      boolean offheap = this.regionServerAccounting.isOffheap();</span>
<span class="source-line-no">1788</span><span id="line-1788">      // When off heap memstore in use, take full area for chunk pool.</span>
<span class="source-line-no">1789</span><span id="line-1789">      float poolSizePercentage = offheap</span>
<span class="source-line-no">1790</span><span id="line-1790">        ? 1.0F</span>
<span class="source-line-no">1791</span><span id="line-1791">        : conf.getFloat(MemStoreLAB.CHUNK_POOL_MAXSIZE_KEY, MemStoreLAB.POOL_MAX_SIZE_DEFAULT);</span>
<span class="source-line-no">1792</span><span id="line-1792">      float initialCountPercentage = conf.getFloat(MemStoreLAB.CHUNK_POOL_INITIALSIZE_KEY,</span>
<span class="source-line-no">1793</span><span id="line-1793">        MemStoreLAB.POOL_INITIAL_SIZE_DEFAULT);</span>
<span class="source-line-no">1794</span><span id="line-1794">      int chunkSize = conf.getInt(MemStoreLAB.CHUNK_SIZE_KEY, MemStoreLAB.CHUNK_SIZE_DEFAULT);</span>
<span class="source-line-no">1795</span><span id="line-1795">      float indexChunkSizePercent = conf.getFloat(MemStoreLAB.INDEX_CHUNK_SIZE_PERCENTAGE_KEY,</span>
<span class="source-line-no">1796</span><span id="line-1796">        MemStoreLAB.INDEX_CHUNK_SIZE_PERCENTAGE_DEFAULT);</span>
<span class="source-line-no">1797</span><span id="line-1797">      // init the chunkCreator</span>
<span class="source-line-no">1798</span><span id="line-1798">      ChunkCreator.initialize(chunkSize, offheap, globalMemStoreSize, poolSizePercentage,</span>
<span class="source-line-no">1799</span><span id="line-1799">        initialCountPercentage, this.hMemManager, indexChunkSizePercent);</span>
<span class="source-line-no">1800</span><span id="line-1800">    }</span>
<span class="source-line-no">1801</span><span id="line-1801">  }</span>
<span class="source-line-no">1802</span><span id="line-1802"></span>
<span class="source-line-no">1803</span><span id="line-1803">  private void startHeapMemoryManager() {</span>
<span class="source-line-no">1804</span><span id="line-1804">    if (this.blockCache != null) {</span>
<span class="source-line-no">1805</span><span id="line-1805">      this.hMemManager =</span>
<span class="source-line-no">1806</span><span id="line-1806">        new HeapMemoryManager(this.blockCache, this.cacheFlusher, this, regionServerAccounting);</span>
<span class="source-line-no">1807</span><span id="line-1807">      this.hMemManager.start(getChoreService());</span>
<span class="source-line-no">1808</span><span id="line-1808">    }</span>
<span class="source-line-no">1809</span><span id="line-1809">  }</span>
<span class="source-line-no">1810</span><span id="line-1810"></span>
<span class="source-line-no">1811</span><span id="line-1811">  private void createMyEphemeralNode() throws KeeperException {</span>
<span class="source-line-no">1812</span><span id="line-1812">    RegionServerInfo.Builder rsInfo = RegionServerInfo.newBuilder();</span>
<span class="source-line-no">1813</span><span id="line-1813">    rsInfo.setInfoPort(infoServer != null ? infoServer.getPort() : -1);</span>
<span class="source-line-no">1814</span><span id="line-1814">    rsInfo.setVersionInfo(ProtobufUtil.getVersionInfo());</span>
<span class="source-line-no">1815</span><span id="line-1815">    byte[] data = ProtobufUtil.prependPBMagic(rsInfo.build().toByteArray());</span>
<span class="source-line-no">1816</span><span id="line-1816">    ZKUtil.createEphemeralNodeAndWatch(this.zooKeeper, getMyEphemeralNodePath(), data);</span>
<span class="source-line-no">1817</span><span id="line-1817">  }</span>
<span class="source-line-no">1818</span><span id="line-1818"></span>
<span class="source-line-no">1819</span><span id="line-1819">  private void deleteMyEphemeralNode() throws KeeperException {</span>
<span class="source-line-no">1820</span><span id="line-1820">    ZKUtil.deleteNode(this.zooKeeper, getMyEphemeralNodePath());</span>
<span class="source-line-no">1821</span><span id="line-1821">  }</span>
<span class="source-line-no">1822</span><span id="line-1822"></span>
<span class="source-line-no">1823</span><span id="line-1823">  @Override</span>
<span class="source-line-no">1824</span><span id="line-1824">  public RegionServerAccounting getRegionServerAccounting() {</span>
<span class="source-line-no">1825</span><span id="line-1825">    return regionServerAccounting;</span>
<span class="source-line-no">1826</span><span id="line-1826">  }</span>
<span class="source-line-no">1827</span><span id="line-1827"></span>
<span class="source-line-no">1828</span><span id="line-1828">  // Round the size with KB or MB.</span>
<span class="source-line-no">1829</span><span id="line-1829">  // A trick here is that if the sizeInBytes is less than sizeUnit, we will round the size to 1</span>
<span class="source-line-no">1830</span><span id="line-1830">  // instead of 0 if it is not 0, to avoid some schedulers think the region has no data. See</span>
<span class="source-line-no">1831</span><span id="line-1831">  // HBASE-26340 for more details on why this is important.</span>
<span class="source-line-no">1832</span><span id="line-1832">  private static int roundSize(long sizeInByte, int sizeUnit) {</span>
<span class="source-line-no">1833</span><span id="line-1833">    if (sizeInByte == 0) {</span>
<span class="source-line-no">1834</span><span id="line-1834">      return 0;</span>
<span class="source-line-no">1835</span><span id="line-1835">    } else if (sizeInByte &lt; sizeUnit) {</span>
<span class="source-line-no">1836</span><span id="line-1836">      return 1;</span>
<span class="source-line-no">1837</span><span id="line-1837">    } else {</span>
<span class="source-line-no">1838</span><span id="line-1838">      return (int) Math.min(sizeInByte / sizeUnit, Integer.MAX_VALUE);</span>
<span class="source-line-no">1839</span><span id="line-1839">    }</span>
<span class="source-line-no">1840</span><span id="line-1840">  }</span>
<span class="source-line-no">1841</span><span id="line-1841"></span>
<span class="source-line-no">1842</span><span id="line-1842">  private void computeIfPersistentBucketCache(Consumer&lt;BucketCache&gt; computation) {</span>
<span class="source-line-no">1843</span><span id="line-1843">    if (blockCache instanceof CombinedBlockCache) {</span>
<span class="source-line-no">1844</span><span id="line-1844">      BlockCache l2 = ((CombinedBlockCache) blockCache).getSecondLevelCache();</span>
<span class="source-line-no">1845</span><span id="line-1845">      if (l2 instanceof BucketCache &amp;&amp; ((BucketCache) l2).isCachePersistent()) {</span>
<span class="source-line-no">1846</span><span id="line-1846">        computation.accept((BucketCache) l2);</span>
<span class="source-line-no">1847</span><span id="line-1847">      }</span>
<span class="source-line-no">1848</span><span id="line-1848">    }</span>
<span class="source-line-no">1849</span><span id="line-1849">  }</span>
<span class="source-line-no">1850</span><span id="line-1850"></span>
<span class="source-line-no">1851</span><span id="line-1851">  /**</span>
<span class="source-line-no">1852</span><span id="line-1852">   * @param r               Region to get RegionLoad for.</span>
<span class="source-line-no">1853</span><span id="line-1853">   * @param regionLoadBldr  the RegionLoad.Builder, can be null</span>
<span class="source-line-no">1854</span><span id="line-1854">   * @param regionSpecifier the RegionSpecifier.Builder, can be null</span>
<span class="source-line-no">1855</span><span id="line-1855">   * @return RegionLoad instance.</span>
<span class="source-line-no">1856</span><span id="line-1856">   */</span>
<span class="source-line-no">1857</span><span id="line-1857">  RegionLoad createRegionLoad(final HRegion r, RegionLoad.Builder regionLoadBldr,</span>
<span class="source-line-no">1858</span><span id="line-1858">    RegionSpecifier.Builder regionSpecifier) throws IOException {</span>
<span class="source-line-no">1859</span><span id="line-1859">    byte[] name = r.getRegionInfo().getRegionName();</span>
<span class="source-line-no">1860</span><span id="line-1860">    String regionEncodedName = r.getRegionInfo().getEncodedName();</span>
<span class="source-line-no">1861</span><span id="line-1861">    int stores = 0;</span>
<span class="source-line-no">1862</span><span id="line-1862">    int storefiles = 0;</span>
<span class="source-line-no">1863</span><span id="line-1863">    int storeRefCount = 0;</span>
<span class="source-line-no">1864</span><span id="line-1864">    int maxCompactedStoreFileRefCount = 0;</span>
<span class="source-line-no">1865</span><span id="line-1865">    long storeUncompressedSize = 0L;</span>
<span class="source-line-no">1866</span><span id="line-1866">    long storefileSize = 0L;</span>
<span class="source-line-no">1867</span><span id="line-1867">    long storefileIndexSize = 0L;</span>
<span class="source-line-no">1868</span><span id="line-1868">    long rootLevelIndexSize = 0L;</span>
<span class="source-line-no">1869</span><span id="line-1869">    long totalStaticIndexSize = 0L;</span>
<span class="source-line-no">1870</span><span id="line-1870">    long totalStaticBloomSize = 0L;</span>
<span class="source-line-no">1871</span><span id="line-1871">    long totalCompactingKVs = 0L;</span>
<span class="source-line-no">1872</span><span id="line-1872">    long currentCompactedKVs = 0L;</span>
<span class="source-line-no">1873</span><span id="line-1873">    long totalRegionSize = 0L;</span>
<span class="source-line-no">1874</span><span id="line-1874">    List&lt;HStore&gt; storeList = r.getStores();</span>
<span class="source-line-no">1875</span><span id="line-1875">    stores += storeList.size();</span>
<span class="source-line-no">1876</span><span id="line-1876">    for (HStore store : storeList) {</span>
<span class="source-line-no">1877</span><span id="line-1877">      storefiles += store.getStorefilesCount();</span>
<span class="source-line-no">1878</span><span id="line-1878">      int currentStoreRefCount = store.getStoreRefCount();</span>
<span class="source-line-no">1879</span><span id="line-1879">      storeRefCount += currentStoreRefCount;</span>
<span class="source-line-no">1880</span><span id="line-1880">      int currentMaxCompactedStoreFileRefCount = store.getMaxCompactedStoreFileRefCount();</span>
<span class="source-line-no">1881</span><span id="line-1881">      maxCompactedStoreFileRefCount =</span>
<span class="source-line-no">1882</span><span id="line-1882">        Math.max(maxCompactedStoreFileRefCount, currentMaxCompactedStoreFileRefCount);</span>
<span class="source-line-no">1883</span><span id="line-1883">      storeUncompressedSize += store.getStoreSizeUncompressed();</span>
<span class="source-line-no">1884</span><span id="line-1884">      storefileSize += store.getStorefilesSize();</span>
<span class="source-line-no">1885</span><span id="line-1885">      totalRegionSize += store.getHFilesSize();</span>
<span class="source-line-no">1886</span><span id="line-1886">      // TODO: storefileIndexSizeKB is same with rootLevelIndexSizeKB?</span>
<span class="source-line-no">1887</span><span id="line-1887">      storefileIndexSize += store.getStorefilesRootLevelIndexSize();</span>
<span class="source-line-no">1888</span><span id="line-1888">      CompactionProgress progress = store.getCompactionProgress();</span>
<span class="source-line-no">1889</span><span id="line-1889">      if (progress != null) {</span>
<span class="source-line-no">1890</span><span id="line-1890">        totalCompactingKVs += progress.getTotalCompactingKVs();</span>
<span class="source-line-no">1891</span><span id="line-1891">        currentCompactedKVs += progress.currentCompactedKVs;</span>
<span class="source-line-no">1892</span><span id="line-1892">      }</span>
<span class="source-line-no">1893</span><span id="line-1893">      rootLevelIndexSize += store.getStorefilesRootLevelIndexSize();</span>
<span class="source-line-no">1894</span><span id="line-1894">      totalStaticIndexSize += store.getTotalStaticIndexSize();</span>
<span class="source-line-no">1895</span><span id="line-1895">      totalStaticBloomSize += store.getTotalStaticBloomSize();</span>
<span class="source-line-no">1896</span><span id="line-1896">    }</span>
<span class="source-line-no">1897</span><span id="line-1897"></span>
<span class="source-line-no">1898</span><span id="line-1898">    int memstoreSizeMB = roundSize(r.getMemStoreDataSize(), unitMB);</span>
<span class="source-line-no">1899</span><span id="line-1899">    int storeUncompressedSizeMB = roundSize(storeUncompressedSize, unitMB);</span>
<span class="source-line-no">1900</span><span id="line-1900">    int storefileSizeMB = roundSize(storefileSize, unitMB);</span>
<span class="source-line-no">1901</span><span id="line-1901">    int storefileIndexSizeKB = roundSize(storefileIndexSize, unitKB);</span>
<span class="source-line-no">1902</span><span id="line-1902">    int rootLevelIndexSizeKB = roundSize(rootLevelIndexSize, unitKB);</span>
<span class="source-line-no">1903</span><span id="line-1903">    int totalStaticIndexSizeKB = roundSize(totalStaticIndexSize, unitKB);</span>
<span class="source-line-no">1904</span><span id="line-1904">    int totalStaticBloomSizeKB = roundSize(totalStaticBloomSize, unitKB);</span>
<span class="source-line-no">1905</span><span id="line-1905">    int regionSizeMB = roundSize(totalRegionSize, unitMB);</span>
<span class="source-line-no">1906</span><span id="line-1906">    final MutableFloat currentRegionCachedRatio = new MutableFloat(0.0f);</span>
<span class="source-line-no">1907</span><span id="line-1907">    computeIfPersistentBucketCache(bc -&gt; {</span>
<span class="source-line-no">1908</span><span id="line-1908">      if (bc.getRegionCachedInfo().containsKey(regionEncodedName)) {</span>
<span class="source-line-no">1909</span><span id="line-1909">        currentRegionCachedRatio.setValue(regionSizeMB == 0</span>
<span class="source-line-no">1910</span><span id="line-1910">          ? 0.0f</span>
<span class="source-line-no">1911</span><span id="line-1911">          : (float) roundSize(bc.getRegionCachedInfo().get(regionEncodedName), unitMB)</span>
<span class="source-line-no">1912</span><span id="line-1912">            / regionSizeMB);</span>
<span class="source-line-no">1913</span><span id="line-1913">      }</span>
<span class="source-line-no">1914</span><span id="line-1914">    });</span>
<span class="source-line-no">1915</span><span id="line-1915"></span>
<span class="source-line-no">1916</span><span id="line-1916">    HDFSBlocksDistribution hdfsBd = r.getHDFSBlocksDistribution();</span>
<span class="source-line-no">1917</span><span id="line-1917">    float dataLocality = hdfsBd.getBlockLocalityIndex(serverName.getHostname());</span>
<span class="source-line-no">1918</span><span id="line-1918">    float dataLocalityForSsd = hdfsBd.getBlockLocalityIndexForSsd(serverName.getHostname());</span>
<span class="source-line-no">1919</span><span id="line-1919">    long blocksTotalWeight = hdfsBd.getUniqueBlocksTotalWeight();</span>
<span class="source-line-no">1920</span><span id="line-1920">    long blocksLocalWeight = hdfsBd.getBlocksLocalWeight(serverName.getHostname());</span>
<span class="source-line-no">1921</span><span id="line-1921">    long blocksLocalWithSsdWeight = hdfsBd.getBlocksLocalWithSsdWeight(serverName.getHostname());</span>
<span class="source-line-no">1922</span><span id="line-1922">    if (regionLoadBldr == null) {</span>
<span class="source-line-no">1923</span><span id="line-1923">      regionLoadBldr = RegionLoad.newBuilder();</span>
<span class="source-line-no">1924</span><span id="line-1924">    }</span>
<span class="source-line-no">1925</span><span id="line-1925">    if (regionSpecifier == null) {</span>
<span class="source-line-no">1926</span><span id="line-1926">      regionSpecifier = RegionSpecifier.newBuilder();</span>
<span class="source-line-no">1927</span><span id="line-1927">    }</span>
<span class="source-line-no">1928</span><span id="line-1928"></span>
<span class="source-line-no">1929</span><span id="line-1929">    regionSpecifier.setType(RegionSpecifierType.REGION_NAME);</span>
<span class="source-line-no">1930</span><span id="line-1930">    regionSpecifier.setValue(UnsafeByteOperations.unsafeWrap(name));</span>
<span class="source-line-no">1931</span><span id="line-1931">    regionLoadBldr.setRegionSpecifier(regionSpecifier.build()).setStores(stores)</span>
<span class="source-line-no">1932</span><span id="line-1932">      .setStorefiles(storefiles).setStoreRefCount(storeRefCount)</span>
<span class="source-line-no">1933</span><span id="line-1933">      .setMaxCompactedStoreFileRefCount(maxCompactedStoreFileRefCount)</span>
<span class="source-line-no">1934</span><span id="line-1934">      .setStoreUncompressedSizeMB(storeUncompressedSizeMB).setStorefileSizeMB(storefileSizeMB)</span>
<span class="source-line-no">1935</span><span id="line-1935">      .setMemStoreSizeMB(memstoreSizeMB).setStorefileIndexSizeKB(storefileIndexSizeKB)</span>
<span class="source-line-no">1936</span><span id="line-1936">      .setRootIndexSizeKB(rootLevelIndexSizeKB).setTotalStaticIndexSizeKB(totalStaticIndexSizeKB)</span>
<span class="source-line-no">1937</span><span id="line-1937">      .setTotalStaticBloomSizeKB(totalStaticBloomSizeKB)</span>
<span class="source-line-no">1938</span><span id="line-1938">      .setReadRequestsCount(r.getReadRequestsCount())</span>
<span class="source-line-no">1939</span><span id="line-1939">      .setFilteredReadRequestsCount(r.getFilteredReadRequestsCount())</span>
<span class="source-line-no">1940</span><span id="line-1940">      .setWriteRequestsCount(r.getWriteRequestsCount()).setTotalCompactingKVs(totalCompactingKVs)</span>
<span class="source-line-no">1941</span><span id="line-1941">      .setCurrentCompactedKVs(currentCompactedKVs).setDataLocality(dataLocality)</span>
<span class="source-line-no">1942</span><span id="line-1942">      .setDataLocalityForSsd(dataLocalityForSsd).setBlocksLocalWeight(blocksLocalWeight)</span>
<span class="source-line-no">1943</span><span id="line-1943">      .setBlocksLocalWithSsdWeight(blocksLocalWithSsdWeight).setBlocksTotalWeight(blocksTotalWeight)</span>
<span class="source-line-no">1944</span><span id="line-1944">      .setCompactionState(ProtobufUtil.createCompactionStateForRegionLoad(r.getCompactionState()))</span>
<span class="source-line-no">1945</span><span id="line-1945">      .setLastMajorCompactionTs(r.getOldestHfileTs(true)).setRegionSizeMB(regionSizeMB)</span>
<span class="source-line-no">1946</span><span id="line-1946">      .setCurrentRegionCachedRatio(currentRegionCachedRatio.floatValue());</span>
<span class="source-line-no">1947</span><span id="line-1947">    r.setCompleteSequenceId(regionLoadBldr);</span>
<span class="source-line-no">1948</span><span id="line-1948">    return regionLoadBldr.build();</span>
<span class="source-line-no">1949</span><span id="line-1949">  }</span>
<span class="source-line-no">1950</span><span id="line-1950"></span>
<span class="source-line-no">1951</span><span id="line-1951">  private UserLoad createUserLoad(String user, MetricsUserSource userSource) {</span>
<span class="source-line-no">1952</span><span id="line-1952">    UserLoad.Builder userLoadBldr = UserLoad.newBuilder();</span>
<span class="source-line-no">1953</span><span id="line-1953">    userLoadBldr.setUserName(user);</span>
<span class="source-line-no">1954</span><span id="line-1954">    userSource.getClientMetrics().values().stream()</span>
<span class="source-line-no">1955</span><span id="line-1955">      .map(clientMetrics -&gt; ClusterStatusProtos.ClientMetrics.newBuilder()</span>
<span class="source-line-no">1956</span><span id="line-1956">        .setHostName(clientMetrics.getHostName())</span>
<span class="source-line-no">1957</span><span id="line-1957">        .setWriteRequestsCount(clientMetrics.getWriteRequestsCount())</span>
<span class="source-line-no">1958</span><span id="line-1958">        .setFilteredRequestsCount(clientMetrics.getFilteredReadRequests())</span>
<span class="source-line-no">1959</span><span id="line-1959">        .setReadRequestsCount(clientMetrics.getReadRequestsCount()).build())</span>
<span class="source-line-no">1960</span><span id="line-1960">      .forEach(userLoadBldr::addClientMetrics);</span>
<span class="source-line-no">1961</span><span id="line-1961">    return userLoadBldr.build();</span>
<span class="source-line-no">1962</span><span id="line-1962">  }</span>
<span class="source-line-no">1963</span><span id="line-1963"></span>
<span class="source-line-no">1964</span><span id="line-1964">  public RegionLoad createRegionLoad(final String encodedRegionName) throws IOException {</span>
<span class="source-line-no">1965</span><span id="line-1965">    HRegion r = onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">1966</span><span id="line-1966">    return r != null ? createRegionLoad(r, null, null) : null;</span>
<span class="source-line-no">1967</span><span id="line-1967">  }</span>
<span class="source-line-no">1968</span><span id="line-1968"></span>
<span class="source-line-no">1969</span><span id="line-1969">  /**</span>
<span class="source-line-no">1970</span><span id="line-1970">   * Inner class that runs on a long period checking if regions need compaction.</span>
<span class="source-line-no">1971</span><span id="line-1971">   */</span>
<span class="source-line-no">1972</span><span id="line-1972">  private static class CompactionChecker extends ScheduledChore {</span>
<span class="source-line-no">1973</span><span id="line-1973">    private final HRegionServer instance;</span>
<span class="source-line-no">1974</span><span id="line-1974">    private final int majorCompactPriority;</span>
<span class="source-line-no">1975</span><span id="line-1975">    private final static int DEFAULT_PRIORITY = Integer.MAX_VALUE;</span>
<span class="source-line-no">1976</span><span id="line-1976">    // Iteration is 1-based rather than 0-based so we don't check for compaction</span>
<span class="source-line-no">1977</span><span id="line-1977">    // immediately upon region server startup</span>
<span class="source-line-no">1978</span><span id="line-1978">    private long iteration = 1;</span>
<span class="source-line-no">1979</span><span id="line-1979"></span>
<span class="source-line-no">1980</span><span id="line-1980">    CompactionChecker(final HRegionServer h, final int sleepTime, final Stoppable stopper) {</span>
<span class="source-line-no">1981</span><span id="line-1981">      super("CompactionChecker", stopper, sleepTime);</span>
<span class="source-line-no">1982</span><span id="line-1982">      this.instance = h;</span>
<span class="source-line-no">1983</span><span id="line-1983">      LOG.info(this.getName() + " runs every " + Duration.ofMillis(sleepTime));</span>
<span class="source-line-no">1984</span><span id="line-1984"></span>
<span class="source-line-no">1985</span><span id="line-1985">      /*</span>
<span class="source-line-no">1986</span><span id="line-1986">       * MajorCompactPriority is configurable. If not set, the compaction will use default priority.</span>
<span class="source-line-no">1987</span><span id="line-1987">       */</span>
<span class="source-line-no">1988</span><span id="line-1988">      this.majorCompactPriority = this.instance.conf</span>
<span class="source-line-no">1989</span><span id="line-1989">        .getInt("hbase.regionserver.compactionChecker.majorCompactPriority", DEFAULT_PRIORITY);</span>
<span class="source-line-no">1990</span><span id="line-1990">    }</span>
<span class="source-line-no">1991</span><span id="line-1991"></span>
<span class="source-line-no">1992</span><span id="line-1992">    @Override</span>
<span class="source-line-no">1993</span><span id="line-1993">    protected void chore() {</span>
<span class="source-line-no">1994</span><span id="line-1994">      for (HRegion hr : this.instance.onlineRegions.values()) {</span>
<span class="source-line-no">1995</span><span id="line-1995">        // If region is read only or compaction is disabled at table level, there's no need to</span>
<span class="source-line-no">1996</span><span id="line-1996">        // iterate through region's stores</span>
<span class="source-line-no">1997</span><span id="line-1997">        if (hr == null || hr.isReadOnly() || !hr.getTableDescriptor().isCompactionEnabled()) {</span>
<span class="source-line-no">1998</span><span id="line-1998">          continue;</span>
<span class="source-line-no">1999</span><span id="line-1999">        }</span>
<span class="source-line-no">2000</span><span id="line-2000">        for (HStore s : hr.stores.values()) {</span>
<span class="source-line-no">2001</span><span id="line-2001">          try {</span>
<span class="source-line-no">2002</span><span id="line-2002">            long multiplier = s.getCompactionCheckMultiplier();</span>
<span class="source-line-no">2003</span><span id="line-2003">            assert multiplier &gt; 0;</span>
<span class="source-line-no">2004</span><span id="line-2004">            if (iteration % multiplier != 0) {</span>
<span class="source-line-no">2005</span><span id="line-2005">              continue;</span>
<span class="source-line-no">2006</span><span id="line-2006">            }</span>
<span class="source-line-no">2007</span><span id="line-2007">            if (s.needsCompaction()) {</span>
<span class="source-line-no">2008</span><span id="line-2008">              // Queue a compaction. Will recognize if major is needed.</span>
<span class="source-line-no">2009</span><span id="line-2009">              this.instance.compactSplitThread.requestSystemCompaction(hr, s,</span>
<span class="source-line-no">2010</span><span id="line-2010">                getName() + " requests compaction");</span>
<span class="source-line-no">2011</span><span id="line-2011">            } else if (s.shouldPerformMajorCompaction()) {</span>
<span class="source-line-no">2012</span><span id="line-2012">              s.triggerMajorCompaction();</span>
<span class="source-line-no">2013</span><span id="line-2013">              if (</span>
<span class="source-line-no">2014</span><span id="line-2014">                majorCompactPriority == DEFAULT_PRIORITY</span>
<span class="source-line-no">2015</span><span id="line-2015">                  || majorCompactPriority &gt; hr.getCompactPriority()</span>
<span class="source-line-no">2016</span><span id="line-2016">              ) {</span>
<span class="source-line-no">2017</span><span id="line-2017">                this.instance.compactSplitThread.requestCompaction(hr, s,</span>
<span class="source-line-no">2018</span><span id="line-2018">                  getName() + " requests major compaction; use default priority", Store.NO_PRIORITY,</span>
<span class="source-line-no">2019</span><span id="line-2019">                  CompactionLifeCycleTracker.DUMMY, null);</span>
<span class="source-line-no">2020</span><span id="line-2020">              } else {</span>
<span class="source-line-no">2021</span><span id="line-2021">                this.instance.compactSplitThread.requestCompaction(hr, s,</span>
<span class="source-line-no">2022</span><span id="line-2022">                  getName() + " requests major compaction; use configured priority",</span>
<span class="source-line-no">2023</span><span id="line-2023">                  this.majorCompactPriority, CompactionLifeCycleTracker.DUMMY, null);</span>
<span class="source-line-no">2024</span><span id="line-2024">              }</span>
<span class="source-line-no">2025</span><span id="line-2025">            }</span>
<span class="source-line-no">2026</span><span id="line-2026">          } catch (IOException e) {</span>
<span class="source-line-no">2027</span><span id="line-2027">            LOG.warn("Failed major compaction check on " + hr, e);</span>
<span class="source-line-no">2028</span><span id="line-2028">          }</span>
<span class="source-line-no">2029</span><span id="line-2029">        }</span>
<span class="source-line-no">2030</span><span id="line-2030">      }</span>
<span class="source-line-no">2031</span><span id="line-2031">      iteration = (iteration == Long.MAX_VALUE) ? 0 : (iteration + 1);</span>
<span class="source-line-no">2032</span><span id="line-2032">    }</span>
<span class="source-line-no">2033</span><span id="line-2033">  }</span>
<span class="source-line-no">2034</span><span id="line-2034"></span>
<span class="source-line-no">2035</span><span id="line-2035">  private static class PeriodicMemStoreFlusher extends ScheduledChore {</span>
<span class="source-line-no">2036</span><span id="line-2036">    private final HRegionServer server;</span>
<span class="source-line-no">2037</span><span id="line-2037">    private final static int RANGE_OF_DELAY = 5 * 60; // 5 min in seconds</span>
<span class="source-line-no">2038</span><span id="line-2038">    private final static int MIN_DELAY_TIME = 0; // millisec</span>
<span class="source-line-no">2039</span><span id="line-2039">    private final long rangeOfDelayMs;</span>
<span class="source-line-no">2040</span><span id="line-2040"></span>
<span class="source-line-no">2041</span><span id="line-2041">    PeriodicMemStoreFlusher(int cacheFlushInterval, final HRegionServer server) {</span>
<span class="source-line-no">2042</span><span id="line-2042">      super("MemstoreFlusherChore", server, cacheFlushInterval);</span>
<span class="source-line-no">2043</span><span id="line-2043">      this.server = server;</span>
<span class="source-line-no">2044</span><span id="line-2044"></span>
<span class="source-line-no">2045</span><span id="line-2045">      final long configuredRangeOfDelay = server.getConfiguration()</span>
<span class="source-line-no">2046</span><span id="line-2046">        .getInt("hbase.regionserver.periodicmemstoreflusher.rangeofdelayseconds", RANGE_OF_DELAY);</span>
<span class="source-line-no">2047</span><span id="line-2047">      this.rangeOfDelayMs = TimeUnit.SECONDS.toMillis(configuredRangeOfDelay);</span>
<span class="source-line-no">2048</span><span id="line-2048">    }</span>
<span class="source-line-no">2049</span><span id="line-2049"></span>
<span class="source-line-no">2050</span><span id="line-2050">    @Override</span>
<span class="source-line-no">2051</span><span id="line-2051">    protected void chore() {</span>
<span class="source-line-no">2052</span><span id="line-2052">      final StringBuilder whyFlush = new StringBuilder();</span>
<span class="source-line-no">2053</span><span id="line-2053">      for (HRegion r : this.server.onlineRegions.values()) {</span>
<span class="source-line-no">2054</span><span id="line-2054">        if (r == null) {</span>
<span class="source-line-no">2055</span><span id="line-2055">          continue;</span>
<span class="source-line-no">2056</span><span id="line-2056">        }</span>
<span class="source-line-no">2057</span><span id="line-2057">        if (r.shouldFlush(whyFlush)) {</span>
<span class="source-line-no">2058</span><span id="line-2058">          FlushRequester requester = server.getFlushRequester();</span>
<span class="source-line-no">2059</span><span id="line-2059">          if (requester != null) {</span>
<span class="source-line-no">2060</span><span id="line-2060">            long delay = ThreadLocalRandom.current().nextLong(rangeOfDelayMs) + MIN_DELAY_TIME;</span>
<span class="source-line-no">2061</span><span id="line-2061">            // Throttle the flushes by putting a delay. If we don't throttle, and there</span>
<span class="source-line-no">2062</span><span id="line-2062">            // is a balanced write-load on the regions in a table, we might end up</span>
<span class="source-line-no">2063</span><span id="line-2063">            // overwhelming the filesystem with too many flushes at once.</span>
<span class="source-line-no">2064</span><span id="line-2064">            if (requester.requestDelayedFlush(r, delay)) {</span>
<span class="source-line-no">2065</span><span id="line-2065">              LOG.info("{} requesting flush of {} because {} after random delay {} ms", getName(),</span>
<span class="source-line-no">2066</span><span id="line-2066">                r.getRegionInfo().getRegionNameAsString(), whyFlush.toString(), delay);</span>
<span class="source-line-no">2067</span><span id="line-2067">            }</span>
<span class="source-line-no">2068</span><span id="line-2068">          }</span>
<span class="source-line-no">2069</span><span id="line-2069">        }</span>
<span class="source-line-no">2070</span><span id="line-2070">      }</span>
<span class="source-line-no">2071</span><span id="line-2071">    }</span>
<span class="source-line-no">2072</span><span id="line-2072">  }</span>
<span class="source-line-no">2073</span><span id="line-2073"></span>
<span class="source-line-no">2074</span><span id="line-2074">  /**</span>
<span class="source-line-no">2075</span><span id="line-2075">   * Report the status of the server. A server is online once all the startup is completed (setting</span>
<span class="source-line-no">2076</span><span id="line-2076">   * up filesystem, starting executorService threads, etc.). This method is designed mostly to be</span>
<span class="source-line-no">2077</span><span id="line-2077">   * useful in tests.</span>
<span class="source-line-no">2078</span><span id="line-2078">   * @return true if online, false if not.</span>
<span class="source-line-no">2079</span><span id="line-2079">   */</span>
<span class="source-line-no">2080</span><span id="line-2080">  public boolean isOnline() {</span>
<span class="source-line-no">2081</span><span id="line-2081">    return online.get();</span>
<span class="source-line-no">2082</span><span id="line-2082">  }</span>
<span class="source-line-no">2083</span><span id="line-2083"></span>
<span class="source-line-no">2084</span><span id="line-2084">  /**</span>
<span class="source-line-no">2085</span><span id="line-2085">   * Setup WAL log and replication if enabled. Replication setup is done in here because it wants to</span>
<span class="source-line-no">2086</span><span id="line-2086">   * be hooked up to WAL.</span>
<span class="source-line-no">2087</span><span id="line-2087">   */</span>
<span class="source-line-no">2088</span><span id="line-2088">  private void setupWALAndReplication() throws IOException {</span>
<span class="source-line-no">2089</span><span id="line-2089">    WALFactory factory = new WALFactory(conf, serverName.toString(), (Server) this);</span>
<span class="source-line-no">2090</span><span id="line-2090">    // TODO Replication make assumptions here based on the default filesystem impl</span>
<span class="source-line-no">2091</span><span id="line-2091">    Path oldLogDir = new Path(walRootDir, HConstants.HREGION_OLDLOGDIR_NAME);</span>
<span class="source-line-no">2092</span><span id="line-2092">    String logName = AbstractFSWALProvider.getWALDirectoryName(this.serverName.toString());</span>
<span class="source-line-no">2093</span><span id="line-2093"></span>
<span class="source-line-no">2094</span><span id="line-2094">    Path logDir = new Path(walRootDir, logName);</span>
<span class="source-line-no">2095</span><span id="line-2095">    LOG.debug("logDir={}", logDir);</span>
<span class="source-line-no">2096</span><span id="line-2096">    if (this.walFs.exists(logDir)) {</span>
<span class="source-line-no">2097</span><span id="line-2097">      throw new RegionServerRunningException(</span>
<span class="source-line-no">2098</span><span id="line-2098">        "Region server has already created directory at " + this.serverName.toString());</span>
<span class="source-line-no">2099</span><span id="line-2099">    }</span>
<span class="source-line-no">2100</span><span id="line-2100">    // Always create wal directory as now we need this when master restarts to find out the live</span>
<span class="source-line-no">2101</span><span id="line-2101">    // region servers.</span>
<span class="source-line-no">2102</span><span id="line-2102">    if (!this.walFs.mkdirs(logDir)) {</span>
<span class="source-line-no">2103</span><span id="line-2103">      throw new IOException("Can not create wal directory " + logDir);</span>
<span class="source-line-no">2104</span><span id="line-2104">    }</span>
<span class="source-line-no">2105</span><span id="line-2105">    // Instantiate replication if replication enabled. Pass it the log directories.</span>
<span class="source-line-no">2106</span><span id="line-2106">    createNewReplicationInstance(conf, this, this.walFs, logDir, oldLogDir, factory);</span>
<span class="source-line-no">2107</span><span id="line-2107"></span>
<span class="source-line-no">2108</span><span id="line-2108">    WALActionsListener walEventListener = getWALEventTrackerListener(conf);</span>
<span class="source-line-no">2109</span><span id="line-2109">    if (walEventListener != null &amp;&amp; factory.getWALProvider() != null) {</span>
<span class="source-line-no">2110</span><span id="line-2110">      factory.getWALProvider().addWALActionsListener(walEventListener);</span>
<span class="source-line-no">2111</span><span id="line-2111">    }</span>
<span class="source-line-no">2112</span><span id="line-2112">    this.walFactory = factory;</span>
<span class="source-line-no">2113</span><span id="line-2113">  }</span>
<span class="source-line-no">2114</span><span id="line-2114"></span>
<span class="source-line-no">2115</span><span id="line-2115">  private WALActionsListener getWALEventTrackerListener(Configuration conf) {</span>
<span class="source-line-no">2116</span><span id="line-2116">    if (conf.getBoolean(WAL_EVENT_TRACKER_ENABLED_KEY, WAL_EVENT_TRACKER_ENABLED_DEFAULT)) {</span>
<span class="source-line-no">2117</span><span id="line-2117">      WALEventTrackerListener listener =</span>
<span class="source-line-no">2118</span><span id="line-2118">        new WALEventTrackerListener(conf, getNamedQueueRecorder(), getServerName());</span>
<span class="source-line-no">2119</span><span id="line-2119">      return listener;</span>
<span class="source-line-no">2120</span><span id="line-2120">    }</span>
<span class="source-line-no">2121</span><span id="line-2121">    return null;</span>
<span class="source-line-no">2122</span><span id="line-2122">  }</span>
<span class="source-line-no">2123</span><span id="line-2123"></span>
<span class="source-line-no">2124</span><span id="line-2124">  /**</span>
<span class="source-line-no">2125</span><span id="line-2125">   * Start up replication source and sink handlers.</span>
<span class="source-line-no">2126</span><span id="line-2126">   */</span>
<span class="source-line-no">2127</span><span id="line-2127">  private void startReplicationService() throws IOException {</span>
<span class="source-line-no">2128</span><span id="line-2128">    if (</span>
<span class="source-line-no">2129</span><span id="line-2129">      this.replicationSourceHandler == this.replicationSinkHandler</span>
<span class="source-line-no">2130</span><span id="line-2130">        &amp;&amp; this.replicationSourceHandler != null</span>
<span class="source-line-no">2131</span><span id="line-2131">    ) {</span>
<span class="source-line-no">2132</span><span id="line-2132">      this.replicationSourceHandler.startReplicationService();</span>
<span class="source-line-no">2133</span><span id="line-2133">    } else {</span>
<span class="source-line-no">2134</span><span id="line-2134">      if (this.replicationSourceHandler != null) {</span>
<span class="source-line-no">2135</span><span id="line-2135">        this.replicationSourceHandler.startReplicationService();</span>
<span class="source-line-no">2136</span><span id="line-2136">      }</span>
<span class="source-line-no">2137</span><span id="line-2137">      if (this.replicationSinkHandler != null) {</span>
<span class="source-line-no">2138</span><span id="line-2138">        this.replicationSinkHandler.startReplicationService();</span>
<span class="source-line-no">2139</span><span id="line-2139">      }</span>
<span class="source-line-no">2140</span><span id="line-2140">    }</span>
<span class="source-line-no">2141</span><span id="line-2141">  }</span>
<span class="source-line-no">2142</span><span id="line-2142"></span>
<span class="source-line-no">2143</span><span id="line-2143">  /** Returns Master address tracker instance. */</span>
<span class="source-line-no">2144</span><span id="line-2144">  public MasterAddressTracker getMasterAddressTracker() {</span>
<span class="source-line-no">2145</span><span id="line-2145">    return this.masterAddressTracker;</span>
<span class="source-line-no">2146</span><span id="line-2146">  }</span>
<span class="source-line-no">2147</span><span id="line-2147"></span>
<span class="source-line-no">2148</span><span id="line-2148">  /**</span>
<span class="source-line-no">2149</span><span id="line-2149">   * Start maintenance Threads, Server, Worker and lease checker threads. Start all threads we need</span>
<span class="source-line-no">2150</span><span id="line-2150">   * to run. This is called after we've successfully registered with the Master. Install an</span>
<span class="source-line-no">2151</span><span id="line-2151">   * UncaughtExceptionHandler that calls abort of RegionServer if we get an unhandled exception. We</span>
<span class="source-line-no">2152</span><span id="line-2152">   * cannot set the handler on all threads. Server's internal Listener thread is off limits. For</span>
<span class="source-line-no">2153</span><span id="line-2153">   * Server, if an OOME, it waits a while then retries. Meantime, a flush or a compaction that tries</span>
<span class="source-line-no">2154</span><span id="line-2154">   * to run should trigger same critical condition and the shutdown will run. On its way out, this</span>
<span class="source-line-no">2155</span><span id="line-2155">   * server will shut down Server. Leases are sort of inbetween. It has an internal thread that</span>
<span class="source-line-no">2156</span><span id="line-2156">   * while it inherits from Chore, it keeps its own internal stop mechanism so needs to be stopped</span>
<span class="source-line-no">2157</span><span id="line-2157">   * by this hosting server. Worker logs the exception and exits.</span>
<span class="source-line-no">2158</span><span id="line-2158">   */</span>
<span class="source-line-no">2159</span><span id="line-2159">  private void startServices() throws IOException {</span>
<span class="source-line-no">2160</span><span id="line-2160">    if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">2161</span><span id="line-2161">      initializeThreads();</span>
<span class="source-line-no">2162</span><span id="line-2162">    }</span>
<span class="source-line-no">2163</span><span id="line-2163">    this.secureBulkLoadManager = new SecureBulkLoadManager(this.conf, clusterConnection);</span>
<span class="source-line-no">2164</span><span id="line-2164">    this.secureBulkLoadManager.start();</span>
<span class="source-line-no">2165</span><span id="line-2165"></span>
<span class="source-line-no">2166</span><span id="line-2166">    // Health checker thread.</span>
<span class="source-line-no">2167</span><span id="line-2167">    if (isHealthCheckerConfigured()) {</span>
<span class="source-line-no">2168</span><span id="line-2168">      int sleepTime = this.conf.getInt(HConstants.HEALTH_CHORE_WAKE_FREQ,</span>
<span class="source-line-no">2169</span><span id="line-2169">        HConstants.DEFAULT_THREAD_WAKE_FREQUENCY);</span>
<span class="source-line-no">2170</span><span id="line-2170">      healthCheckChore = new HealthCheckChore(sleepTime, this, getConfiguration());</span>
<span class="source-line-no">2171</span><span id="line-2171">    }</span>
<span class="source-line-no">2172</span><span id="line-2172"></span>
<span class="source-line-no">2173</span><span id="line-2173">    this.walRoller = new LogRoller(this);</span>
<span class="source-line-no">2174</span><span id="line-2174">    this.flushThroughputController = FlushThroughputControllerFactory.create(this, conf);</span>
<span class="source-line-no">2175</span><span id="line-2175">    this.procedureResultReporter = new RemoteProcedureResultReporter(this);</span>
<span class="source-line-no">2176</span><span id="line-2176"></span>
<span class="source-line-no">2177</span><span id="line-2177">    // Create the CompactedFileDischarger chore executorService. This chore helps to</span>
<span class="source-line-no">2178</span><span id="line-2178">    // remove the compacted files that will no longer be used in reads.</span>
<span class="source-line-no">2179</span><span id="line-2179">    // Default is 2 mins. The default value for TTLCleaner is 5 mins so we set this to</span>
<span class="source-line-no">2180</span><span id="line-2180">    // 2 mins so that compacted files can be archived before the TTLCleaner runs</span>
<span class="source-line-no">2181</span><span id="line-2181">    int cleanerInterval = conf.getInt("hbase.hfile.compaction.discharger.interval", 2 * 60 * 1000);</span>
<span class="source-line-no">2182</span><span id="line-2182">    this.compactedFileDischarger = new CompactedHFilesDischarger(cleanerInterval, this, this);</span>
<span class="source-line-no">2183</span><span id="line-2183">    choreService.scheduleChore(compactedFileDischarger);</span>
<span class="source-line-no">2184</span><span id="line-2184"></span>
<span class="source-line-no">2185</span><span id="line-2185">    // Start executor services</span>
<span class="source-line-no">2186</span><span id="line-2186">    final int openRegionThreads = conf.getInt("hbase.regionserver.executor.openregion.threads", 3);</span>
<span class="source-line-no">2187</span><span id="line-2187">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2188</span><span id="line-2188">      .setExecutorType(ExecutorType.RS_OPEN_REGION).setCorePoolSize(openRegionThreads));</span>
<span class="source-line-no">2189</span><span id="line-2189">    final int openMetaThreads = conf.getInt("hbase.regionserver.executor.openmeta.threads", 1);</span>
<span class="source-line-no">2190</span><span id="line-2190">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2191</span><span id="line-2191">      .setExecutorType(ExecutorType.RS_OPEN_META).setCorePoolSize(openMetaThreads));</span>
<span class="source-line-no">2192</span><span id="line-2192">    final int openPriorityRegionThreads =</span>
<span class="source-line-no">2193</span><span id="line-2193">      conf.getInt("hbase.regionserver.executor.openpriorityregion.threads", 3);</span>
<span class="source-line-no">2194</span><span id="line-2194">    executorService.startExecutorService(</span>
<span class="source-line-no">2195</span><span id="line-2195">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_OPEN_PRIORITY_REGION)</span>
<span class="source-line-no">2196</span><span id="line-2196">        .setCorePoolSize(openPriorityRegionThreads));</span>
<span class="source-line-no">2197</span><span id="line-2197">    final int closeRegionThreads =</span>
<span class="source-line-no">2198</span><span id="line-2198">      conf.getInt("hbase.regionserver.executor.closeregion.threads", 3);</span>
<span class="source-line-no">2199</span><span id="line-2199">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2200</span><span id="line-2200">      .setExecutorType(ExecutorType.RS_CLOSE_REGION).setCorePoolSize(closeRegionThreads));</span>
<span class="source-line-no">2201</span><span id="line-2201">    final int closeMetaThreads = conf.getInt("hbase.regionserver.executor.closemeta.threads", 1);</span>
<span class="source-line-no">2202</span><span id="line-2202">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2203</span><span id="line-2203">      .setExecutorType(ExecutorType.RS_CLOSE_META).setCorePoolSize(closeMetaThreads));</span>
<span class="source-line-no">2204</span><span id="line-2204">    if (conf.getBoolean(StoreScanner.STORESCANNER_PARALLEL_SEEK_ENABLE, false)) {</span>
<span class="source-line-no">2205</span><span id="line-2205">      final int storeScannerParallelSeekThreads =</span>
<span class="source-line-no">2206</span><span id="line-2206">        conf.getInt("hbase.storescanner.parallel.seek.threads", 10);</span>
<span class="source-line-no">2207</span><span id="line-2207">      executorService.startExecutorService(</span>
<span class="source-line-no">2208</span><span id="line-2208">        executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_PARALLEL_SEEK)</span>
<span class="source-line-no">2209</span><span id="line-2209">          .setCorePoolSize(storeScannerParallelSeekThreads).setAllowCoreThreadTimeout(true));</span>
<span class="source-line-no">2210</span><span id="line-2210">    }</span>
<span class="source-line-no">2211</span><span id="line-2211">    final int logReplayOpsThreads =</span>
<span class="source-line-no">2212</span><span id="line-2212">      conf.getInt(HBASE_SPLIT_WAL_MAX_SPLITTER, DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER);</span>
<span class="source-line-no">2213</span><span id="line-2213">    executorService.startExecutorService(</span>
<span class="source-line-no">2214</span><span id="line-2214">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_LOG_REPLAY_OPS)</span>
<span class="source-line-no">2215</span><span id="line-2215">        .setCorePoolSize(logReplayOpsThreads).setAllowCoreThreadTimeout(true));</span>
<span class="source-line-no">2216</span><span id="line-2216">    // Start the threads for compacted files discharger</span>
<span class="source-line-no">2217</span><span id="line-2217">    final int compactionDischargerThreads =</span>
<span class="source-line-no">2218</span><span id="line-2218">      conf.getInt(CompactionConfiguration.HBASE_HFILE_COMPACTION_DISCHARGER_THREAD_COUNT, 10);</span>
<span class="source-line-no">2219</span><span id="line-2219">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2220</span><span id="line-2220">      .setExecutorType(ExecutorType.RS_COMPACTED_FILES_DISCHARGER)</span>
<span class="source-line-no">2221</span><span id="line-2221">      .setCorePoolSize(compactionDischargerThreads));</span>
<span class="source-line-no">2222</span><span id="line-2222">    if (ServerRegionReplicaUtil.isRegionReplicaWaitForPrimaryFlushEnabled(conf)) {</span>
<span class="source-line-no">2223</span><span id="line-2223">      final int regionReplicaFlushThreads =</span>
<span class="source-line-no">2224</span><span id="line-2224">        conf.getInt("hbase.regionserver.region.replica.flusher.threads",</span>
<span class="source-line-no">2225</span><span id="line-2225">          conf.getInt("hbase.regionserver.executor.openregion.threads", 3));</span>
<span class="source-line-no">2226</span><span id="line-2226">      executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2227</span><span id="line-2227">        .setExecutorType(ExecutorType.RS_REGION_REPLICA_FLUSH_OPS)</span>
<span class="source-line-no">2228</span><span id="line-2228">        .setCorePoolSize(regionReplicaFlushThreads));</span>
<span class="source-line-no">2229</span><span id="line-2229">    }</span>
<span class="source-line-no">2230</span><span id="line-2230">    final int refreshPeerThreads =</span>
<span class="source-line-no">2231</span><span id="line-2231">      conf.getInt("hbase.regionserver.executor.refresh.peer.threads", 2);</span>
<span class="source-line-no">2232</span><span id="line-2232">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2233</span><span id="line-2233">      .setExecutorType(ExecutorType.RS_REFRESH_PEER).setCorePoolSize(refreshPeerThreads));</span>
<span class="source-line-no">2234</span><span id="line-2234"></span>
<span class="source-line-no">2235</span><span id="line-2235">    final int switchRpcThrottleThreads =</span>
<span class="source-line-no">2236</span><span id="line-2236">      conf.getInt("hbase.regionserver.executor.switch.rpc.throttle.threads", 1);</span>
<span class="source-line-no">2237</span><span id="line-2237">    executorService.startExecutorService(</span>
<span class="source-line-no">2238</span><span id="line-2238">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_SWITCH_RPC_THROTTLE)</span>
<span class="source-line-no">2239</span><span id="line-2239">        .setCorePoolSize(switchRpcThrottleThreads));</span>
<span class="source-line-no">2240</span><span id="line-2240">    final int claimReplicationQueueThreads =</span>
<span class="source-line-no">2241</span><span id="line-2241">      conf.getInt("hbase.regionserver.executor.claim.replication.queue.threads", 1);</span>
<span class="source-line-no">2242</span><span id="line-2242">    executorService.startExecutorService(</span>
<span class="source-line-no">2243</span><span id="line-2243">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_CLAIM_REPLICATION_QUEUE)</span>
<span class="source-line-no">2244</span><span id="line-2244">        .setCorePoolSize(claimReplicationQueueThreads));</span>
<span class="source-line-no">2245</span><span id="line-2245">    final int rsSnapshotOperationThreads =</span>
<span class="source-line-no">2246</span><span id="line-2246">      conf.getInt("hbase.regionserver.executor.snapshot.operations.threads", 3);</span>
<span class="source-line-no">2247</span><span id="line-2247">    executorService.startExecutorService(</span>
<span class="source-line-no">2248</span><span id="line-2248">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_SNAPSHOT_OPERATIONS)</span>
<span class="source-line-no">2249</span><span id="line-2249">        .setCorePoolSize(rsSnapshotOperationThreads));</span>
<span class="source-line-no">2250</span><span id="line-2250">    final int rsFlushOperationThreads =</span>
<span class="source-line-no">2251</span><span id="line-2251">      conf.getInt("hbase.regionserver.executor.flush.operations.threads", 3);</span>
<span class="source-line-no">2252</span><span id="line-2252">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">2253</span><span id="line-2253">      .setExecutorType(ExecutorType.RS_FLUSH_OPERATIONS).setCorePoolSize(rsFlushOperationThreads));</span>
<span class="source-line-no">2254</span><span id="line-2254"></span>
<span class="source-line-no">2255</span><span id="line-2255">    Threads.setDaemonThreadRunning(this.walRoller, getName() + ".logRoller",</span>
<span class="source-line-no">2256</span><span id="line-2256">      uncaughtExceptionHandler);</span>
<span class="source-line-no">2257</span><span id="line-2257">    if (this.cacheFlusher != null) {</span>
<span class="source-line-no">2258</span><span id="line-2258">      this.cacheFlusher.start(uncaughtExceptionHandler);</span>
<span class="source-line-no">2259</span><span id="line-2259">    }</span>
<span class="source-line-no">2260</span><span id="line-2260">    Threads.setDaemonThreadRunning(this.procedureResultReporter,</span>
<span class="source-line-no">2261</span><span id="line-2261">      getName() + ".procedureResultReporter", uncaughtExceptionHandler);</span>
<span class="source-line-no">2262</span><span id="line-2262"></span>
<span class="source-line-no">2263</span><span id="line-2263">    if (this.compactionChecker != null) {</span>
<span class="source-line-no">2264</span><span id="line-2264">      choreService.scheduleChore(compactionChecker);</span>
<span class="source-line-no">2265</span><span id="line-2265">    }</span>
<span class="source-line-no">2266</span><span id="line-2266">    if (this.periodicFlusher != null) {</span>
<span class="source-line-no">2267</span><span id="line-2267">      choreService.scheduleChore(periodicFlusher);</span>
<span class="source-line-no">2268</span><span id="line-2268">    }</span>
<span class="source-line-no">2269</span><span id="line-2269">    if (this.healthCheckChore != null) {</span>
<span class="source-line-no">2270</span><span id="line-2270">      choreService.scheduleChore(healthCheckChore);</span>
<span class="source-line-no">2271</span><span id="line-2271">    }</span>
<span class="source-line-no">2272</span><span id="line-2272">    if (this.nonceManagerChore != null) {</span>
<span class="source-line-no">2273</span><span id="line-2273">      choreService.scheduleChore(nonceManagerChore);</span>
<span class="source-line-no">2274</span><span id="line-2274">    }</span>
<span class="source-line-no">2275</span><span id="line-2275">    if (this.storefileRefresher != null) {</span>
<span class="source-line-no">2276</span><span id="line-2276">      choreService.scheduleChore(storefileRefresher);</span>
<span class="source-line-no">2277</span><span id="line-2277">    }</span>
<span class="source-line-no">2278</span><span id="line-2278">    if (this.fsUtilizationChore != null) {</span>
<span class="source-line-no">2279</span><span id="line-2279">      choreService.scheduleChore(fsUtilizationChore);</span>
<span class="source-line-no">2280</span><span id="line-2280">    }</span>
<span class="source-line-no">2281</span><span id="line-2281">    if (this.namedQueueServiceChore != null) {</span>
<span class="source-line-no">2282</span><span id="line-2282">      choreService.scheduleChore(namedQueueServiceChore);</span>
<span class="source-line-no">2283</span><span id="line-2283">    }</span>
<span class="source-line-no">2284</span><span id="line-2284">    if (this.brokenStoreFileCleaner != null) {</span>
<span class="source-line-no">2285</span><span id="line-2285">      choreService.scheduleChore(brokenStoreFileCleaner);</span>
<span class="source-line-no">2286</span><span id="line-2286">    }</span>
<span class="source-line-no">2287</span><span id="line-2287">    if (this.rsMobFileCleanerChore != null) {</span>
<span class="source-line-no">2288</span><span id="line-2288">      choreService.scheduleChore(rsMobFileCleanerChore);</span>
<span class="source-line-no">2289</span><span id="line-2289">    }</span>
<span class="source-line-no">2290</span><span id="line-2290">    if (replicationMarkerChore != null) {</span>
<span class="source-line-no">2291</span><span id="line-2291">      LOG.info("Starting replication marker chore");</span>
<span class="source-line-no">2292</span><span id="line-2292">      choreService.scheduleChore(replicationMarkerChore);</span>
<span class="source-line-no">2293</span><span id="line-2293">    }</span>
<span class="source-line-no">2294</span><span id="line-2294"></span>
<span class="source-line-no">2295</span><span id="line-2295">    // Leases is not a Thread. Internally it runs a daemon thread. If it gets</span>
<span class="source-line-no">2296</span><span id="line-2296">    // an unhandled exception, it will just exit.</span>
<span class="source-line-no">2297</span><span id="line-2297">    Threads.setDaemonThreadRunning(this.leaseManager, getName() + ".leaseChecker",</span>
<span class="source-line-no">2298</span><span id="line-2298">      uncaughtExceptionHandler);</span>
<span class="source-line-no">2299</span><span id="line-2299"></span>
<span class="source-line-no">2300</span><span id="line-2300">    // Create the log splitting worker and start it</span>
<span class="source-line-no">2301</span><span id="line-2301">    // set a smaller retries to fast fail otherwise splitlogworker could be blocked for</span>
<span class="source-line-no">2302</span><span id="line-2302">    // quite a while inside Connection layer. The worker won't be available for other</span>
<span class="source-line-no">2303</span><span id="line-2303">    // tasks even after current task is preempted after a split task times out.</span>
<span class="source-line-no">2304</span><span id="line-2304">    Configuration sinkConf = HBaseConfiguration.create(conf);</span>
<span class="source-line-no">2305</span><span id="line-2305">    sinkConf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,</span>
<span class="source-line-no">2306</span><span id="line-2306">      conf.getInt("hbase.log.replay.retries.number", 8)); // 8 retries take about 23 seconds</span>
<span class="source-line-no">2307</span><span id="line-2307">    sinkConf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,</span>
<span class="source-line-no">2308</span><span id="line-2308">      conf.getInt("hbase.log.replay.rpc.timeout", 30000)); // default 30 seconds</span>
<span class="source-line-no">2309</span><span id="line-2309">    sinkConf.setInt(HConstants.HBASE_CLIENT_SERVERSIDE_RETRIES_MULTIPLIER, 1);</span>
<span class="source-line-no">2310</span><span id="line-2310">    if (</span>
<span class="source-line-no">2311</span><span id="line-2311">      this.csm != null</span>
<span class="source-line-no">2312</span><span id="line-2312">        &amp;&amp; conf.getBoolean(HBASE_SPLIT_WAL_COORDINATED_BY_ZK, DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK)</span>
<span class="source-line-no">2313</span><span id="line-2313">    ) {</span>
<span class="source-line-no">2314</span><span id="line-2314">      // SplitLogWorker needs csm. If none, don't start this.</span>
<span class="source-line-no">2315</span><span id="line-2315">      this.splitLogWorker = new SplitLogWorker(sinkConf, this, this, walFactory);</span>
<span class="source-line-no">2316</span><span id="line-2316">      splitLogWorker.start();</span>
<span class="source-line-no">2317</span><span id="line-2317">      LOG.debug("SplitLogWorker started");</span>
<span class="source-line-no">2318</span><span id="line-2318">    }</span>
<span class="source-line-no">2319</span><span id="line-2319"></span>
<span class="source-line-no">2320</span><span id="line-2320">    // Memstore services.</span>
<span class="source-line-no">2321</span><span id="line-2321">    startHeapMemoryManager();</span>
<span class="source-line-no">2322</span><span id="line-2322">    // Call it after starting HeapMemoryManager.</span>
<span class="source-line-no">2323</span><span id="line-2323">    initializeMemStoreChunkCreator();</span>
<span class="source-line-no">2324</span><span id="line-2324">  }</span>
<span class="source-line-no">2325</span><span id="line-2325"></span>
<span class="source-line-no">2326</span><span id="line-2326">  private void initializeThreads() {</span>
<span class="source-line-no">2327</span><span id="line-2327">    // Cache flushing thread.</span>
<span class="source-line-no">2328</span><span id="line-2328">    this.cacheFlusher = new MemStoreFlusher(conf, this);</span>
<span class="source-line-no">2329</span><span id="line-2329"></span>
<span class="source-line-no">2330</span><span id="line-2330">    // Compaction thread</span>
<span class="source-line-no">2331</span><span id="line-2331">    this.compactSplitThread = new CompactSplit(this);</span>
<span class="source-line-no">2332</span><span id="line-2332"></span>
<span class="source-line-no">2333</span><span id="line-2333">    // Prefetch Notifier</span>
<span class="source-line-no">2334</span><span id="line-2334">    this.prefetchExecutorNotifier = new PrefetchExecutorNotifier(conf);</span>
<span class="source-line-no">2335</span><span id="line-2335"></span>
<span class="source-line-no">2336</span><span id="line-2336">    // Background thread to check for compactions; needed if region has not gotten updates</span>
<span class="source-line-no">2337</span><span id="line-2337">    // in a while. It will take care of not checking too frequently on store-by-store basis.</span>
<span class="source-line-no">2338</span><span id="line-2338">    this.compactionChecker = new CompactionChecker(this, this.compactionCheckFrequency, this);</span>
<span class="source-line-no">2339</span><span id="line-2339">    this.periodicFlusher = new PeriodicMemStoreFlusher(this.flushCheckFrequency, this);</span>
<span class="source-line-no">2340</span><span id="line-2340">    this.leaseManager = new LeaseManager(this.threadWakeFrequency);</span>
<span class="source-line-no">2341</span><span id="line-2341"></span>
<span class="source-line-no">2342</span><span id="line-2342">    final boolean isSlowLogTableEnabled = conf.getBoolean(HConstants.SLOW_LOG_SYS_TABLE_ENABLED_KEY,</span>
<span class="source-line-no">2343</span><span id="line-2343">      HConstants.DEFAULT_SLOW_LOG_SYS_TABLE_ENABLED_KEY);</span>
<span class="source-line-no">2344</span><span id="line-2344">    final boolean walEventTrackerEnabled =</span>
<span class="source-line-no">2345</span><span id="line-2345">      conf.getBoolean(WAL_EVENT_TRACKER_ENABLED_KEY, WAL_EVENT_TRACKER_ENABLED_DEFAULT);</span>
<span class="source-line-no">2346</span><span id="line-2346"></span>
<span class="source-line-no">2347</span><span id="line-2347">    if (isSlowLogTableEnabled || walEventTrackerEnabled) {</span>
<span class="source-line-no">2348</span><span id="line-2348">      // default chore duration: 10 min</span>
<span class="source-line-no">2349</span><span id="line-2349">      // After &lt;version number&gt;, we will remove hbase.slowlog.systable.chore.duration conf property</span>
<span class="source-line-no">2350</span><span id="line-2350">      final int slowLogChoreDuration = conf.getInt(HConstants.SLOW_LOG_SYS_TABLE_CHORE_DURATION_KEY,</span>
<span class="source-line-no">2351</span><span id="line-2351">        DEFAULT_SLOW_LOG_SYS_TABLE_CHORE_DURATION);</span>
<span class="source-line-no">2352</span><span id="line-2352"></span>
<span class="source-line-no">2353</span><span id="line-2353">      final int namedQueueChoreDuration =</span>
<span class="source-line-no">2354</span><span id="line-2354">        conf.getInt(NAMED_QUEUE_CHORE_DURATION_KEY, NAMED_QUEUE_CHORE_DURATION_DEFAULT);</span>
<span class="source-line-no">2355</span><span id="line-2355">      // Considering min of slowLogChoreDuration and namedQueueChoreDuration</span>
<span class="source-line-no">2356</span><span id="line-2356">      int choreDuration = Math.min(slowLogChoreDuration, namedQueueChoreDuration);</span>
<span class="source-line-no">2357</span><span id="line-2357"></span>
<span class="source-line-no">2358</span><span id="line-2358">      namedQueueServiceChore = new NamedQueueServiceChore(this, choreDuration,</span>
<span class="source-line-no">2359</span><span id="line-2359">        this.namedQueueRecorder, this.getConnection());</span>
<span class="source-line-no">2360</span><span id="line-2360">    }</span>
<span class="source-line-no">2361</span><span id="line-2361"></span>
<span class="source-line-no">2362</span><span id="line-2362">    if (this.nonceManager != null) {</span>
<span class="source-line-no">2363</span><span id="line-2363">      // Create the scheduled chore that cleans up nonces.</span>
<span class="source-line-no">2364</span><span id="line-2364">      nonceManagerChore = this.nonceManager.createCleanupScheduledChore(this);</span>
<span class="source-line-no">2365</span><span id="line-2365">    }</span>
<span class="source-line-no">2366</span><span id="line-2366"></span>
<span class="source-line-no">2367</span><span id="line-2367">    // Setup the Quota Manager</span>
<span class="source-line-no">2368</span><span id="line-2368">    rsQuotaManager = new RegionServerRpcQuotaManager(this);</span>
<span class="source-line-no">2369</span><span id="line-2369">    rsSpaceQuotaManager = new RegionServerSpaceQuotaManager(this);</span>
<span class="source-line-no">2370</span><span id="line-2370"></span>
<span class="source-line-no">2371</span><span id="line-2371">    if (QuotaUtil.isQuotaEnabled(conf)) {</span>
<span class="source-line-no">2372</span><span id="line-2372">      this.fsUtilizationChore = new FileSystemUtilizationChore(this);</span>
<span class="source-line-no">2373</span><span id="line-2373">    }</span>
<span class="source-line-no">2374</span><span id="line-2374"></span>
<span class="source-line-no">2375</span><span id="line-2375">    boolean onlyMetaRefresh = false;</span>
<span class="source-line-no">2376</span><span id="line-2376">    int storefileRefreshPeriod =</span>
<span class="source-line-no">2377</span><span id="line-2377">      conf.getInt(StorefileRefresherChore.REGIONSERVER_STOREFILE_REFRESH_PERIOD,</span>
<span class="source-line-no">2378</span><span id="line-2378">        StorefileRefresherChore.DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD);</span>
<span class="source-line-no">2379</span><span id="line-2379">    if (storefileRefreshPeriod == 0) {</span>
<span class="source-line-no">2380</span><span id="line-2380">      storefileRefreshPeriod =</span>
<span class="source-line-no">2381</span><span id="line-2381">        conf.getInt(StorefileRefresherChore.REGIONSERVER_META_STOREFILE_REFRESH_PERIOD,</span>
<span class="source-line-no">2382</span><span id="line-2382">          StorefileRefresherChore.DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD);</span>
<span class="source-line-no">2383</span><span id="line-2383">      onlyMetaRefresh = true;</span>
<span class="source-line-no">2384</span><span id="line-2384">    }</span>
<span class="source-line-no">2385</span><span id="line-2385">    if (storefileRefreshPeriod &gt; 0) {</span>
<span class="source-line-no">2386</span><span id="line-2386">      this.storefileRefresher =</span>
<span class="source-line-no">2387</span><span id="line-2387">        new StorefileRefresherChore(storefileRefreshPeriod, onlyMetaRefresh, this, this);</span>
<span class="source-line-no">2388</span><span id="line-2388">    }</span>
<span class="source-line-no">2389</span><span id="line-2389"></span>
<span class="source-line-no">2390</span><span id="line-2390">    int brokenStoreFileCleanerPeriod =</span>
<span class="source-line-no">2391</span><span id="line-2391">      conf.getInt(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_PERIOD,</span>
<span class="source-line-no">2392</span><span id="line-2392">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_PERIOD);</span>
<span class="source-line-no">2393</span><span id="line-2393">    int brokenStoreFileCleanerDelay =</span>
<span class="source-line-no">2394</span><span id="line-2394">      conf.getInt(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_DELAY,</span>
<span class="source-line-no">2395</span><span id="line-2395">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_DELAY);</span>
<span class="source-line-no">2396</span><span id="line-2396">    double brokenStoreFileCleanerDelayJitter =</span>
<span class="source-line-no">2397</span><span id="line-2397">      conf.getDouble(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_DELAY_JITTER,</span>
<span class="source-line-no">2398</span><span id="line-2398">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_DELAY_JITTER);</span>
<span class="source-line-no">2399</span><span id="line-2399">    double jitterRate =</span>
<span class="source-line-no">2400</span><span id="line-2400">      (ThreadLocalRandom.current().nextDouble() - 0.5D) * brokenStoreFileCleanerDelayJitter;</span>
<span class="source-line-no">2401</span><span id="line-2401">    long jitterValue = Math.round(brokenStoreFileCleanerDelay * jitterRate);</span>
<span class="source-line-no">2402</span><span id="line-2402">    this.brokenStoreFileCleaner =</span>
<span class="source-line-no">2403</span><span id="line-2403">      new BrokenStoreFileCleaner((int) (brokenStoreFileCleanerDelay + jitterValue),</span>
<span class="source-line-no">2404</span><span id="line-2404">        brokenStoreFileCleanerPeriod, this, conf, this);</span>
<span class="source-line-no">2405</span><span id="line-2405"></span>
<span class="source-line-no">2406</span><span id="line-2406">    this.rsMobFileCleanerChore = new RSMobFileCleanerChore(this);</span>
<span class="source-line-no">2407</span><span id="line-2407"></span>
<span class="source-line-no">2408</span><span id="line-2408">    registerConfigurationObservers();</span>
<span class="source-line-no">2409</span><span id="line-2409">    initializeReplicationMarkerChore();</span>
<span class="source-line-no">2410</span><span id="line-2410">  }</span>
<span class="source-line-no">2411</span><span id="line-2411"></span>
<span class="source-line-no">2412</span><span id="line-2412">  private void registerConfigurationObservers() {</span>
<span class="source-line-no">2413</span><span id="line-2413">    // Register Replication if possible, as now we support recreating replication peer storage, for</span>
<span class="source-line-no">2414</span><span id="line-2414">    // migrating across different replication peer storages online</span>
<span class="source-line-no">2415</span><span id="line-2415">    if (replicationSourceHandler instanceof ConfigurationObserver) {</span>
<span class="source-line-no">2416</span><span id="line-2416">      configurationManager.registerObserver((ConfigurationObserver) replicationSourceHandler);</span>
<span class="source-line-no">2417</span><span id="line-2417">    }</span>
<span class="source-line-no">2418</span><span id="line-2418">    if (</span>
<span class="source-line-no">2419</span><span id="line-2419">      replicationSourceHandler != replicationSinkHandler</span>
<span class="source-line-no">2420</span><span id="line-2420">        &amp;&amp; replicationSinkHandler instanceof ConfigurationObserver</span>
<span class="source-line-no">2421</span><span id="line-2421">    ) {</span>
<span class="source-line-no">2422</span><span id="line-2422">      configurationManager.registerObserver((ConfigurationObserver) replicationSinkHandler);</span>
<span class="source-line-no">2423</span><span id="line-2423">    }</span>
<span class="source-line-no">2424</span><span id="line-2424">    // Registering the compactSplitThread object with the ConfigurationManager.</span>
<span class="source-line-no">2425</span><span id="line-2425">    configurationManager.registerObserver(this.compactSplitThread);</span>
<span class="source-line-no">2426</span><span id="line-2426">    configurationManager.registerObserver(this.cacheFlusher);</span>
<span class="source-line-no">2427</span><span id="line-2427">    configurationManager.registerObserver(this.rpcServices);</span>
<span class="source-line-no">2428</span><span id="line-2428">    configurationManager.registerObserver(this.prefetchExecutorNotifier);</span>
<span class="source-line-no">2429</span><span id="line-2429">    configurationManager.registerObserver(this);</span>
<span class="source-line-no">2430</span><span id="line-2430">  }</span>
<span class="source-line-no">2431</span><span id="line-2431"></span>
<span class="source-line-no">2432</span><span id="line-2432">  /**</span>
<span class="source-line-no">2433</span><span id="line-2433">   * Puts up the webui.</span>
<span class="source-line-no">2434</span><span id="line-2434">   */</span>
<span class="source-line-no">2435</span><span id="line-2435">  private void putUpWebUI() throws IOException {</span>
<span class="source-line-no">2436</span><span id="line-2436">    int port =</span>
<span class="source-line-no">2437</span><span id="line-2437">      this.conf.getInt(HConstants.REGIONSERVER_INFO_PORT, HConstants.DEFAULT_REGIONSERVER_INFOPORT);</span>
<span class="source-line-no">2438</span><span id="line-2438">    String addr = this.conf.get("hbase.regionserver.info.bindAddress", "0.0.0.0");</span>
<span class="source-line-no">2439</span><span id="line-2439"></span>
<span class="source-line-no">2440</span><span id="line-2440">    if (this instanceof HMaster) {</span>
<span class="source-line-no">2441</span><span id="line-2441">      port = conf.getInt(HConstants.MASTER_INFO_PORT, HConstants.DEFAULT_MASTER_INFOPORT);</span>
<span class="source-line-no">2442</span><span id="line-2442">      addr = this.conf.get("hbase.master.info.bindAddress", "0.0.0.0");</span>
<span class="source-line-no">2443</span><span id="line-2443">    }</span>
<span class="source-line-no">2444</span><span id="line-2444">    // -1 is for disabling info server</span>
<span class="source-line-no">2445</span><span id="line-2445">    if (port &lt; 0) {</span>
<span class="source-line-no">2446</span><span id="line-2446">      return;</span>
<span class="source-line-no">2447</span><span id="line-2447">    }</span>
<span class="source-line-no">2448</span><span id="line-2448"></span>
<span class="source-line-no">2449</span><span id="line-2449">    if (!Addressing.isLocalAddress(InetAddress.getByName(addr))) {</span>
<span class="source-line-no">2450</span><span id="line-2450">      String msg = "Failed to start http info server. Address " + addr</span>
<span class="source-line-no">2451</span><span id="line-2451">        + " does not belong to this host. Correct configuration parameter: "</span>
<span class="source-line-no">2452</span><span id="line-2452">        + "hbase.regionserver.info.bindAddress";</span>
<span class="source-line-no">2453</span><span id="line-2453">      LOG.error(msg);</span>
<span class="source-line-no">2454</span><span id="line-2454">      throw new IOException(msg);</span>
<span class="source-line-no">2455</span><span id="line-2455">    }</span>
<span class="source-line-no">2456</span><span id="line-2456">    // check if auto port bind enabled</span>
<span class="source-line-no">2457</span><span id="line-2457">    boolean auto = this.conf.getBoolean(HConstants.REGIONSERVER_INFO_PORT_AUTO, false);</span>
<span class="source-line-no">2458</span><span id="line-2458">    while (true) {</span>
<span class="source-line-no">2459</span><span id="line-2459">      try {</span>
<span class="source-line-no">2460</span><span id="line-2460">        this.infoServer = new InfoServer(getProcessName(), addr, port, false, this.conf);</span>
<span class="source-line-no">2461</span><span id="line-2461">        infoServer.addPrivilegedServlet("dump", "/dump", getDumpServlet());</span>
<span class="source-line-no">2462</span><span id="line-2462">        configureInfoServer();</span>
<span class="source-line-no">2463</span><span id="line-2463">        this.infoServer.start();</span>
<span class="source-line-no">2464</span><span id="line-2464">        break;</span>
<span class="source-line-no">2465</span><span id="line-2465">      } catch (BindException e) {</span>
<span class="source-line-no">2466</span><span id="line-2466">        if (!auto) {</span>
<span class="source-line-no">2467</span><span id="line-2467">          // auto bind disabled throw BindException</span>
<span class="source-line-no">2468</span><span id="line-2468">          LOG.error("Failed binding http info server to port: " + port);</span>
<span class="source-line-no">2469</span><span id="line-2469">          throw e;</span>
<span class="source-line-no">2470</span><span id="line-2470">        }</span>
<span class="source-line-no">2471</span><span id="line-2471">        // auto bind enabled, try to use another port</span>
<span class="source-line-no">2472</span><span id="line-2472">        LOG.info("Failed binding http info server to port: " + port);</span>
<span class="source-line-no">2473</span><span id="line-2473">        port++;</span>
<span class="source-line-no">2474</span><span id="line-2474">        LOG.info("Retry starting http info server with port: " + port);</span>
<span class="source-line-no">2475</span><span id="line-2475">      }</span>
<span class="source-line-no">2476</span><span id="line-2476">    }</span>
<span class="source-line-no">2477</span><span id="line-2477">    port = this.infoServer.getPort();</span>
<span class="source-line-no">2478</span><span id="line-2478">    conf.setInt(HConstants.REGIONSERVER_INFO_PORT, port);</span>
<span class="source-line-no">2479</span><span id="line-2479">    int masterInfoPort =</span>
<span class="source-line-no">2480</span><span id="line-2480">      conf.getInt(HConstants.MASTER_INFO_PORT, HConstants.DEFAULT_MASTER_INFOPORT);</span>
<span class="source-line-no">2481</span><span id="line-2481">    conf.setInt("hbase.master.info.port.orig", masterInfoPort);</span>
<span class="source-line-no">2482</span><span id="line-2482">    conf.setInt(HConstants.MASTER_INFO_PORT, port);</span>
<span class="source-line-no">2483</span><span id="line-2483">  }</span>
<span class="source-line-no">2484</span><span id="line-2484"></span>
<span class="source-line-no">2485</span><span id="line-2485">  /*</span>
<span class="source-line-no">2486</span><span id="line-2486">   * Verify that server is healthy</span>
<span class="source-line-no">2487</span><span id="line-2487">   */</span>
<span class="source-line-no">2488</span><span id="line-2488">  private boolean isHealthy() {</span>
<span class="source-line-no">2489</span><span id="line-2489">    if (!dataFsOk) {</span>
<span class="source-line-no">2490</span><span id="line-2490">      // File system problem</span>
<span class="source-line-no">2491</span><span id="line-2491">      return false;</span>
<span class="source-line-no">2492</span><span id="line-2492">    }</span>
<span class="source-line-no">2493</span><span id="line-2493">    // Verify that all threads are alive</span>
<span class="source-line-no">2494</span><span id="line-2494">    boolean healthy = (this.leaseManager == null || this.leaseManager.isAlive())</span>
<span class="source-line-no">2495</span><span id="line-2495">      &amp;&amp; (this.cacheFlusher == null || this.cacheFlusher.isAlive())</span>
<span class="source-line-no">2496</span><span id="line-2496">      &amp;&amp; (this.walRoller == null || this.walRoller.isAlive())</span>
<span class="source-line-no">2497</span><span id="line-2497">      &amp;&amp; (this.compactionChecker == null || this.compactionChecker.isScheduled())</span>
<span class="source-line-no">2498</span><span id="line-2498">      &amp;&amp; (this.periodicFlusher == null || this.periodicFlusher.isScheduled());</span>
<span class="source-line-no">2499</span><span id="line-2499">    if (!healthy) {</span>
<span class="source-line-no">2500</span><span id="line-2500">      stop("One or more threads are no longer alive -- stop");</span>
<span class="source-line-no">2501</span><span id="line-2501">    }</span>
<span class="source-line-no">2502</span><span id="line-2502">    return healthy;</span>
<span class="source-line-no">2503</span><span id="line-2503">  }</span>
<span class="source-line-no">2504</span><span id="line-2504"></span>
<span class="source-line-no">2505</span><span id="line-2505">  @Override</span>
<span class="source-line-no">2506</span><span id="line-2506">  public List&lt;WAL&gt; getWALs() {</span>
<span class="source-line-no">2507</span><span id="line-2507">    return walFactory.getWALs();</span>
<span class="source-line-no">2508</span><span id="line-2508">  }</span>
<span class="source-line-no">2509</span><span id="line-2509"></span>
<span class="source-line-no">2510</span><span id="line-2510">  @Override</span>
<span class="source-line-no">2511</span><span id="line-2511">  public WAL getWAL(RegionInfo regionInfo) throws IOException {</span>
<span class="source-line-no">2512</span><span id="line-2512">    try {</span>
<span class="source-line-no">2513</span><span id="line-2513">      WAL wal = walFactory.getWAL(regionInfo);</span>
<span class="source-line-no">2514</span><span id="line-2514">      if (this.walRoller != null) {</span>
<span class="source-line-no">2515</span><span id="line-2515">        this.walRoller.addWAL(wal);</span>
<span class="source-line-no">2516</span><span id="line-2516">      }</span>
<span class="source-line-no">2517</span><span id="line-2517">      return wal;</span>
<span class="source-line-no">2518</span><span id="line-2518">    } catch (FailedCloseWALAfterInitializedErrorException ex) {</span>
<span class="source-line-no">2519</span><span id="line-2519">      // see HBASE-21751 for details</span>
<span class="source-line-no">2520</span><span id="line-2520">      abort("WAL can not clean up after init failed", ex);</span>
<span class="source-line-no">2521</span><span id="line-2521">      throw ex;</span>
<span class="source-line-no">2522</span><span id="line-2522">    }</span>
<span class="source-line-no">2523</span><span id="line-2523">  }</span>
<span class="source-line-no">2524</span><span id="line-2524"></span>
<span class="source-line-no">2525</span><span id="line-2525">  public LogRoller getWalRoller() {</span>
<span class="source-line-no">2526</span><span id="line-2526">    return walRoller;</span>
<span class="source-line-no">2527</span><span id="line-2527">  }</span>
<span class="source-line-no">2528</span><span id="line-2528"></span>
<span class="source-line-no">2529</span><span id="line-2529">  WALFactory getWalFactory() {</span>
<span class="source-line-no">2530</span><span id="line-2530">    return walFactory;</span>
<span class="source-line-no">2531</span><span id="line-2531">  }</span>
<span class="source-line-no">2532</span><span id="line-2532"></span>
<span class="source-line-no">2533</span><span id="line-2533">  @Override</span>
<span class="source-line-no">2534</span><span id="line-2534">  public Connection getConnection() {</span>
<span class="source-line-no">2535</span><span id="line-2535">    return getClusterConnection();</span>
<span class="source-line-no">2536</span><span id="line-2536">  }</span>
<span class="source-line-no">2537</span><span id="line-2537"></span>
<span class="source-line-no">2538</span><span id="line-2538">  @Override</span>
<span class="source-line-no">2539</span><span id="line-2539">  public ClusterConnection getClusterConnection() {</span>
<span class="source-line-no">2540</span><span id="line-2540">    return this.clusterConnection;</span>
<span class="source-line-no">2541</span><span id="line-2541">  }</span>
<span class="source-line-no">2542</span><span id="line-2542"></span>
<span class="source-line-no">2543</span><span id="line-2543">  @Override</span>
<span class="source-line-no">2544</span><span id="line-2544">  public void stop(final String msg) {</span>
<span class="source-line-no">2545</span><span id="line-2545">    stop(msg, false, RpcServer.getRequestUser().orElse(null));</span>
<span class="source-line-no">2546</span><span id="line-2546">  }</span>
<span class="source-line-no">2547</span><span id="line-2547"></span>
<span class="source-line-no">2548</span><span id="line-2548">  /**</span>
<span class="source-line-no">2549</span><span id="line-2549">   * Stops the regionserver.</span>
<span class="source-line-no">2550</span><span id="line-2550">   * @param msg   Status message</span>
<span class="source-line-no">2551</span><span id="line-2551">   * @param force True if this is a regionserver abort</span>
<span class="source-line-no">2552</span><span id="line-2552">   * @param user  The user executing the stop request, or null if no user is associated</span>
<span class="source-line-no">2553</span><span id="line-2553">   */</span>
<span class="source-line-no">2554</span><span id="line-2554">  public void stop(final String msg, final boolean force, final User user) {</span>
<span class="source-line-no">2555</span><span id="line-2555">    if (!this.stopped) {</span>
<span class="source-line-no">2556</span><span id="line-2556">      LOG.info("***** STOPPING region server '" + this + "' *****");</span>
<span class="source-line-no">2557</span><span id="line-2557">      if (this.rsHost != null) {</span>
<span class="source-line-no">2558</span><span id="line-2558">        // when forced via abort don't allow CPs to override</span>
<span class="source-line-no">2559</span><span id="line-2559">        try {</span>
<span class="source-line-no">2560</span><span id="line-2560">          this.rsHost.preStop(msg, user);</span>
<span class="source-line-no">2561</span><span id="line-2561">        } catch (IOException ioe) {</span>
<span class="source-line-no">2562</span><span id="line-2562">          if (!force) {</span>
<span class="source-line-no">2563</span><span id="line-2563">            LOG.warn("The region server did not stop", ioe);</span>
<span class="source-line-no">2564</span><span id="line-2564">            return;</span>
<span class="source-line-no">2565</span><span id="line-2565">          }</span>
<span class="source-line-no">2566</span><span id="line-2566">          LOG.warn("Skipping coprocessor exception on preStop() due to forced shutdown", ioe);</span>
<span class="source-line-no">2567</span><span id="line-2567">        }</span>
<span class="source-line-no">2568</span><span id="line-2568">      }</span>
<span class="source-line-no">2569</span><span id="line-2569">      this.stopped = true;</span>
<span class="source-line-no">2570</span><span id="line-2570">      LOG.info("STOPPED: " + msg);</span>
<span class="source-line-no">2571</span><span id="line-2571">      // Wakes run() if it is sleeping</span>
<span class="source-line-no">2572</span><span id="line-2572">      sleeper.skipSleepCycle();</span>
<span class="source-line-no">2573</span><span id="line-2573">    }</span>
<span class="source-line-no">2574</span><span id="line-2574">  }</span>
<span class="source-line-no">2575</span><span id="line-2575"></span>
<span class="source-line-no">2576</span><span id="line-2576">  public void waitForServerOnline() {</span>
<span class="source-line-no">2577</span><span id="line-2577">    while (!isStopped() &amp;&amp; !isOnline()) {</span>
<span class="source-line-no">2578</span><span id="line-2578">      synchronized (online) {</span>
<span class="source-line-no">2579</span><span id="line-2579">        try {</span>
<span class="source-line-no">2580</span><span id="line-2580">          online.wait(msgInterval);</span>
<span class="source-line-no">2581</span><span id="line-2581">        } catch (InterruptedException ie) {</span>
<span class="source-line-no">2582</span><span id="line-2582">          Thread.currentThread().interrupt();</span>
<span class="source-line-no">2583</span><span id="line-2583">          break;</span>
<span class="source-line-no">2584</span><span id="line-2584">        }</span>
<span class="source-line-no">2585</span><span id="line-2585">      }</span>
<span class="source-line-no">2586</span><span id="line-2586">    }</span>
<span class="source-line-no">2587</span><span id="line-2587">  }</span>
<span class="source-line-no">2588</span><span id="line-2588"></span>
<span class="source-line-no">2589</span><span id="line-2589">  @Override</span>
<span class="source-line-no">2590</span><span id="line-2590">  public void postOpenDeployTasks(final PostOpenDeployContext context) throws IOException {</span>
<span class="source-line-no">2591</span><span id="line-2591">    HRegion r = context.getRegion();</span>
<span class="source-line-no">2592</span><span id="line-2592">    long openProcId = context.getOpenProcId();</span>
<span class="source-line-no">2593</span><span id="line-2593">    long masterSystemTime = context.getMasterSystemTime();</span>
<span class="source-line-no">2594</span><span id="line-2594">    rpcServices.checkOpen();</span>
<span class="source-line-no">2595</span><span id="line-2595">    LOG.info("Post open deploy tasks for {}, pid={}, masterSystemTime={}",</span>
<span class="source-line-no">2596</span><span id="line-2596">      r.getRegionInfo().getRegionNameAsString(), openProcId, masterSystemTime);</span>
<span class="source-line-no">2597</span><span id="line-2597">    // Do checks to see if we need to compact (references or too many files)</span>
<span class="source-line-no">2598</span><span id="line-2598">    for (HStore s : r.stores.values()) {</span>
<span class="source-line-no">2599</span><span id="line-2599">      if (s.hasReferences() || s.needsCompaction()) {</span>
<span class="source-line-no">2600</span><span id="line-2600">        this.compactSplitThread.requestSystemCompaction(r, s, "Opening Region");</span>
<span class="source-line-no">2601</span><span id="line-2601">      }</span>
<span class="source-line-no">2602</span><span id="line-2602">    }</span>
<span class="source-line-no">2603</span><span id="line-2603">    long openSeqNum = r.getOpenSeqNum();</span>
<span class="source-line-no">2604</span><span id="line-2604">    if (openSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">2605</span><span id="line-2605">      // If we opened a region, we should have read some sequence number from it.</span>
<span class="source-line-no">2606</span><span id="line-2606">      LOG.error(</span>
<span class="source-line-no">2607</span><span id="line-2607">        "No sequence number found when opening " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2608</span><span id="line-2608">      openSeqNum = 0;</span>
<span class="source-line-no">2609</span><span id="line-2609">    }</span>
<span class="source-line-no">2610</span><span id="line-2610"></span>
<span class="source-line-no">2611</span><span id="line-2611">    // Notify master</span>
<span class="source-line-no">2612</span><span id="line-2612">    if (</span>
<span class="source-line-no">2613</span><span id="line-2613">      !reportRegionStateTransition(new RegionStateTransitionContext(TransitionCode.OPENED,</span>
<span class="source-line-no">2614</span><span id="line-2614">        openSeqNum, openProcId, masterSystemTime, r.getRegionInfo()))</span>
<span class="source-line-no">2615</span><span id="line-2615">    ) {</span>
<span class="source-line-no">2616</span><span id="line-2616">      throw new IOException(</span>
<span class="source-line-no">2617</span><span id="line-2617">        "Failed to report opened region to master: " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2618</span><span id="line-2618">    }</span>
<span class="source-line-no">2619</span><span id="line-2619"></span>
<span class="source-line-no">2620</span><span id="line-2620">    triggerFlushInPrimaryRegion(r);</span>
<span class="source-line-no">2621</span><span id="line-2621"></span>
<span class="source-line-no">2622</span><span id="line-2622">    LOG.debug("Finished post open deploy task for " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2623</span><span id="line-2623">  }</span>
<span class="source-line-no">2624</span><span id="line-2624"></span>
<span class="source-line-no">2625</span><span id="line-2625">  /**</span>
<span class="source-line-no">2626</span><span id="line-2626">   * Helper method for use in tests. Skip the region transition report when there's no master around</span>
<span class="source-line-no">2627</span><span id="line-2627">   * to receive it.</span>
<span class="source-line-no">2628</span><span id="line-2628">   */</span>
<span class="source-line-no">2629</span><span id="line-2629">  private boolean skipReportingTransition(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2630</span><span id="line-2630">    final TransitionCode code = context.getCode();</span>
<span class="source-line-no">2631</span><span id="line-2631">    final long openSeqNum = context.getOpenSeqNum();</span>
<span class="source-line-no">2632</span><span id="line-2632">    long masterSystemTime = context.getMasterSystemTime();</span>
<span class="source-line-no">2633</span><span id="line-2633">    final RegionInfo[] hris = context.getHris();</span>
<span class="source-line-no">2634</span><span id="line-2634"></span>
<span class="source-line-no">2635</span><span id="line-2635">    if (code == TransitionCode.OPENED) {</span>
<span class="source-line-no">2636</span><span id="line-2636">      Preconditions.checkArgument(hris != null &amp;&amp; hris.length == 1);</span>
<span class="source-line-no">2637</span><span id="line-2637">      if (hris[0].isMetaRegion()) {</span>
<span class="source-line-no">2638</span><span id="line-2638">        LOG.warn(</span>
<span class="source-line-no">2639</span><span id="line-2639">          "meta table location is stored in master local store, so we can not skip reporting");</span>
<span class="source-line-no">2640</span><span id="line-2640">        return false;</span>
<span class="source-line-no">2641</span><span id="line-2641">      } else {</span>
<span class="source-line-no">2642</span><span id="line-2642">        try {</span>
<span class="source-line-no">2643</span><span id="line-2643">          MetaTableAccessor.updateRegionLocation(clusterConnection, hris[0], serverName, openSeqNum,</span>
<span class="source-line-no">2644</span><span id="line-2644">            masterSystemTime);</span>
<span class="source-line-no">2645</span><span id="line-2645">        } catch (IOException e) {</span>
<span class="source-line-no">2646</span><span id="line-2646">          LOG.info("Failed to update meta", e);</span>
<span class="source-line-no">2647</span><span id="line-2647">          return false;</span>
<span class="source-line-no">2648</span><span id="line-2648">        }</span>
<span class="source-line-no">2649</span><span id="line-2649">      }</span>
<span class="source-line-no">2650</span><span id="line-2650">    }</span>
<span class="source-line-no">2651</span><span id="line-2651">    return true;</span>
<span class="source-line-no">2652</span><span id="line-2652">  }</span>
<span class="source-line-no">2653</span><span id="line-2653"></span>
<span class="source-line-no">2654</span><span id="line-2654">  private ReportRegionStateTransitionRequest</span>
<span class="source-line-no">2655</span><span id="line-2655">    createReportRegionStateTransitionRequest(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2656</span><span id="line-2656">    final TransitionCode code = context.getCode();</span>
<span class="source-line-no">2657</span><span id="line-2657">    final long openSeqNum = context.getOpenSeqNum();</span>
<span class="source-line-no">2658</span><span id="line-2658">    final RegionInfo[] hris = context.getHris();</span>
<span class="source-line-no">2659</span><span id="line-2659">    final long[] procIds = context.getProcIds();</span>
<span class="source-line-no">2660</span><span id="line-2660"></span>
<span class="source-line-no">2661</span><span id="line-2661">    ReportRegionStateTransitionRequest.Builder builder =</span>
<span class="source-line-no">2662</span><span id="line-2662">      ReportRegionStateTransitionRequest.newBuilder();</span>
<span class="source-line-no">2663</span><span id="line-2663">    builder.setServer(ProtobufUtil.toServerName(serverName));</span>
<span class="source-line-no">2664</span><span id="line-2664">    RegionStateTransition.Builder transition = builder.addTransitionBuilder();</span>
<span class="source-line-no">2665</span><span id="line-2665">    transition.setTransitionCode(code);</span>
<span class="source-line-no">2666</span><span id="line-2666">    if (code == TransitionCode.OPENED &amp;&amp; openSeqNum &gt;= 0) {</span>
<span class="source-line-no">2667</span><span id="line-2667">      transition.setOpenSeqNum(openSeqNum);</span>
<span class="source-line-no">2668</span><span id="line-2668">    }</span>
<span class="source-line-no">2669</span><span id="line-2669">    for (RegionInfo hri : hris) {</span>
<span class="source-line-no">2670</span><span id="line-2670">      transition.addRegionInfo(ProtobufUtil.toRegionInfo(hri));</span>
<span class="source-line-no">2671</span><span id="line-2671">    }</span>
<span class="source-line-no">2672</span><span id="line-2672">    for (long procId : procIds) {</span>
<span class="source-line-no">2673</span><span id="line-2673">      transition.addProcId(procId);</span>
<span class="source-line-no">2674</span><span id="line-2674">    }</span>
<span class="source-line-no">2675</span><span id="line-2675"></span>
<span class="source-line-no">2676</span><span id="line-2676">    return builder.build();</span>
<span class="source-line-no">2677</span><span id="line-2677">  }</span>
<span class="source-line-no">2678</span><span id="line-2678"></span>
<span class="source-line-no">2679</span><span id="line-2679">  @Override</span>
<span class="source-line-no">2680</span><span id="line-2680">  public boolean reportRegionStateTransition(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2681</span><span id="line-2681">    if (TEST_SKIP_REPORTING_TRANSITION) {</span>
<span class="source-line-no">2682</span><span id="line-2682">      return skipReportingTransition(context);</span>
<span class="source-line-no">2683</span><span id="line-2683">    }</span>
<span class="source-line-no">2684</span><span id="line-2684">    final ReportRegionStateTransitionRequest request =</span>
<span class="source-line-no">2685</span><span id="line-2685">      createReportRegionStateTransitionRequest(context);</span>
<span class="source-line-no">2686</span><span id="line-2686"></span>
<span class="source-line-no">2687</span><span id="line-2687">    int tries = 0;</span>
<span class="source-line-no">2688</span><span id="line-2688">    long pauseTime = this.retryPauseTime;</span>
<span class="source-line-no">2689</span><span id="line-2689">    // Keep looping till we get an error. We want to send reports even though server is going down.</span>
<span class="source-line-no">2690</span><span id="line-2690">    // Only go down if clusterConnection is null. It is set to null almost as last thing as the</span>
<span class="source-line-no">2691</span><span id="line-2691">    // HRegionServer does down.</span>
<span class="source-line-no">2692</span><span id="line-2692">    while (this.clusterConnection != null &amp;&amp; !this.clusterConnection.isClosed()) {</span>
<span class="source-line-no">2693</span><span id="line-2693">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2694</span><span id="line-2694">      try {</span>
<span class="source-line-no">2695</span><span id="line-2695">        if (rss == null) {</span>
<span class="source-line-no">2696</span><span id="line-2696">          createRegionServerStatusStub();</span>
<span class="source-line-no">2697</span><span id="line-2697">          continue;</span>
<span class="source-line-no">2698</span><span id="line-2698">        }</span>
<span class="source-line-no">2699</span><span id="line-2699">        ReportRegionStateTransitionResponse response =</span>
<span class="source-line-no">2700</span><span id="line-2700">          rss.reportRegionStateTransition(null, request);</span>
<span class="source-line-no">2701</span><span id="line-2701">        if (response.hasErrorMessage()) {</span>
<span class="source-line-no">2702</span><span id="line-2702">          LOG.info("TRANSITION FAILED " + request + ": " + response.getErrorMessage());</span>
<span class="source-line-no">2703</span><span id="line-2703">          break;</span>
<span class="source-line-no">2704</span><span id="line-2704">        }</span>
<span class="source-line-no">2705</span><span id="line-2705">        // Log if we had to retry else don't log unless TRACE. We want to</span>
<span class="source-line-no">2706</span><span id="line-2706">        // know if were successful after an attempt showed in logs as failed.</span>
<span class="source-line-no">2707</span><span id="line-2707">        if (tries &gt; 0 || LOG.isTraceEnabled()) {</span>
<span class="source-line-no">2708</span><span id="line-2708">          LOG.info("TRANSITION REPORTED " + request);</span>
<span class="source-line-no">2709</span><span id="line-2709">        }</span>
<span class="source-line-no">2710</span><span id="line-2710">        // NOTE: Return mid-method!!!</span>
<span class="source-line-no">2711</span><span id="line-2711">        return true;</span>
<span class="source-line-no">2712</span><span id="line-2712">      } catch (ServiceException se) {</span>
<span class="source-line-no">2713</span><span id="line-2713">        IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">2714</span><span id="line-2714">        boolean pause = ioe instanceof ServerNotRunningYetException</span>
<span class="source-line-no">2715</span><span id="line-2715">          || ioe instanceof PleaseHoldException || ioe instanceof CallQueueTooBigException;</span>
<span class="source-line-no">2716</span><span id="line-2716">        if (pause) {</span>
<span class="source-line-no">2717</span><span id="line-2717">          // Do backoff else we flood the Master with requests.</span>
<span class="source-line-no">2718</span><span id="line-2718">          pauseTime = ConnectionUtils.getPauseTime(this.retryPauseTime, tries);</span>
<span class="source-line-no">2719</span><span id="line-2719">        } else {</span>
<span class="source-line-no">2720</span><span id="line-2720">          pauseTime = this.retryPauseTime; // Reset.</span>
<span class="source-line-no">2721</span><span id="line-2721">        }</span>
<span class="source-line-no">2722</span><span id="line-2722">        LOG.info("Failed report transition " + TextFormat.shortDebugString(request) + "; retry (#"</span>
<span class="source-line-no">2723</span><span id="line-2723">          + tries + ")"</span>
<span class="source-line-no">2724</span><span id="line-2724">          + (pause</span>
<span class="source-line-no">2725</span><span id="line-2725">            ? " after " + pauseTime + "ms delay (Master is coming online...)."</span>
<span class="source-line-no">2726</span><span id="line-2726">            : " immediately."),</span>
<span class="source-line-no">2727</span><span id="line-2727">          ioe);</span>
<span class="source-line-no">2728</span><span id="line-2728">        if (pause) {</span>
<span class="source-line-no">2729</span><span id="line-2729">          Threads.sleep(pauseTime);</span>
<span class="source-line-no">2730</span><span id="line-2730">        }</span>
<span class="source-line-no">2731</span><span id="line-2731">        tries++;</span>
<span class="source-line-no">2732</span><span id="line-2732">        if (rssStub == rss) {</span>
<span class="source-line-no">2733</span><span id="line-2733">          rssStub = null;</span>
<span class="source-line-no">2734</span><span id="line-2734">        }</span>
<span class="source-line-no">2735</span><span id="line-2735">      }</span>
<span class="source-line-no">2736</span><span id="line-2736">    }</span>
<span class="source-line-no">2737</span><span id="line-2737">    return false;</span>
<span class="source-line-no">2738</span><span id="line-2738">  }</span>
<span class="source-line-no">2739</span><span id="line-2739"></span>
<span class="source-line-no">2740</span><span id="line-2740">  /**</span>
<span class="source-line-no">2741</span><span id="line-2741">   * Trigger a flush in the primary region replica if this region is a secondary replica. Does not</span>
<span class="source-line-no">2742</span><span id="line-2742">   * block this thread. See RegionReplicaFlushHandler for details.</span>
<span class="source-line-no">2743</span><span id="line-2743">   */</span>
<span class="source-line-no">2744</span><span id="line-2744">  private void triggerFlushInPrimaryRegion(final HRegion region) {</span>
<span class="source-line-no">2745</span><span id="line-2745">    if (ServerRegionReplicaUtil.isDefaultReplica(region.getRegionInfo())) {</span>
<span class="source-line-no">2746</span><span id="line-2746">      return;</span>
<span class="source-line-no">2747</span><span id="line-2747">    }</span>
<span class="source-line-no">2748</span><span id="line-2748">    TableName tn = region.getTableDescriptor().getTableName();</span>
<span class="source-line-no">2749</span><span id="line-2749">    if (</span>
<span class="source-line-no">2750</span><span id="line-2750">      !ServerRegionReplicaUtil.isRegionReplicaReplicationEnabled(region.conf, tn)</span>
<span class="source-line-no">2751</span><span id="line-2751">        || !ServerRegionReplicaUtil.isRegionReplicaWaitForPrimaryFlushEnabled(region.conf) ||</span>
<span class="source-line-no">2752</span><span id="line-2752">        // If the memstore replication not setup, we do not have to wait for observing a flush event</span>
<span class="source-line-no">2753</span><span id="line-2753">        // from primary before starting to serve reads, because gaps from replication is not</span>
<span class="source-line-no">2754</span><span id="line-2754">        // applicable,this logic is from</span>
<span class="source-line-no">2755</span><span id="line-2755">        // TableDescriptorBuilder.ModifyableTableDescriptor.setRegionMemStoreReplication by</span>
<span class="source-line-no">2756</span><span id="line-2756">        // HBASE-13063</span>
<span class="source-line-no">2757</span><span id="line-2757">        !region.getTableDescriptor().hasRegionMemStoreReplication()</span>
<span class="source-line-no">2758</span><span id="line-2758">    ) {</span>
<span class="source-line-no">2759</span><span id="line-2759">      region.setReadsEnabled(true);</span>
<span class="source-line-no">2760</span><span id="line-2760">      return;</span>
<span class="source-line-no">2761</span><span id="line-2761">    }</span>
<span class="source-line-no">2762</span><span id="line-2762"></span>
<span class="source-line-no">2763</span><span id="line-2763">    region.setReadsEnabled(false); // disable reads before marking the region as opened.</span>
<span class="source-line-no">2764</span><span id="line-2764">    // RegionReplicaFlushHandler might reset this.</span>
<span class="source-line-no">2765</span><span id="line-2765"></span>
<span class="source-line-no">2766</span><span id="line-2766">    // Submit it to be handled by one of the handlers so that we do not block OpenRegionHandler</span>
<span class="source-line-no">2767</span><span id="line-2767">    if (this.executorService != null) {</span>
<span class="source-line-no">2768</span><span id="line-2768">      this.executorService.submit(new RegionReplicaFlushHandler(this, clusterConnection,</span>
<span class="source-line-no">2769</span><span id="line-2769">        rpcRetryingCallerFactory, rpcControllerFactory, operationTimeout, region));</span>
<span class="source-line-no">2770</span><span id="line-2770">    } else {</span>
<span class="source-line-no">2771</span><span id="line-2771">      LOG.info("Executor is null; not running flush of primary region replica for {}",</span>
<span class="source-line-no">2772</span><span id="line-2772">        region.getRegionInfo());</span>
<span class="source-line-no">2773</span><span id="line-2773">    }</span>
<span class="source-line-no">2774</span><span id="line-2774">  }</span>
<span class="source-line-no">2775</span><span id="line-2775"></span>
<span class="source-line-no">2776</span><span id="line-2776">  @Override</span>
<span class="source-line-no">2777</span><span id="line-2777">  public RpcServerInterface getRpcServer() {</span>
<span class="source-line-no">2778</span><span id="line-2778">    return rpcServices.rpcServer;</span>
<span class="source-line-no">2779</span><span id="line-2779">  }</span>
<span class="source-line-no">2780</span><span id="line-2780"></span>
<span class="source-line-no">2781</span><span id="line-2781">  @InterfaceAudience.Private</span>
<span class="source-line-no">2782</span><span id="line-2782">  public RSRpcServices getRSRpcServices() {</span>
<span class="source-line-no">2783</span><span id="line-2783">    return rpcServices;</span>
<span class="source-line-no">2784</span><span id="line-2784">  }</span>
<span class="source-line-no">2785</span><span id="line-2785"></span>
<span class="source-line-no">2786</span><span id="line-2786">  /**</span>
<span class="source-line-no">2787</span><span id="line-2787">   * Cause the server to exit without closing the regions it is serving, the log it is using and</span>
<span class="source-line-no">2788</span><span id="line-2788">   * without notifying the master. Used unit testing and on catastrophic events such as HDFS is</span>
<span class="source-line-no">2789</span><span id="line-2789">   * yanked out from under hbase or we OOME. the reason we are aborting the exception that caused</span>
<span class="source-line-no">2790</span><span id="line-2790">   * the abort, or null</span>
<span class="source-line-no">2791</span><span id="line-2791">   */</span>
<span class="source-line-no">2792</span><span id="line-2792">  @Override</span>
<span class="source-line-no">2793</span><span id="line-2793">  public void abort(String reason, Throwable cause) {</span>
<span class="source-line-no">2794</span><span id="line-2794">    if (!setAbortRequested()) {</span>
<span class="source-line-no">2795</span><span id="line-2795">      // Abort already in progress, ignore the new request.</span>
<span class="source-line-no">2796</span><span id="line-2796">      LOG.debug("Abort already in progress. Ignoring the current request with reason: {}", reason);</span>
<span class="source-line-no">2797</span><span id="line-2797">      return;</span>
<span class="source-line-no">2798</span><span id="line-2798">    }</span>
<span class="source-line-no">2799</span><span id="line-2799">    String msg = "***** ABORTING region server " + this + ": " + reason + " *****";</span>
<span class="source-line-no">2800</span><span id="line-2800">    if (cause != null) {</span>
<span class="source-line-no">2801</span><span id="line-2801">      LOG.error(HBaseMarkers.FATAL, msg, cause);</span>
<span class="source-line-no">2802</span><span id="line-2802">    } else {</span>
<span class="source-line-no">2803</span><span id="line-2803">      LOG.error(HBaseMarkers.FATAL, msg);</span>
<span class="source-line-no">2804</span><span id="line-2804">    }</span>
<span class="source-line-no">2805</span><span id="line-2805">    // HBASE-4014: show list of coprocessors that were loaded to help debug</span>
<span class="source-line-no">2806</span><span id="line-2806">    // regionserver crashes.Note that we're implicitly using</span>
<span class="source-line-no">2807</span><span id="line-2807">    // java.util.HashSet's toString() method to print the coprocessor names.</span>
<span class="source-line-no">2808</span><span id="line-2808">    LOG.error(HBaseMarkers.FATAL,</span>
<span class="source-line-no">2809</span><span id="line-2809">      "RegionServer abort: loaded coprocessors are: " + CoprocessorHost.getLoadedCoprocessors());</span>
<span class="source-line-no">2810</span><span id="line-2810">    // Try and dump metrics if abort -- might give clue as to how fatal came about....</span>
<span class="source-line-no">2811</span><span id="line-2811">    try {</span>
<span class="source-line-no">2812</span><span id="line-2812">      LOG.info("Dump of metrics as JSON on abort: " + DumpRegionServerMetrics.dumpMetrics());</span>
<span class="source-line-no">2813</span><span id="line-2813">    } catch (MalformedObjectNameException | IOException e) {</span>
<span class="source-line-no">2814</span><span id="line-2814">      LOG.warn("Failed dumping metrics", e);</span>
<span class="source-line-no">2815</span><span id="line-2815">    }</span>
<span class="source-line-no">2816</span><span id="line-2816"></span>
<span class="source-line-no">2817</span><span id="line-2817">    // Do our best to report our abort to the master, but this may not work</span>
<span class="source-line-no">2818</span><span id="line-2818">    try {</span>
<span class="source-line-no">2819</span><span id="line-2819">      if (cause != null) {</span>
<span class="source-line-no">2820</span><span id="line-2820">        msg += "\nCause:\n" + Throwables.getStackTraceAsString(cause);</span>
<span class="source-line-no">2821</span><span id="line-2821">      }</span>
<span class="source-line-no">2822</span><span id="line-2822">      // Report to the master but only if we have already registered with the master.</span>
<span class="source-line-no">2823</span><span id="line-2823">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2824</span><span id="line-2824">      if (rss != null &amp;&amp; this.serverName != null) {</span>
<span class="source-line-no">2825</span><span id="line-2825">        ReportRSFatalErrorRequest.Builder builder = ReportRSFatalErrorRequest.newBuilder();</span>
<span class="source-line-no">2826</span><span id="line-2826">        builder.setServer(ProtobufUtil.toServerName(this.serverName));</span>
<span class="source-line-no">2827</span><span id="line-2827">        builder.setErrorMessage(msg);</span>
<span class="source-line-no">2828</span><span id="line-2828">        rss.reportRSFatalError(null, builder.build());</span>
<span class="source-line-no">2829</span><span id="line-2829">      }</span>
<span class="source-line-no">2830</span><span id="line-2830">    } catch (Throwable t) {</span>
<span class="source-line-no">2831</span><span id="line-2831">      LOG.warn("Unable to report fatal error to master", t);</span>
<span class="source-line-no">2832</span><span id="line-2832">    }</span>
<span class="source-line-no">2833</span><span id="line-2833"></span>
<span class="source-line-no">2834</span><span id="line-2834">    scheduleAbortTimer();</span>
<span class="source-line-no">2835</span><span id="line-2835">    // shutdown should be run as the internal user</span>
<span class="source-line-no">2836</span><span id="line-2836">    stop(reason, true, null);</span>
<span class="source-line-no">2837</span><span id="line-2837">  }</span>
<span class="source-line-no">2838</span><span id="line-2838"></span>
<span class="source-line-no">2839</span><span id="line-2839">  /**</span>
<span class="source-line-no">2840</span><span id="line-2840">   * Sets the abort state if not already set.</span>
<span class="source-line-no">2841</span><span id="line-2841">   * @return True if abortRequested set to True successfully, false if an abort is already in</span>
<span class="source-line-no">2842</span><span id="line-2842">   *         progress.</span>
<span class="source-line-no">2843</span><span id="line-2843">   */</span>
<span class="source-line-no">2844</span><span id="line-2844">  protected boolean setAbortRequested() {</span>
<span class="source-line-no">2845</span><span id="line-2845">    return abortRequested.compareAndSet(false, true);</span>
<span class="source-line-no">2846</span><span id="line-2846">  }</span>
<span class="source-line-no">2847</span><span id="line-2847"></span>
<span class="source-line-no">2848</span><span id="line-2848">  @Override</span>
<span class="source-line-no">2849</span><span id="line-2849">  public boolean isAborted() {</span>
<span class="source-line-no">2850</span><span id="line-2850">    return abortRequested.get();</span>
<span class="source-line-no">2851</span><span id="line-2851">  }</span>
<span class="source-line-no">2852</span><span id="line-2852"></span>
<span class="source-line-no">2853</span><span id="line-2853">  /*</span>
<span class="source-line-no">2854</span><span id="line-2854">   * Simulate a kill -9 of this server. Exits w/o closing regions or cleaninup logs but it does</span>
<span class="source-line-no">2855</span><span id="line-2855">   * close socket in case want to bring up server on old hostname+port immediately.</span>
<span class="source-line-no">2856</span><span id="line-2856">   */</span>
<span class="source-line-no">2857</span><span id="line-2857">  @InterfaceAudience.Private</span>
<span class="source-line-no">2858</span><span id="line-2858">  protected void kill() {</span>
<span class="source-line-no">2859</span><span id="line-2859">    this.killed = true;</span>
<span class="source-line-no">2860</span><span id="line-2860">    abort("Simulated kill");</span>
<span class="source-line-no">2861</span><span id="line-2861">  }</span>
<span class="source-line-no">2862</span><span id="line-2862"></span>
<span class="source-line-no">2863</span><span id="line-2863">  // Limits the time spent in the shutdown process.</span>
<span class="source-line-no">2864</span><span id="line-2864">  private void scheduleAbortTimer() {</span>
<span class="source-line-no">2865</span><span id="line-2865">    if (this.abortMonitor == null) {</span>
<span class="source-line-no">2866</span><span id="line-2866">      this.abortMonitor = new Timer("Abort regionserver monitor", true);</span>
<span class="source-line-no">2867</span><span id="line-2867">      TimerTask abortTimeoutTask = null;</span>
<span class="source-line-no">2868</span><span id="line-2868">      try {</span>
<span class="source-line-no">2869</span><span id="line-2869">        Constructor&lt;? extends TimerTask&gt; timerTaskCtor =</span>
<span class="source-line-no">2870</span><span id="line-2870">          Class.forName(conf.get(ABORT_TIMEOUT_TASK, SystemExitWhenAbortTimeout.class.getName()))</span>
<span class="source-line-no">2871</span><span id="line-2871">            .asSubclass(TimerTask.class).getDeclaredConstructor();</span>
<span class="source-line-no">2872</span><span id="line-2872">        timerTaskCtor.setAccessible(true);</span>
<span class="source-line-no">2873</span><span id="line-2873">        abortTimeoutTask = timerTaskCtor.newInstance();</span>
<span class="source-line-no">2874</span><span id="line-2874">      } catch (Exception e) {</span>
<span class="source-line-no">2875</span><span id="line-2875">        LOG.warn("Initialize abort timeout task failed", e);</span>
<span class="source-line-no">2876</span><span id="line-2876">      }</span>
<span class="source-line-no">2877</span><span id="line-2877">      if (abortTimeoutTask != null) {</span>
<span class="source-line-no">2878</span><span id="line-2878">        abortMonitor.schedule(abortTimeoutTask, conf.getLong(ABORT_TIMEOUT, DEFAULT_ABORT_TIMEOUT));</span>
<span class="source-line-no">2879</span><span id="line-2879">      }</span>
<span class="source-line-no">2880</span><span id="line-2880">    }</span>
<span class="source-line-no">2881</span><span id="line-2881">  }</span>
<span class="source-line-no">2882</span><span id="line-2882"></span>
<span class="source-line-no">2883</span><span id="line-2883">  protected final void shutdownChore(ScheduledChore chore) {</span>
<span class="source-line-no">2884</span><span id="line-2884">    if (chore != null) {</span>
<span class="source-line-no">2885</span><span id="line-2885">      chore.shutdown();</span>
<span class="source-line-no">2886</span><span id="line-2886">    }</span>
<span class="source-line-no">2887</span><span id="line-2887">  }</span>
<span class="source-line-no">2888</span><span id="line-2888"></span>
<span class="source-line-no">2889</span><span id="line-2889">  /**</span>
<span class="source-line-no">2890</span><span id="line-2890">   * Wait on all threads to finish. Presumption is that all closes and stops have already been</span>
<span class="source-line-no">2891</span><span id="line-2891">   * called.</span>
<span class="source-line-no">2892</span><span id="line-2892">   */</span>
<span class="source-line-no">2893</span><span id="line-2893">  protected void stopServiceThreads() {</span>
<span class="source-line-no">2894</span><span id="line-2894">    // clean up the scheduled chores</span>
<span class="source-line-no">2895</span><span id="line-2895">    if (this.choreService != null) {</span>
<span class="source-line-no">2896</span><span id="line-2896">      shutdownChore(nonceManagerChore);</span>
<span class="source-line-no">2897</span><span id="line-2897">      shutdownChore(compactionChecker);</span>
<span class="source-line-no">2898</span><span id="line-2898">      shutdownChore(compactedFileDischarger);</span>
<span class="source-line-no">2899</span><span id="line-2899">      shutdownChore(periodicFlusher);</span>
<span class="source-line-no">2900</span><span id="line-2900">      shutdownChore(healthCheckChore);</span>
<span class="source-line-no">2901</span><span id="line-2901">      shutdownChore(storefileRefresher);</span>
<span class="source-line-no">2902</span><span id="line-2902">      shutdownChore(fsUtilizationChore);</span>
<span class="source-line-no">2903</span><span id="line-2903">      shutdownChore(namedQueueServiceChore);</span>
<span class="source-line-no">2904</span><span id="line-2904">      shutdownChore(replicationMarkerChore);</span>
<span class="source-line-no">2905</span><span id="line-2905">      shutdownChore(rsMobFileCleanerChore);</span>
<span class="source-line-no">2906</span><span id="line-2906">      // cancel the remaining scheduled chores (in case we missed out any)</span>
<span class="source-line-no">2907</span><span id="line-2907">      // TODO: cancel will not cleanup the chores, so we need make sure we do not miss any</span>
<span class="source-line-no">2908</span><span id="line-2908">      choreService.shutdown();</span>
<span class="source-line-no">2909</span><span id="line-2909">    }</span>
<span class="source-line-no">2910</span><span id="line-2910">    if (bootstrapNodeManager != null) {</span>
<span class="source-line-no">2911</span><span id="line-2911">      bootstrapNodeManager.stop();</span>
<span class="source-line-no">2912</span><span id="line-2912">    }</span>
<span class="source-line-no">2913</span><span id="line-2913">    if (this.cacheFlusher != null) {</span>
<span class="source-line-no">2914</span><span id="line-2914">      this.cacheFlusher.shutdown();</span>
<span class="source-line-no">2915</span><span id="line-2915">    }</span>
<span class="source-line-no">2916</span><span id="line-2916">    if (this.walRoller != null) {</span>
<span class="source-line-no">2917</span><span id="line-2917">      this.walRoller.close();</span>
<span class="source-line-no">2918</span><span id="line-2918">    }</span>
<span class="source-line-no">2919</span><span id="line-2919">    if (this.compactSplitThread != null) {</span>
<span class="source-line-no">2920</span><span id="line-2920">      this.compactSplitThread.join();</span>
<span class="source-line-no">2921</span><span id="line-2921">    }</span>
<span class="source-line-no">2922</span><span id="line-2922">    if (this.executorService != null) {</span>
<span class="source-line-no">2923</span><span id="line-2923">      this.executorService.shutdown();</span>
<span class="source-line-no">2924</span><span id="line-2924">    }</span>
<span class="source-line-no">2925</span><span id="line-2925">    if (</span>
<span class="source-line-no">2926</span><span id="line-2926">      this.replicationSourceHandler != null</span>
<span class="source-line-no">2927</span><span id="line-2927">        &amp;&amp; this.replicationSourceHandler == this.replicationSinkHandler</span>
<span class="source-line-no">2928</span><span id="line-2928">    ) {</span>
<span class="source-line-no">2929</span><span id="line-2929">      this.replicationSourceHandler.stopReplicationService();</span>
<span class="source-line-no">2930</span><span id="line-2930">    } else {</span>
<span class="source-line-no">2931</span><span id="line-2931">      if (this.replicationSourceHandler != null) {</span>
<span class="source-line-no">2932</span><span id="line-2932">        this.replicationSourceHandler.stopReplicationService();</span>
<span class="source-line-no">2933</span><span id="line-2933">      }</span>
<span class="source-line-no">2934</span><span id="line-2934">      if (this.replicationSinkHandler != null) {</span>
<span class="source-line-no">2935</span><span id="line-2935">        this.replicationSinkHandler.stopReplicationService();</span>
<span class="source-line-no">2936</span><span id="line-2936">      }</span>
<span class="source-line-no">2937</span><span id="line-2937">    }</span>
<span class="source-line-no">2938</span><span id="line-2938">  }</span>
<span class="source-line-no">2939</span><span id="line-2939"></span>
<span class="source-line-no">2940</span><span id="line-2940">  /** Returns Return the object that implements the replication source executorService. */</span>
<span class="source-line-no">2941</span><span id="line-2941">  @InterfaceAudience.Private</span>
<span class="source-line-no">2942</span><span id="line-2942">  public ReplicationSourceService getReplicationSourceService() {</span>
<span class="source-line-no">2943</span><span id="line-2943">    return replicationSourceHandler;</span>
<span class="source-line-no">2944</span><span id="line-2944">  }</span>
<span class="source-line-no">2945</span><span id="line-2945"></span>
<span class="source-line-no">2946</span><span id="line-2946">  /** Returns Return the object that implements the replication sink executorService. */</span>
<span class="source-line-no">2947</span><span id="line-2947">  ReplicationSinkService getReplicationSinkService() {</span>
<span class="source-line-no">2948</span><span id="line-2948">    return replicationSinkHandler;</span>
<span class="source-line-no">2949</span><span id="line-2949">  }</span>
<span class="source-line-no">2950</span><span id="line-2950"></span>
<span class="source-line-no">2951</span><span id="line-2951">  /**</span>
<span class="source-line-no">2952</span><span id="line-2952">   * Get the current master from ZooKeeper and open the RPC connection to it. To get a fresh</span>
<span class="source-line-no">2953</span><span id="line-2953">   * connection, the current rssStub must be null. Method will block until a master is available.</span>
<span class="source-line-no">2954</span><span id="line-2954">   * You can break from this block by requesting the server stop.</span>
<span class="source-line-no">2955</span><span id="line-2955">   * @return master + port, or null if server has been stopped</span>
<span class="source-line-no">2956</span><span id="line-2956">   */</span>
<span class="source-line-no">2957</span><span id="line-2957">  private synchronized ServerName createRegionServerStatusStub() {</span>
<span class="source-line-no">2958</span><span id="line-2958">    // Create RS stub without refreshing the master node from ZK, use cached data</span>
<span class="source-line-no">2959</span><span id="line-2959">    return createRegionServerStatusStub(false);</span>
<span class="source-line-no">2960</span><span id="line-2960">  }</span>
<span class="source-line-no">2961</span><span id="line-2961"></span>
<span class="source-line-no">2962</span><span id="line-2962">  /**</span>
<span class="source-line-no">2963</span><span id="line-2963">   * Get the current master from ZooKeeper and open the RPC connection to it. To get a fresh</span>
<span class="source-line-no">2964</span><span id="line-2964">   * connection, the current rssStub must be null. Method will block until a master is available.</span>
<span class="source-line-no">2965</span><span id="line-2965">   * You can break from this block by requesting the server stop.</span>
<span class="source-line-no">2966</span><span id="line-2966">   * @param refresh If true then master address will be read from ZK, otherwise use cached data</span>
<span class="source-line-no">2967</span><span id="line-2967">   * @return master + port, or null if server has been stopped</span>
<span class="source-line-no">2968</span><span id="line-2968">   */</span>
<span class="source-line-no">2969</span><span id="line-2969">  @InterfaceAudience.Private</span>
<span class="source-line-no">2970</span><span id="line-2970">  protected synchronized ServerName createRegionServerStatusStub(boolean refresh) {</span>
<span class="source-line-no">2971</span><span id="line-2971">    if (rssStub != null) {</span>
<span class="source-line-no">2972</span><span id="line-2972">      return masterAddressTracker.getMasterAddress();</span>
<span class="source-line-no">2973</span><span id="line-2973">    }</span>
<span class="source-line-no">2974</span><span id="line-2974">    ServerName sn = null;</span>
<span class="source-line-no">2975</span><span id="line-2975">    long previousLogTime = 0;</span>
<span class="source-line-no">2976</span><span id="line-2976">    RegionServerStatusService.BlockingInterface intRssStub = null;</span>
<span class="source-line-no">2977</span><span id="line-2977">    LockService.BlockingInterface intLockStub = null;</span>
<span class="source-line-no">2978</span><span id="line-2978">    boolean interrupted = false;</span>
<span class="source-line-no">2979</span><span id="line-2979">    try {</span>
<span class="source-line-no">2980</span><span id="line-2980">      while (keepLooping()) {</span>
<span class="source-line-no">2981</span><span id="line-2981">        sn = this.masterAddressTracker.getMasterAddress(refresh);</span>
<span class="source-line-no">2982</span><span id="line-2982">        if (sn == null) {</span>
<span class="source-line-no">2983</span><span id="line-2983">          if (!keepLooping()) {</span>
<span class="source-line-no">2984</span><span id="line-2984">            // give up with no connection.</span>
<span class="source-line-no">2985</span><span id="line-2985">            LOG.debug("No master found and cluster is stopped; bailing out");</span>
<span class="source-line-no">2986</span><span id="line-2986">            return null;</span>
<span class="source-line-no">2987</span><span id="line-2987">          }</span>
<span class="source-line-no">2988</span><span id="line-2988">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">2989</span><span id="line-2989">            LOG.debug("No master found; retry");</span>
<span class="source-line-no">2990</span><span id="line-2990">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2991</span><span id="line-2991">          }</span>
<span class="source-line-no">2992</span><span id="line-2992">          refresh = true; // let's try pull it from ZK directly</span>
<span class="source-line-no">2993</span><span id="line-2993">          if (sleepInterrupted(200)) {</span>
<span class="source-line-no">2994</span><span id="line-2994">            interrupted = true;</span>
<span class="source-line-no">2995</span><span id="line-2995">          }</span>
<span class="source-line-no">2996</span><span id="line-2996">          continue;</span>
<span class="source-line-no">2997</span><span id="line-2997">        }</span>
<span class="source-line-no">2998</span><span id="line-2998"></span>
<span class="source-line-no">2999</span><span id="line-2999">        // If we are on the active master, use the shortcut</span>
<span class="source-line-no">3000</span><span id="line-3000">        if (this instanceof HMaster &amp;&amp; sn.equals(getServerName())) {</span>
<span class="source-line-no">3001</span><span id="line-3001">          intRssStub = ((HMaster) this).getMasterRpcServices();</span>
<span class="source-line-no">3002</span><span id="line-3002">          intLockStub = ((HMaster) this).getMasterRpcServices();</span>
<span class="source-line-no">3003</span><span id="line-3003">          break;</span>
<span class="source-line-no">3004</span><span id="line-3004">        }</span>
<span class="source-line-no">3005</span><span id="line-3005">        try {</span>
<span class="source-line-no">3006</span><span id="line-3006">          BlockingRpcChannel channel = this.rpcClient.createBlockingRpcChannel(sn,</span>
<span class="source-line-no">3007</span><span id="line-3007">            userProvider.getCurrent(), shortOperationTimeout);</span>
<span class="source-line-no">3008</span><span id="line-3008">          intRssStub = RegionServerStatusService.newBlockingStub(channel);</span>
<span class="source-line-no">3009</span><span id="line-3009">          intLockStub = LockService.newBlockingStub(channel);</span>
<span class="source-line-no">3010</span><span id="line-3010">          break;</span>
<span class="source-line-no">3011</span><span id="line-3011">        } catch (IOException e) {</span>
<span class="source-line-no">3012</span><span id="line-3012">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">3013</span><span id="line-3013">            e = e instanceof RemoteException ? ((RemoteException) e).unwrapRemoteException() : e;</span>
<span class="source-line-no">3014</span><span id="line-3014">            if (e instanceof ServerNotRunningYetException) {</span>
<span class="source-line-no">3015</span><span id="line-3015">              LOG.info("Master isn't available yet, retrying");</span>
<span class="source-line-no">3016</span><span id="line-3016">            } else {</span>
<span class="source-line-no">3017</span><span id="line-3017">              LOG.warn("Unable to connect to master. Retrying. Error was:", e);</span>
<span class="source-line-no">3018</span><span id="line-3018">            }</span>
<span class="source-line-no">3019</span><span id="line-3019">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">3020</span><span id="line-3020">          }</span>
<span class="source-line-no">3021</span><span id="line-3021">          if (sleepInterrupted(200)) {</span>
<span class="source-line-no">3022</span><span id="line-3022">            interrupted = true;</span>
<span class="source-line-no">3023</span><span id="line-3023">          }</span>
<span class="source-line-no">3024</span><span id="line-3024">        }</span>
<span class="source-line-no">3025</span><span id="line-3025">      }</span>
<span class="source-line-no">3026</span><span id="line-3026">    } finally {</span>
<span class="source-line-no">3027</span><span id="line-3027">      if (interrupted) {</span>
<span class="source-line-no">3028</span><span id="line-3028">        Thread.currentThread().interrupt();</span>
<span class="source-line-no">3029</span><span id="line-3029">      }</span>
<span class="source-line-no">3030</span><span id="line-3030">    }</span>
<span class="source-line-no">3031</span><span id="line-3031">    this.rssStub = intRssStub;</span>
<span class="source-line-no">3032</span><span id="line-3032">    this.lockStub = intLockStub;</span>
<span class="source-line-no">3033</span><span id="line-3033">    return sn;</span>
<span class="source-line-no">3034</span><span id="line-3034">  }</span>
<span class="source-line-no">3035</span><span id="line-3035"></span>
<span class="source-line-no">3036</span><span id="line-3036">  /**</span>
<span class="source-line-no">3037</span><span id="line-3037">   * @return True if we should break loop because cluster is going down or this server has been</span>
<span class="source-line-no">3038</span><span id="line-3038">   *         stopped or hdfs has gone bad.</span>
<span class="source-line-no">3039</span><span id="line-3039">   */</span>
<span class="source-line-no">3040</span><span id="line-3040">  private boolean keepLooping() {</span>
<span class="source-line-no">3041</span><span id="line-3041">    return !this.stopped &amp;&amp; isClusterUp();</span>
<span class="source-line-no">3042</span><span id="line-3042">  }</span>
<span class="source-line-no">3043</span><span id="line-3043"></span>
<span class="source-line-no">3044</span><span id="line-3044">  /*</span>
<span class="source-line-no">3045</span><span id="line-3045">   * Let the master know we're here Run initialization using parameters passed us by the master.</span>
<span class="source-line-no">3046</span><span id="line-3046">   * @return A Map of key/value configurations we got from the Master else null if we failed to</span>
<span class="source-line-no">3047</span><span id="line-3047">   * register.</span>
<span class="source-line-no">3048</span><span id="line-3048">   */</span>
<span class="source-line-no">3049</span><span id="line-3049">  private RegionServerStartupResponse reportForDuty() throws IOException {</span>
<span class="source-line-no">3050</span><span id="line-3050">    if (this.masterless) {</span>
<span class="source-line-no">3051</span><span id="line-3051">      return RegionServerStartupResponse.getDefaultInstance();</span>
<span class="source-line-no">3052</span><span id="line-3052">    }</span>
<span class="source-line-no">3053</span><span id="line-3053">    ServerName masterServerName = createRegionServerStatusStub(true);</span>
<span class="source-line-no">3054</span><span id="line-3054">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">3055</span><span id="line-3055">    if (masterServerName == null || rss == null) {</span>
<span class="source-line-no">3056</span><span id="line-3056">      return null;</span>
<span class="source-line-no">3057</span><span id="line-3057">    }</span>
<span class="source-line-no">3058</span><span id="line-3058">    RegionServerStartupResponse result = null;</span>
<span class="source-line-no">3059</span><span id="line-3059">    try {</span>
<span class="source-line-no">3060</span><span id="line-3060">      rpcServices.requestCount.reset();</span>
<span class="source-line-no">3061</span><span id="line-3061">      rpcServices.rpcGetRequestCount.reset();</span>
<span class="source-line-no">3062</span><span id="line-3062">      rpcServices.rpcScanRequestCount.reset();</span>
<span class="source-line-no">3063</span><span id="line-3063">      rpcServices.rpcFullScanRequestCount.reset();</span>
<span class="source-line-no">3064</span><span id="line-3064">      rpcServices.rpcMultiRequestCount.reset();</span>
<span class="source-line-no">3065</span><span id="line-3065">      rpcServices.rpcMutateRequestCount.reset();</span>
<span class="source-line-no">3066</span><span id="line-3066">      LOG.info("reportForDuty to master=" + masterServerName + " with isa=" + rpcServices.isa</span>
<span class="source-line-no">3067</span><span id="line-3067">        + ", startcode=" + this.startcode);</span>
<span class="source-line-no">3068</span><span id="line-3068">      long now = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">3069</span><span id="line-3069">      int port = rpcServices.isa.getPort();</span>
<span class="source-line-no">3070</span><span id="line-3070">      RegionServerStartupRequest.Builder request = RegionServerStartupRequest.newBuilder();</span>
<span class="source-line-no">3071</span><span id="line-3071">      if (!StringUtils.isBlank(useThisHostnameInstead)) {</span>
<span class="source-line-no">3072</span><span id="line-3072">        request.setUseThisHostnameInstead(useThisHostnameInstead);</span>
<span class="source-line-no">3073</span><span id="line-3073">      }</span>
<span class="source-line-no">3074</span><span id="line-3074">      request.setPort(port);</span>
<span class="source-line-no">3075</span><span id="line-3075">      request.setServerStartCode(this.startcode);</span>
<span class="source-line-no">3076</span><span id="line-3076">      request.setServerCurrentTime(now);</span>
<span class="source-line-no">3077</span><span id="line-3077">      result = rss.regionServerStartup(null, request.build());</span>
<span class="source-line-no">3078</span><span id="line-3078">    } catch (ServiceException se) {</span>
<span class="source-line-no">3079</span><span id="line-3079">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">3080</span><span id="line-3080">      if (ioe instanceof ClockOutOfSyncException) {</span>
<span class="source-line-no">3081</span><span id="line-3081">        LOG.error(HBaseMarkers.FATAL, "Master rejected startup because clock is out of sync", ioe);</span>
<span class="source-line-no">3082</span><span id="line-3082">        // Re-throw IOE will cause RS to abort</span>
<span class="source-line-no">3083</span><span id="line-3083">        throw ioe;</span>
<span class="source-line-no">3084</span><span id="line-3084">      } else if (ioe instanceof DecommissionedHostRejectedException) {</span>
<span class="source-line-no">3085</span><span id="line-3085">        LOG.error(HBaseMarkers.FATAL,</span>
<span class="source-line-no">3086</span><span id="line-3086">          "Master rejected startup because the host is considered decommissioned", ioe);</span>
<span class="source-line-no">3087</span><span id="line-3087">        // Re-throw IOE will cause RS to abort</span>
<span class="source-line-no">3088</span><span id="line-3088">        throw ioe;</span>
<span class="source-line-no">3089</span><span id="line-3089">      } else if (ioe instanceof ServerNotRunningYetException) {</span>
<span class="source-line-no">3090</span><span id="line-3090">        LOG.debug("Master is not running yet");</span>
<span class="source-line-no">3091</span><span id="line-3091">      } else {</span>
<span class="source-line-no">3092</span><span id="line-3092">        LOG.warn("error telling master we are up", se);</span>
<span class="source-line-no">3093</span><span id="line-3093">      }</span>
<span class="source-line-no">3094</span><span id="line-3094">      rssStub = null;</span>
<span class="source-line-no">3095</span><span id="line-3095">    }</span>
<span class="source-line-no">3096</span><span id="line-3096">    return result;</span>
<span class="source-line-no">3097</span><span id="line-3097">  }</span>
<span class="source-line-no">3098</span><span id="line-3098"></span>
<span class="source-line-no">3099</span><span id="line-3099">  @Override</span>
<span class="source-line-no">3100</span><span id="line-3100">  public RegionStoreSequenceIds getLastSequenceId(byte[] encodedRegionName) {</span>
<span class="source-line-no">3101</span><span id="line-3101">    try {</span>
<span class="source-line-no">3102</span><span id="line-3102">      GetLastFlushedSequenceIdRequest req =</span>
<span class="source-line-no">3103</span><span id="line-3103">        RequestConverter.buildGetLastFlushedSequenceIdRequest(encodedRegionName);</span>
<span class="source-line-no">3104</span><span id="line-3104">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">3105</span><span id="line-3105">      if (rss == null) { // Try to connect one more time</span>
<span class="source-line-no">3106</span><span id="line-3106">        createRegionServerStatusStub();</span>
<span class="source-line-no">3107</span><span id="line-3107">        rss = rssStub;</span>
<span class="source-line-no">3108</span><span id="line-3108">        if (rss == null) {</span>
<span class="source-line-no">3109</span><span id="line-3109">          // Still no luck, we tried</span>
<span class="source-line-no">3110</span><span id="line-3110">          LOG.warn("Unable to connect to the master to check " + "the last flushed sequence id");</span>
<span class="source-line-no">3111</span><span id="line-3111">          return RegionStoreSequenceIds.newBuilder().setLastFlushedSequenceId(HConstants.NO_SEQNUM)</span>
<span class="source-line-no">3112</span><span id="line-3112">            .build();</span>
<span class="source-line-no">3113</span><span id="line-3113">        }</span>
<span class="source-line-no">3114</span><span id="line-3114">      }</span>
<span class="source-line-no">3115</span><span id="line-3115">      GetLastFlushedSequenceIdResponse resp = rss.getLastFlushedSequenceId(null, req);</span>
<span class="source-line-no">3116</span><span id="line-3116">      return RegionStoreSequenceIds.newBuilder()</span>
<span class="source-line-no">3117</span><span id="line-3117">        .setLastFlushedSequenceId(resp.getLastFlushedSequenceId())</span>
<span class="source-line-no">3118</span><span id="line-3118">        .addAllStoreSequenceId(resp.getStoreLastFlushedSequenceIdList()).build();</span>
<span class="source-line-no">3119</span><span id="line-3119">    } catch (ServiceException e) {</span>
<span class="source-line-no">3120</span><span id="line-3120">      LOG.warn("Unable to connect to the master to check the last flushed sequence id", e);</span>
<span class="source-line-no">3121</span><span id="line-3121">      return RegionStoreSequenceIds.newBuilder().setLastFlushedSequenceId(HConstants.NO_SEQNUM)</span>
<span class="source-line-no">3122</span><span id="line-3122">        .build();</span>
<span class="source-line-no">3123</span><span id="line-3123">    }</span>
<span class="source-line-no">3124</span><span id="line-3124">  }</span>
<span class="source-line-no">3125</span><span id="line-3125"></span>
<span class="source-line-no">3126</span><span id="line-3126">  /**</span>
<span class="source-line-no">3127</span><span id="line-3127">   * Close meta region if we carry it</span>
<span class="source-line-no">3128</span><span id="line-3128">   * @param abort Whether we're running an abort.</span>
<span class="source-line-no">3129</span><span id="line-3129">   */</span>
<span class="source-line-no">3130</span><span id="line-3130">  private void closeMetaTableRegions(final boolean abort) {</span>
<span class="source-line-no">3131</span><span id="line-3131">    HRegion meta = null;</span>
<span class="source-line-no">3132</span><span id="line-3132">    this.onlineRegionsLock.writeLock().lock();</span>
<span class="source-line-no">3133</span><span id="line-3133">    try {</span>
<span class="source-line-no">3134</span><span id="line-3134">      for (Map.Entry&lt;String, HRegion&gt; e : onlineRegions.entrySet()) {</span>
<span class="source-line-no">3135</span><span id="line-3135">        RegionInfo hri = e.getValue().getRegionInfo();</span>
<span class="source-line-no">3136</span><span id="line-3136">        if (hri.isMetaRegion()) {</span>
<span class="source-line-no">3137</span><span id="line-3137">          meta = e.getValue();</span>
<span class="source-line-no">3138</span><span id="line-3138">        }</span>
<span class="source-line-no">3139</span><span id="line-3139">        if (meta != null) {</span>
<span class="source-line-no">3140</span><span id="line-3140">          break;</span>
<span class="source-line-no">3141</span><span id="line-3141">        }</span>
<span class="source-line-no">3142</span><span id="line-3142">      }</span>
<span class="source-line-no">3143</span><span id="line-3143">    } finally {</span>
<span class="source-line-no">3144</span><span id="line-3144">      this.onlineRegionsLock.writeLock().unlock();</span>
<span class="source-line-no">3145</span><span id="line-3145">    }</span>
<span class="source-line-no">3146</span><span id="line-3146">    if (meta != null) {</span>
<span class="source-line-no">3147</span><span id="line-3147">      closeRegionIgnoreErrors(meta.getRegionInfo(), abort);</span>
<span class="source-line-no">3148</span><span id="line-3148">    }</span>
<span class="source-line-no">3149</span><span id="line-3149">  }</span>
<span class="source-line-no">3150</span><span id="line-3150"></span>
<span class="source-line-no">3151</span><span id="line-3151">  /**</span>
<span class="source-line-no">3152</span><span id="line-3152">   * Schedule closes on all user regions. Should be safe calling multiple times because it wont'</span>
<span class="source-line-no">3153</span><span id="line-3153">   * close regions that are already closed or that are closing.</span>
<span class="source-line-no">3154</span><span id="line-3154">   * @param abort Whether we're running an abort.</span>
<span class="source-line-no">3155</span><span id="line-3155">   */</span>
<span class="source-line-no">3156</span><span id="line-3156">  private void closeUserRegions(final boolean abort) {</span>
<span class="source-line-no">3157</span><span id="line-3157">    this.onlineRegionsLock.writeLock().lock();</span>
<span class="source-line-no">3158</span><span id="line-3158">    try {</span>
<span class="source-line-no">3159</span><span id="line-3159">      for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">3160</span><span id="line-3160">        HRegion r = e.getValue();</span>
<span class="source-line-no">3161</span><span id="line-3161">        if (!r.getRegionInfo().isMetaRegion() &amp;&amp; r.isAvailable()) {</span>
<span class="source-line-no">3162</span><span id="line-3162">          // Don't update zk with this close transition; pass false.</span>
<span class="source-line-no">3163</span><span id="line-3163">          closeRegionIgnoreErrors(r.getRegionInfo(), abort);</span>
<span class="source-line-no">3164</span><span id="line-3164">        }</span>
<span class="source-line-no">3165</span><span id="line-3165">      }</span>
<span class="source-line-no">3166</span><span id="line-3166">    } finally {</span>
<span class="source-line-no">3167</span><span id="line-3167">      this.onlineRegionsLock.writeLock().unlock();</span>
<span class="source-line-no">3168</span><span id="line-3168">    }</span>
<span class="source-line-no">3169</span><span id="line-3169">  }</span>
<span class="source-line-no">3170</span><span id="line-3170"></span>
<span class="source-line-no">3171</span><span id="line-3171">  /** Returns the info server */</span>
<span class="source-line-no">3172</span><span id="line-3172">  public InfoServer getInfoServer() {</span>
<span class="source-line-no">3173</span><span id="line-3173">    return infoServer;</span>
<span class="source-line-no">3174</span><span id="line-3174">  }</span>
<span class="source-line-no">3175</span><span id="line-3175"></span>
<span class="source-line-no">3176</span><span id="line-3176">  /** Returns true if a stop has been requested. */</span>
<span class="source-line-no">3177</span><span id="line-3177">  @Override</span>
<span class="source-line-no">3178</span><span id="line-3178">  public boolean isStopped() {</span>
<span class="source-line-no">3179</span><span id="line-3179">    return this.stopped;</span>
<span class="source-line-no">3180</span><span id="line-3180">  }</span>
<span class="source-line-no">3181</span><span id="line-3181"></span>
<span class="source-line-no">3182</span><span id="line-3182">  @Override</span>
<span class="source-line-no">3183</span><span id="line-3183">  public boolean isStopping() {</span>
<span class="source-line-no">3184</span><span id="line-3184">    return this.stopping;</span>
<span class="source-line-no">3185</span><span id="line-3185">  }</span>
<span class="source-line-no">3186</span><span id="line-3186"></span>
<span class="source-line-no">3187</span><span id="line-3187">  @Override</span>
<span class="source-line-no">3188</span><span id="line-3188">  public Configuration getConfiguration() {</span>
<span class="source-line-no">3189</span><span id="line-3189">    return conf;</span>
<span class="source-line-no">3190</span><span id="line-3190">  }</span>
<span class="source-line-no">3191</span><span id="line-3191"></span>
<span class="source-line-no">3192</span><span id="line-3192">  protected Map&lt;String, HRegion&gt; getOnlineRegions() {</span>
<span class="source-line-no">3193</span><span id="line-3193">    return this.onlineRegions;</span>
<span class="source-line-no">3194</span><span id="line-3194">  }</span>
<span class="source-line-no">3195</span><span id="line-3195"></span>
<span class="source-line-no">3196</span><span id="line-3196">  public int getNumberOfOnlineRegions() {</span>
<span class="source-line-no">3197</span><span id="line-3197">    return this.onlineRegions.size();</span>
<span class="source-line-no">3198</span><span id="line-3198">  }</span>
<span class="source-line-no">3199</span><span id="line-3199"></span>
<span class="source-line-no">3200</span><span id="line-3200">  /**</span>
<span class="source-line-no">3201</span><span id="line-3201">   * For tests, web ui and metrics. This method will only work if HRegionServer is in the same JVM</span>
<span class="source-line-no">3202</span><span id="line-3202">   * as client; HRegion cannot be serialized to cross an rpc.</span>
<span class="source-line-no">3203</span><span id="line-3203">   */</span>
<span class="source-line-no">3204</span><span id="line-3204">  public Collection&lt;HRegion&gt; getOnlineRegionsLocalContext() {</span>
<span class="source-line-no">3205</span><span id="line-3205">    Collection&lt;HRegion&gt; regions = this.onlineRegions.values();</span>
<span class="source-line-no">3206</span><span id="line-3206">    return Collections.unmodifiableCollection(regions);</span>
<span class="source-line-no">3207</span><span id="line-3207">  }</span>
<span class="source-line-no">3208</span><span id="line-3208"></span>
<span class="source-line-no">3209</span><span id="line-3209">  @Override</span>
<span class="source-line-no">3210</span><span id="line-3210">  public void addRegion(HRegion region) {</span>
<span class="source-line-no">3211</span><span id="line-3211">    this.onlineRegions.put(region.getRegionInfo().getEncodedName(), region);</span>
<span class="source-line-no">3212</span><span id="line-3212">    configurationManager.registerObserver(region);</span>
<span class="source-line-no">3213</span><span id="line-3213">  }</span>
<span class="source-line-no">3214</span><span id="line-3214"></span>
<span class="source-line-no">3215</span><span id="line-3215">  /**</span>
<span class="source-line-no">3216</span><span id="line-3216">   * @return A new Map of online regions sorted by region off-heap size with the first entry being</span>
<span class="source-line-no">3217</span><span id="line-3217">   *         the biggest. If two regions are the same size, then the last one found wins; i.e. this</span>
<span class="source-line-no">3218</span><span id="line-3218">   *         method may NOT return all regions.</span>
<span class="source-line-no">3219</span><span id="line-3219">   */</span>
<span class="source-line-no">3220</span><span id="line-3220">  SortedMap&lt;Long, HRegion&gt; getCopyOfOnlineRegionsSortedByOffHeapSize() {</span>
<span class="source-line-no">3221</span><span id="line-3221">    // we'll sort the regions in reverse</span>
<span class="source-line-no">3222</span><span id="line-3222">    SortedMap&lt;Long, HRegion&gt; sortedRegions = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span>
<span class="source-line-no">3223</span><span id="line-3223">    // Copy over all regions. Regions are sorted by size with biggest first.</span>
<span class="source-line-no">3224</span><span id="line-3224">    for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">3225</span><span id="line-3225">      sortedRegions.put(region.getMemStoreOffHeapSize(), region);</span>
<span class="source-line-no">3226</span><span id="line-3226">    }</span>
<span class="source-line-no">3227</span><span id="line-3227">    return sortedRegions;</span>
<span class="source-line-no">3228</span><span id="line-3228">  }</span>
<span class="source-line-no">3229</span><span id="line-3229"></span>
<span class="source-line-no">3230</span><span id="line-3230">  /**</span>
<span class="source-line-no">3231</span><span id="line-3231">   * @return A new Map of online regions sorted by region heap size with the first entry being the</span>
<span class="source-line-no">3232</span><span id="line-3232">   *         biggest. If two regions are the same size, then the last one found wins; i.e. this</span>
<span class="source-line-no">3233</span><span id="line-3233">   *         method may NOT return all regions.</span>
<span class="source-line-no">3234</span><span id="line-3234">   */</span>
<span class="source-line-no">3235</span><span id="line-3235">  SortedMap&lt;Long, HRegion&gt; getCopyOfOnlineRegionsSortedByOnHeapSize() {</span>
<span class="source-line-no">3236</span><span id="line-3236">    // we'll sort the regions in reverse</span>
<span class="source-line-no">3237</span><span id="line-3237">    SortedMap&lt;Long, HRegion&gt; sortedRegions = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span>
<span class="source-line-no">3238</span><span id="line-3238">    // Copy over all regions. Regions are sorted by size with biggest first.</span>
<span class="source-line-no">3239</span><span id="line-3239">    for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">3240</span><span id="line-3240">      sortedRegions.put(region.getMemStoreHeapSize(), region);</span>
<span class="source-line-no">3241</span><span id="line-3241">    }</span>
<span class="source-line-no">3242</span><span id="line-3242">    return sortedRegions;</span>
<span class="source-line-no">3243</span><span id="line-3243">  }</span>
<span class="source-line-no">3244</span><span id="line-3244"></span>
<span class="source-line-no">3245</span><span id="line-3245">  /** Returns time stamp in millis of when this region server was started */</span>
<span class="source-line-no">3246</span><span id="line-3246">  public long getStartcode() {</span>
<span class="source-line-no">3247</span><span id="line-3247">    return this.startcode;</span>
<span class="source-line-no">3248</span><span id="line-3248">  }</span>
<span class="source-line-no">3249</span><span id="line-3249"></span>
<span class="source-line-no">3250</span><span id="line-3250">  /** Returns reference to FlushRequester */</span>
<span class="source-line-no">3251</span><span id="line-3251">  @Override</span>
<span class="source-line-no">3252</span><span id="line-3252">  public FlushRequester getFlushRequester() {</span>
<span class="source-line-no">3253</span><span id="line-3253">    return this.cacheFlusher;</span>
<span class="source-line-no">3254</span><span id="line-3254">  }</span>
<span class="source-line-no">3255</span><span id="line-3255"></span>
<span class="source-line-no">3256</span><span id="line-3256">  @Override</span>
<span class="source-line-no">3257</span><span id="line-3257">  public CompactionRequester getCompactionRequestor() {</span>
<span class="source-line-no">3258</span><span id="line-3258">    return this.compactSplitThread;</span>
<span class="source-line-no">3259</span><span id="line-3259">  }</span>
<span class="source-line-no">3260</span><span id="line-3260"></span>
<span class="source-line-no">3261</span><span id="line-3261">  @Override</span>
<span class="source-line-no">3262</span><span id="line-3262">  public LeaseManager getLeaseManager() {</span>
<span class="source-line-no">3263</span><span id="line-3263">    return leaseManager;</span>
<span class="source-line-no">3264</span><span id="line-3264">  }</span>
<span class="source-line-no">3265</span><span id="line-3265"></span>
<span class="source-line-no">3266</span><span id="line-3266">  /** Returns Return the rootDir. */</span>
<span class="source-line-no">3267</span><span id="line-3267">  protected Path getDataRootDir() {</span>
<span class="source-line-no">3268</span><span id="line-3268">    return dataRootDir;</span>
<span class="source-line-no">3269</span><span id="line-3269">  }</span>
<span class="source-line-no">3270</span><span id="line-3270"></span>
<span class="source-line-no">3271</span><span id="line-3271">  @Override</span>
<span class="source-line-no">3272</span><span id="line-3272">  public FileSystem getFileSystem() {</span>
<span class="source-line-no">3273</span><span id="line-3273">    return dataFs;</span>
<span class="source-line-no">3274</span><span id="line-3274">  }</span>
<span class="source-line-no">3275</span><span id="line-3275"></span>
<span class="source-line-no">3276</span><span id="line-3276">  /** Returns {@code true} when the data file system is available, {@code false} otherwise. */</span>
<span class="source-line-no">3277</span><span id="line-3277">  boolean isDataFileSystemOk() {</span>
<span class="source-line-no">3278</span><span id="line-3278">    return this.dataFsOk;</span>
<span class="source-line-no">3279</span><span id="line-3279">  }</span>
<span class="source-line-no">3280</span><span id="line-3280"></span>
<span class="source-line-no">3281</span><span id="line-3281">  /** Returns Return the walRootDir. */</span>
<span class="source-line-no">3282</span><span id="line-3282">  public Path getWALRootDir() {</span>
<span class="source-line-no">3283</span><span id="line-3283">    return walRootDir;</span>
<span class="source-line-no">3284</span><span id="line-3284">  }</span>
<span class="source-line-no">3285</span><span id="line-3285"></span>
<span class="source-line-no">3286</span><span id="line-3286">  /** Returns Return the walFs. */</span>
<span class="source-line-no">3287</span><span id="line-3287">  public FileSystem getWALFileSystem() {</span>
<span class="source-line-no">3288</span><span id="line-3288">    return walFs;</span>
<span class="source-line-no">3289</span><span id="line-3289">  }</span>
<span class="source-line-no">3290</span><span id="line-3290"></span>
<span class="source-line-no">3291</span><span id="line-3291">  @Override</span>
<span class="source-line-no">3292</span><span id="line-3292">  public String toString() {</span>
<span class="source-line-no">3293</span><span id="line-3293">    return getServerName().toString();</span>
<span class="source-line-no">3294</span><span id="line-3294">  }</span>
<span class="source-line-no">3295</span><span id="line-3295"></span>
<span class="source-line-no">3296</span><span id="line-3296">  @Override</span>
<span class="source-line-no">3297</span><span id="line-3297">  public ZKWatcher getZooKeeper() {</span>
<span class="source-line-no">3298</span><span id="line-3298">    return zooKeeper;</span>
<span class="source-line-no">3299</span><span id="line-3299">  }</span>
<span class="source-line-no">3300</span><span id="line-3300"></span>
<span class="source-line-no">3301</span><span id="line-3301">  @Override</span>
<span class="source-line-no">3302</span><span id="line-3302">  public CoordinatedStateManager getCoordinatedStateManager() {</span>
<span class="source-line-no">3303</span><span id="line-3303">    return csm;</span>
<span class="source-line-no">3304</span><span id="line-3304">  }</span>
<span class="source-line-no">3305</span><span id="line-3305"></span>
<span class="source-line-no">3306</span><span id="line-3306">  @Override</span>
<span class="source-line-no">3307</span><span id="line-3307">  public ServerName getServerName() {</span>
<span class="source-line-no">3308</span><span id="line-3308">    return serverName;</span>
<span class="source-line-no">3309</span><span id="line-3309">  }</span>
<span class="source-line-no">3310</span><span id="line-3310"></span>
<span class="source-line-no">3311</span><span id="line-3311">  public RegionServerCoprocessorHost getRegionServerCoprocessorHost() {</span>
<span class="source-line-no">3312</span><span id="line-3312">    return this.rsHost;</span>
<span class="source-line-no">3313</span><span id="line-3313">  }</span>
<span class="source-line-no">3314</span><span id="line-3314"></span>
<span class="source-line-no">3315</span><span id="line-3315">  @Override</span>
<span class="source-line-no">3316</span><span id="line-3316">  public ConcurrentMap&lt;byte[], Boolean&gt; getRegionsInTransitionInRS() {</span>
<span class="source-line-no">3317</span><span id="line-3317">    return this.regionsInTransitionInRS;</span>
<span class="source-line-no">3318</span><span id="line-3318">  }</span>
<span class="source-line-no">3319</span><span id="line-3319"></span>
<span class="source-line-no">3320</span><span id="line-3320">  @Override</span>
<span class="source-line-no">3321</span><span id="line-3321">  public ExecutorService getExecutorService() {</span>
<span class="source-line-no">3322</span><span id="line-3322">    return executorService;</span>
<span class="source-line-no">3323</span><span id="line-3323">  }</span>
<span class="source-line-no">3324</span><span id="line-3324"></span>
<span class="source-line-no">3325</span><span id="line-3325">  @Override</span>
<span class="source-line-no">3326</span><span id="line-3326">  public ChoreService getChoreService() {</span>
<span class="source-line-no">3327</span><span id="line-3327">    return choreService;</span>
<span class="source-line-no">3328</span><span id="line-3328">  }</span>
<span class="source-line-no">3329</span><span id="line-3329"></span>
<span class="source-line-no">3330</span><span id="line-3330">  @Override</span>
<span class="source-line-no">3331</span><span id="line-3331">  public RegionServerRpcQuotaManager getRegionServerRpcQuotaManager() {</span>
<span class="source-line-no">3332</span><span id="line-3332">    return rsQuotaManager;</span>
<span class="source-line-no">3333</span><span id="line-3333">  }</span>
<span class="source-line-no">3334</span><span id="line-3334"></span>
<span class="source-line-no">3335</span><span id="line-3335">  //</span>
<span class="source-line-no">3336</span><span id="line-3336">  // Main program and support routines</span>
<span class="source-line-no">3337</span><span id="line-3337">  //</span>
<span class="source-line-no">3338</span><span id="line-3338">  /**</span>
<span class="source-line-no">3339</span><span id="line-3339">   * Load the replication executorService objects, if any</span>
<span class="source-line-no">3340</span><span id="line-3340">   */</span>
<span class="source-line-no">3341</span><span id="line-3341">  private static void createNewReplicationInstance(Configuration conf, HRegionServer server,</span>
<span class="source-line-no">3342</span><span id="line-3342">    FileSystem walFs, Path walDir, Path oldWALDir, WALFactory walFactory) throws IOException {</span>
<span class="source-line-no">3343</span><span id="line-3343">    if (</span>
<span class="source-line-no">3344</span><span id="line-3344">      (server instanceof HMaster)</span>
<span class="source-line-no">3345</span><span id="line-3345">        &amp;&amp; (!LoadBalancer.isTablesOnMaster(conf) || LoadBalancer.isSystemTablesOnlyOnMaster(conf))</span>
<span class="source-line-no">3346</span><span id="line-3346">    ) {</span>
<span class="source-line-no">3347</span><span id="line-3347">      return;</span>
<span class="source-line-no">3348</span><span id="line-3348">    }</span>
<span class="source-line-no">3349</span><span id="line-3349">    // read in the name of the source replication class from the config file.</span>
<span class="source-line-no">3350</span><span id="line-3350">    String sourceClassname = conf.get(HConstants.REPLICATION_SOURCE_SERVICE_CLASSNAME,</span>
<span class="source-line-no">3351</span><span id="line-3351">      HConstants.REPLICATION_SERVICE_CLASSNAME_DEFAULT);</span>
<span class="source-line-no">3352</span><span id="line-3352"></span>
<span class="source-line-no">3353</span><span id="line-3353">    // read in the name of the sink replication class from the config file.</span>
<span class="source-line-no">3354</span><span id="line-3354">    String sinkClassname = conf.get(HConstants.REPLICATION_SINK_SERVICE_CLASSNAME,</span>
<span class="source-line-no">3355</span><span id="line-3355">      HConstants.REPLICATION_SERVICE_CLASSNAME_DEFAULT);</span>
<span class="source-line-no">3356</span><span id="line-3356"></span>
<span class="source-line-no">3357</span><span id="line-3357">    // If both the sink and the source class names are the same, then instantiate</span>
<span class="source-line-no">3358</span><span id="line-3358">    // only one object.</span>
<span class="source-line-no">3359</span><span id="line-3359">    if (sourceClassname.equals(sinkClassname)) {</span>
<span class="source-line-no">3360</span><span id="line-3360">      server.replicationSourceHandler = newReplicationInstance(sourceClassname,</span>
<span class="source-line-no">3361</span><span id="line-3361">        ReplicationSourceService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">3362</span><span id="line-3362">      server.replicationSinkHandler = (ReplicationSinkService) server.replicationSourceHandler;</span>
<span class="source-line-no">3363</span><span id="line-3363">    } else {</span>
<span class="source-line-no">3364</span><span id="line-3364">      server.replicationSourceHandler = newReplicationInstance(sourceClassname,</span>
<span class="source-line-no">3365</span><span id="line-3365">        ReplicationSourceService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">3366</span><span id="line-3366">      server.replicationSinkHandler = newReplicationInstance(sinkClassname,</span>
<span class="source-line-no">3367</span><span id="line-3367">        ReplicationSinkService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">3368</span><span id="line-3368">    }</span>
<span class="source-line-no">3369</span><span id="line-3369">  }</span>
<span class="source-line-no">3370</span><span id="line-3370"></span>
<span class="source-line-no">3371</span><span id="line-3371">  private static &lt;T extends ReplicationService&gt; T newReplicationInstance(String classname,</span>
<span class="source-line-no">3372</span><span id="line-3372">    Class&lt;T&gt; xface, Configuration conf, HRegionServer server, FileSystem walFs, Path logDir,</span>
<span class="source-line-no">3373</span><span id="line-3373">    Path oldLogDir, WALFactory walFactory) throws IOException {</span>
<span class="source-line-no">3374</span><span id="line-3374">    final Class&lt;? extends T&gt; clazz;</span>
<span class="source-line-no">3375</span><span id="line-3375">    try {</span>
<span class="source-line-no">3376</span><span id="line-3376">      ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="source-line-no">3377</span><span id="line-3377">      clazz = Class.forName(classname, true, classLoader).asSubclass(xface);</span>
<span class="source-line-no">3378</span><span id="line-3378">    } catch (java.lang.ClassNotFoundException nfe) {</span>
<span class="source-line-no">3379</span><span id="line-3379">      throw new IOException("Could not find class for " + classname);</span>
<span class="source-line-no">3380</span><span id="line-3380">    }</span>
<span class="source-line-no">3381</span><span id="line-3381">    T service = ReflectionUtils.newInstance(clazz, conf);</span>
<span class="source-line-no">3382</span><span id="line-3382">    service.initialize(server, walFs, logDir, oldLogDir, walFactory);</span>
<span class="source-line-no">3383</span><span id="line-3383">    return service;</span>
<span class="source-line-no">3384</span><span id="line-3384">  }</span>
<span class="source-line-no">3385</span><span id="line-3385"></span>
<span class="source-line-no">3386</span><span id="line-3386">  public Map&lt;String, ReplicationStatus&gt; getWalGroupsReplicationStatus() {</span>
<span class="source-line-no">3387</span><span id="line-3387">    Map&lt;String, ReplicationStatus&gt; walGroupsReplicationStatus = new TreeMap&lt;&gt;();</span>
<span class="source-line-no">3388</span><span id="line-3388">    if (!this.isOnline()) {</span>
<span class="source-line-no">3389</span><span id="line-3389">      return walGroupsReplicationStatus;</span>
<span class="source-line-no">3390</span><span id="line-3390">    }</span>
<span class="source-line-no">3391</span><span id="line-3391">    List&lt;ReplicationSourceInterface&gt; allSources = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3392</span><span id="line-3392">    allSources.addAll(replicationSourceHandler.getReplicationManager().getSources());</span>
<span class="source-line-no">3393</span><span id="line-3393">    allSources.addAll(replicationSourceHandler.getReplicationManager().getOldSources());</span>
<span class="source-line-no">3394</span><span id="line-3394">    for (ReplicationSourceInterface source : allSources) {</span>
<span class="source-line-no">3395</span><span id="line-3395">      walGroupsReplicationStatus.putAll(source.getWalGroupStatus());</span>
<span class="source-line-no">3396</span><span id="line-3396">    }</span>
<span class="source-line-no">3397</span><span id="line-3397">    return walGroupsReplicationStatus;</span>
<span class="source-line-no">3398</span><span id="line-3398">  }</span>
<span class="source-line-no">3399</span><span id="line-3399"></span>
<span class="source-line-no">3400</span><span id="line-3400">  /**</span>
<span class="source-line-no">3401</span><span id="line-3401">   * Utility for constructing an instance of the passed HRegionServer class.</span>
<span class="source-line-no">3402</span><span id="line-3402">   */</span>
<span class="source-line-no">3403</span><span id="line-3403">  static HRegionServer constructRegionServer(final Class&lt;? extends HRegionServer&gt; regionServerClass,</span>
<span class="source-line-no">3404</span><span id="line-3404">    final Configuration conf) {</span>
<span class="source-line-no">3405</span><span id="line-3405">    try {</span>
<span class="source-line-no">3406</span><span id="line-3406">      Constructor&lt;? extends HRegionServer&gt; c =</span>
<span class="source-line-no">3407</span><span id="line-3407">        regionServerClass.getConstructor(Configuration.class);</span>
<span class="source-line-no">3408</span><span id="line-3408">      return c.newInstance(conf);</span>
<span class="source-line-no">3409</span><span id="line-3409">    } catch (Exception e) {</span>
<span class="source-line-no">3410</span><span id="line-3410">      throw new RuntimeException(</span>
<span class="source-line-no">3411</span><span id="line-3411">        "Failed construction of " + "Regionserver: " + regionServerClass.toString(), e);</span>
<span class="source-line-no">3412</span><span id="line-3412">    }</span>
<span class="source-line-no">3413</span><span id="line-3413">  }</span>
<span class="source-line-no">3414</span><span id="line-3414"></span>
<span class="source-line-no">3415</span><span id="line-3415">  /**</span>
<span class="source-line-no">3416</span><span id="line-3416">   * @see org.apache.hadoop.hbase.regionserver.HRegionServerCommandLine</span>
<span class="source-line-no">3417</span><span id="line-3417">   */</span>
<span class="source-line-no">3418</span><span id="line-3418">  public static void main(String[] args) {</span>
<span class="source-line-no">3419</span><span id="line-3419">    LOG.info("STARTING executorService " + HRegionServer.class.getSimpleName());</span>
<span class="source-line-no">3420</span><span id="line-3420">    VersionInfo.logVersion();</span>
<span class="source-line-no">3421</span><span id="line-3421">    Configuration conf = HBaseConfiguration.create();</span>
<span class="source-line-no">3422</span><span id="line-3422">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">3423</span><span id="line-3423">    Class&lt;? extends HRegionServer&gt; regionServerClass = (Class&lt;? extends HRegionServer&gt;) conf</span>
<span class="source-line-no">3424</span><span id="line-3424">      .getClass(HConstants.REGION_SERVER_IMPL, HRegionServer.class);</span>
<span class="source-line-no">3425</span><span id="line-3425"></span>
<span class="source-line-no">3426</span><span id="line-3426">    new HRegionServerCommandLine(regionServerClass).doMain(args);</span>
<span class="source-line-no">3427</span><span id="line-3427">  }</span>
<span class="source-line-no">3428</span><span id="line-3428"></span>
<span class="source-line-no">3429</span><span id="line-3429">  /**</span>
<span class="source-line-no">3430</span><span id="line-3430">   * Gets the online regions of the specified table. This method looks at the in-memory</span>
<span class="source-line-no">3431</span><span id="line-3431">   * onlineRegions. It does not go to &lt;code&gt;hbase:meta&lt;/code&gt;. Only returns &lt;em&gt;online&lt;/em&gt; regions.</span>
<span class="source-line-no">3432</span><span id="line-3432">   * If a region on this table has been closed during a disable, etc., it will not be included in</span>
<span class="source-line-no">3433</span><span id="line-3433">   * the returned list. So, the returned list may not necessarily be ALL regions in this table, its</span>
<span class="source-line-no">3434</span><span id="line-3434">   * all the ONLINE regions in the table.</span>
<span class="source-line-no">3435</span><span id="line-3435">   * @param tableName table to limit the scope of the query</span>
<span class="source-line-no">3436</span><span id="line-3436">   * @return Online regions from &lt;code&gt;tableName&lt;/code&gt;</span>
<span class="source-line-no">3437</span><span id="line-3437">   */</span>
<span class="source-line-no">3438</span><span id="line-3438">  @Override</span>
<span class="source-line-no">3439</span><span id="line-3439">  public List&lt;HRegion&gt; getRegions(TableName tableName) {</span>
<span class="source-line-no">3440</span><span id="line-3440">    List&lt;HRegion&gt; tableRegions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">3441</span><span id="line-3441">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">3442</span><span id="line-3442">      for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">3443</span><span id="line-3443">        RegionInfo regionInfo = region.getRegionInfo();</span>
<span class="source-line-no">3444</span><span id="line-3444">        if (regionInfo.getTable().equals(tableName)) {</span>
<span class="source-line-no">3445</span><span id="line-3445">          tableRegions.add(region);</span>
<span class="source-line-no">3446</span><span id="line-3446">        }</span>
<span class="source-line-no">3447</span><span id="line-3447">      }</span>
<span class="source-line-no">3448</span><span id="line-3448">    }</span>
<span class="source-line-no">3449</span><span id="line-3449">    return tableRegions;</span>
<span class="source-line-no">3450</span><span id="line-3450">  }</span>
<span class="source-line-no">3451</span><span id="line-3451"></span>
<span class="source-line-no">3452</span><span id="line-3452">  @Override</span>
<span class="source-line-no">3453</span><span id="line-3453">  public List&lt;HRegion&gt; getRegions() {</span>
<span class="source-line-no">3454</span><span id="line-3454">    List&lt;HRegion&gt; allRegions;</span>
<span class="source-line-no">3455</span><span id="line-3455">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">3456</span><span id="line-3456">      // Return a clone copy of the onlineRegions</span>
<span class="source-line-no">3457</span><span id="line-3457">      allRegions = new ArrayList&lt;&gt;(onlineRegions.values());</span>
<span class="source-line-no">3458</span><span id="line-3458">    }</span>
<span class="source-line-no">3459</span><span id="line-3459">    return allRegions;</span>
<span class="source-line-no">3460</span><span id="line-3460">  }</span>
<span class="source-line-no">3461</span><span id="line-3461"></span>
<span class="source-line-no">3462</span><span id="line-3462">  /**</span>
<span class="source-line-no">3463</span><span id="line-3463">   * Gets the online tables in this RS. This method looks at the in-memory onlineRegions.</span>
<span class="source-line-no">3464</span><span id="line-3464">   * @return all the online tables in this RS</span>
<span class="source-line-no">3465</span><span id="line-3465">   */</span>
<span class="source-line-no">3466</span><span id="line-3466">  public Set&lt;TableName&gt; getOnlineTables() {</span>
<span class="source-line-no">3467</span><span id="line-3467">    Set&lt;TableName&gt; tables = new HashSet&lt;&gt;();</span>
<span class="source-line-no">3468</span><span id="line-3468">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">3469</span><span id="line-3469">      for (Region region : this.onlineRegions.values()) {</span>
<span class="source-line-no">3470</span><span id="line-3470">        tables.add(region.getTableDescriptor().getTableName());</span>
<span class="source-line-no">3471</span><span id="line-3471">      }</span>
<span class="source-line-no">3472</span><span id="line-3472">    }</span>
<span class="source-line-no">3473</span><span id="line-3473">    return tables;</span>
<span class="source-line-no">3474</span><span id="line-3474">  }</span>
<span class="source-line-no">3475</span><span id="line-3475"></span>
<span class="source-line-no">3476</span><span id="line-3476">  public String[] getRegionServerCoprocessors() {</span>
<span class="source-line-no">3477</span><span id="line-3477">    TreeSet&lt;String&gt; coprocessors = new TreeSet&lt;&gt;();</span>
<span class="source-line-no">3478</span><span id="line-3478">    try {</span>
<span class="source-line-no">3479</span><span id="line-3479">      coprocessors.addAll(getWAL(null).getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">3480</span><span id="line-3480">    } catch (IOException exception) {</span>
<span class="source-line-no">3481</span><span id="line-3481">      LOG.warn("Exception attempting to fetch wal coprocessor information for the common wal; "</span>
<span class="source-line-no">3482</span><span id="line-3482">        + "skipping.");</span>
<span class="source-line-no">3483</span><span id="line-3483">      LOG.debug("Exception details for failure to fetch wal coprocessor information.", exception);</span>
<span class="source-line-no">3484</span><span id="line-3484">    }</span>
<span class="source-line-no">3485</span><span id="line-3485">    Collection&lt;HRegion&gt; regions = getOnlineRegionsLocalContext();</span>
<span class="source-line-no">3486</span><span id="line-3486">    for (HRegion region : regions) {</span>
<span class="source-line-no">3487</span><span id="line-3487">      coprocessors.addAll(region.getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">3488</span><span id="line-3488">      try {</span>
<span class="source-line-no">3489</span><span id="line-3489">        coprocessors.addAll(getWAL(region.getRegionInfo()).getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">3490</span><span id="line-3490">      } catch (IOException exception) {</span>
<span class="source-line-no">3491</span><span id="line-3491">        LOG.warn("Exception attempting to fetch wal coprocessor information for region " + region</span>
<span class="source-line-no">3492</span><span id="line-3492">          + "; skipping.");</span>
<span class="source-line-no">3493</span><span id="line-3493">        LOG.debug("Exception details for failure to fetch wal coprocessor information.", exception);</span>
<span class="source-line-no">3494</span><span id="line-3494">      }</span>
<span class="source-line-no">3495</span><span id="line-3495">    }</span>
<span class="source-line-no">3496</span><span id="line-3496">    coprocessors.addAll(rsHost.getCoprocessors());</span>
<span class="source-line-no">3497</span><span id="line-3497">    return coprocessors.toArray(new String[0]);</span>
<span class="source-line-no">3498</span><span id="line-3498">  }</span>
<span class="source-line-no">3499</span><span id="line-3499"></span>
<span class="source-line-no">3500</span><span id="line-3500">  /**</span>
<span class="source-line-no">3501</span><span id="line-3501">   * Try to close the region, logs a warning on failure but continues.</span>
<span class="source-line-no">3502</span><span id="line-3502">   * @param region Region to close</span>
<span class="source-line-no">3503</span><span id="line-3503">   */</span>
<span class="source-line-no">3504</span><span id="line-3504">  private void closeRegionIgnoreErrors(RegionInfo region, final boolean abort) {</span>
<span class="source-line-no">3505</span><span id="line-3505">    try {</span>
<span class="source-line-no">3506</span><span id="line-3506">      if (!closeRegion(region.getEncodedName(), abort, null)) {</span>
<span class="source-line-no">3507</span><span id="line-3507">        LOG</span>
<span class="source-line-no">3508</span><span id="line-3508">          .warn("Failed to close " + region.getRegionNameAsString() + " - ignoring and continuing");</span>
<span class="source-line-no">3509</span><span id="line-3509">      }</span>
<span class="source-line-no">3510</span><span id="line-3510">    } catch (IOException e) {</span>
<span class="source-line-no">3511</span><span id="line-3511">      LOG.warn("Failed to close " + region.getRegionNameAsString() + " - ignoring and continuing",</span>
<span class="source-line-no">3512</span><span id="line-3512">        e);</span>
<span class="source-line-no">3513</span><span id="line-3513">    }</span>
<span class="source-line-no">3514</span><span id="line-3514">  }</span>
<span class="source-line-no">3515</span><span id="line-3515"></span>
<span class="source-line-no">3516</span><span id="line-3516">  /**</span>
<span class="source-line-no">3517</span><span id="line-3517">   * Close asynchronously a region, can be called from the master or internally by the regionserver</span>
<span class="source-line-no">3518</span><span id="line-3518">   * when stopping. If called from the master, the region will update the status.</span>
<span class="source-line-no">3519</span><span id="line-3519">   * &lt;p&gt;</span>
<span class="source-line-no">3520</span><span id="line-3520">   * If an opening was in progress, this method will cancel it, but will not start a new close. The</span>
<span class="source-line-no">3521</span><span id="line-3521">   * coprocessors are not called in this case. A NotServingRegionException exception is thrown.</span>
<span class="source-line-no">3522</span><span id="line-3522">   * &lt;/p&gt;</span>
<span class="source-line-no">3523</span><span id="line-3523">   * &lt;p&gt;</span>
<span class="source-line-no">3524</span><span id="line-3524">   * If a close was in progress, this new request will be ignored, and an exception thrown.</span>
<span class="source-line-no">3525</span><span id="line-3525">   * &lt;/p&gt;</span>
<span class="source-line-no">3526</span><span id="line-3526">   * &lt;p&gt;</span>
<span class="source-line-no">3527</span><span id="line-3527">   * Provides additional flag to indicate if this region blocks should be evicted from the cache.</span>
<span class="source-line-no">3528</span><span id="line-3528">   * &lt;/p&gt;</span>
<span class="source-line-no">3529</span><span id="line-3529">   * @param encodedName Region to close</span>
<span class="source-line-no">3530</span><span id="line-3530">   * @param abort       True if we are aborting</span>
<span class="source-line-no">3531</span><span id="line-3531">   * @param destination Where the Region is being moved too... maybe null if unknown.</span>
<span class="source-line-no">3532</span><span id="line-3532">   * @return True if closed a region.</span>
<span class="source-line-no">3533</span><span id="line-3533">   * @throws NotServingRegionException if the region is not online</span>
<span class="source-line-no">3534</span><span id="line-3534">   */</span>
<span class="source-line-no">3535</span><span id="line-3535">  protected boolean closeRegion(String encodedName, final boolean abort,</span>
<span class="source-line-no">3536</span><span id="line-3536">    final ServerName destination) throws NotServingRegionException {</span>
<span class="source-line-no">3537</span><span id="line-3537">    // Check for permissions to close.</span>
<span class="source-line-no">3538</span><span id="line-3538">    HRegion actualRegion = this.getRegion(encodedName);</span>
<span class="source-line-no">3539</span><span id="line-3539">    // Can be null if we're calling close on a region that's not online</span>
<span class="source-line-no">3540</span><span id="line-3540">    if ((actualRegion != null) &amp;&amp; (actualRegion.getCoprocessorHost() != null)) {</span>
<span class="source-line-no">3541</span><span id="line-3541">      try {</span>
<span class="source-line-no">3542</span><span id="line-3542">        actualRegion.getCoprocessorHost().preClose(false);</span>
<span class="source-line-no">3543</span><span id="line-3543">      } catch (IOException exp) {</span>
<span class="source-line-no">3544</span><span id="line-3544">        LOG.warn("Unable to close region: the coprocessor launched an error ", exp);</span>
<span class="source-line-no">3545</span><span id="line-3545">        return false;</span>
<span class="source-line-no">3546</span><span id="line-3546">      }</span>
<span class="source-line-no">3547</span><span id="line-3547">    }</span>
<span class="source-line-no">3548</span><span id="line-3548"></span>
<span class="source-line-no">3549</span><span id="line-3549">    // previous can come back 'null' if not in map.</span>
<span class="source-line-no">3550</span><span id="line-3550">    final Boolean previous =</span>
<span class="source-line-no">3551</span><span id="line-3551">      this.regionsInTransitionInRS.putIfAbsent(Bytes.toBytes(encodedName), Boolean.FALSE);</span>
<span class="source-line-no">3552</span><span id="line-3552"></span>
<span class="source-line-no">3553</span><span id="line-3553">    if (Boolean.TRUE.equals(previous)) {</span>
<span class="source-line-no">3554</span><span id="line-3554">      LOG.info("Received CLOSE for the region:" + encodedName + " , which we are already "</span>
<span class="source-line-no">3555</span><span id="line-3555">        + "trying to OPEN. Cancelling OPENING.");</span>
<span class="source-line-no">3556</span><span id="line-3556">      if (!regionsInTransitionInRS.replace(Bytes.toBytes(encodedName), previous, Boolean.FALSE)) {</span>
<span class="source-line-no">3557</span><span id="line-3557">        // The replace failed. That should be an exceptional case, but theoretically it can happen.</span>
<span class="source-line-no">3558</span><span id="line-3558">        // We're going to try to do a standard close then.</span>
<span class="source-line-no">3559</span><span id="line-3559">        LOG.warn("The opening for region " + encodedName + " was done before we could cancel it."</span>
<span class="source-line-no">3560</span><span id="line-3560">          + " Doing a standard close now");</span>
<span class="source-line-no">3561</span><span id="line-3561">        return closeRegion(encodedName, abort, destination);</span>
<span class="source-line-no">3562</span><span id="line-3562">      }</span>
<span class="source-line-no">3563</span><span id="line-3563">      // Let's get the region from the online region list again</span>
<span class="source-line-no">3564</span><span id="line-3564">      actualRegion = this.getRegion(encodedName);</span>
<span class="source-line-no">3565</span><span id="line-3565">      if (actualRegion == null) { // If already online, we still need to close it.</span>
<span class="source-line-no">3566</span><span id="line-3566">        LOG.info("The opening previously in progress has been cancelled by a CLOSE request.");</span>
<span class="source-line-no">3567</span><span id="line-3567">        // The master deletes the znode when it receives this exception.</span>
<span class="source-line-no">3568</span><span id="line-3568">        throw new NotServingRegionException(</span>
<span class="source-line-no">3569</span><span id="line-3569">          "The region " + encodedName + " was opening but not yet served. Opening is cancelled.");</span>
<span class="source-line-no">3570</span><span id="line-3570">      }</span>
<span class="source-line-no">3571</span><span id="line-3571">    } else if (previous == null) {</span>
<span class="source-line-no">3572</span><span id="line-3572">      LOG.info("Received CLOSE for {}", encodedName);</span>
<span class="source-line-no">3573</span><span id="line-3573">    } else if (Boolean.FALSE.equals(previous)) {</span>
<span class="source-line-no">3574</span><span id="line-3574">      LOG.info("Received CLOSE for the region: " + encodedName</span>
<span class="source-line-no">3575</span><span id="line-3575">        + ", which we are already trying to CLOSE, but not completed yet");</span>
<span class="source-line-no">3576</span><span id="line-3576">      return true;</span>
<span class="source-line-no">3577</span><span id="line-3577">    }</span>
<span class="source-line-no">3578</span><span id="line-3578"></span>
<span class="source-line-no">3579</span><span id="line-3579">    if (actualRegion == null) {</span>
<span class="source-line-no">3580</span><span id="line-3580">      LOG.debug("Received CLOSE for a region which is not online, and we're not opening.");</span>
<span class="source-line-no">3581</span><span id="line-3581">      this.regionsInTransitionInRS.remove(Bytes.toBytes(encodedName));</span>
<span class="source-line-no">3582</span><span id="line-3582">      // The master deletes the znode when it receives this exception.</span>
<span class="source-line-no">3583</span><span id="line-3583">      throw new NotServingRegionException(</span>
<span class="source-line-no">3584</span><span id="line-3584">        "The region " + encodedName + " is not online, and is not opening.");</span>
<span class="source-line-no">3585</span><span id="line-3585">    }</span>
<span class="source-line-no">3586</span><span id="line-3586"></span>
<span class="source-line-no">3587</span><span id="line-3587">    CloseRegionHandler crh;</span>
<span class="source-line-no">3588</span><span id="line-3588">    final RegionInfo hri = actualRegion.getRegionInfo();</span>
<span class="source-line-no">3589</span><span id="line-3589">    if (hri.isMetaRegion()) {</span>
<span class="source-line-no">3590</span><span id="line-3590">      crh = new CloseMetaHandler(this, this, hri, abort);</span>
<span class="source-line-no">3591</span><span id="line-3591">    } else {</span>
<span class="source-line-no">3592</span><span id="line-3592">      crh = new CloseRegionHandler(this, this, hri, abort, destination);</span>
<span class="source-line-no">3593</span><span id="line-3593">    }</span>
<span class="source-line-no">3594</span><span id="line-3594">    this.executorService.submit(crh);</span>
<span class="source-line-no">3595</span><span id="line-3595">    return true;</span>
<span class="source-line-no">3596</span><span id="line-3596">  }</span>
<span class="source-line-no">3597</span><span id="line-3597"></span>
<span class="source-line-no">3598</span><span id="line-3598">  /**</span>
<span class="source-line-no">3599</span><span id="line-3599">   * @return HRegion for the passed binary &lt;code&gt;regionName&lt;/code&gt; or null if named region is not</span>
<span class="source-line-no">3600</span><span id="line-3600">   *         member of the online regions.</span>
<span class="source-line-no">3601</span><span id="line-3601">   */</span>
<span class="source-line-no">3602</span><span id="line-3602">  public HRegion getOnlineRegion(final byte[] regionName) {</span>
<span class="source-line-no">3603</span><span id="line-3603">    String encodedRegionName = RegionInfo.encodeRegionName(regionName);</span>
<span class="source-line-no">3604</span><span id="line-3604">    return this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3605</span><span id="line-3605">  }</span>
<span class="source-line-no">3606</span><span id="line-3606"></span>
<span class="source-line-no">3607</span><span id="line-3607">  @Override</span>
<span class="source-line-no">3608</span><span id="line-3608">  public HRegion getRegion(final String encodedRegionName) {</span>
<span class="source-line-no">3609</span><span id="line-3609">    return this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3610</span><span id="line-3610">  }</span>
<span class="source-line-no">3611</span><span id="line-3611"></span>
<span class="source-line-no">3612</span><span id="line-3612">  @Override</span>
<span class="source-line-no">3613</span><span id="line-3613">  public boolean removeRegion(final HRegion r, ServerName destination) {</span>
<span class="source-line-no">3614</span><span id="line-3614">    HRegion toReturn = this.onlineRegions.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3615</span><span id="line-3615">    metricsRegionServerImpl.requestsCountCache.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3616</span><span id="line-3616">    if (destination != null) {</span>
<span class="source-line-no">3617</span><span id="line-3617">      long closeSeqNum = r.getMaxFlushedSeqId();</span>
<span class="source-line-no">3618</span><span id="line-3618">      if (closeSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">3619</span><span id="line-3619">        // No edits in WAL for this region; get the sequence number when the region was opened.</span>
<span class="source-line-no">3620</span><span id="line-3620">        closeSeqNum = r.getOpenSeqNum();</span>
<span class="source-line-no">3621</span><span id="line-3621">        if (closeSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">3622</span><span id="line-3622">          closeSeqNum = 0;</span>
<span class="source-line-no">3623</span><span id="line-3623">        }</span>
<span class="source-line-no">3624</span><span id="line-3624">      }</span>
<span class="source-line-no">3625</span><span id="line-3625">      boolean selfMove = ServerName.isSameAddress(destination, this.getServerName());</span>
<span class="source-line-no">3626</span><span id="line-3626">      addToMovedRegions(r.getRegionInfo().getEncodedName(), destination, closeSeqNum, selfMove);</span>
<span class="source-line-no">3627</span><span id="line-3627">      if (selfMove) {</span>
<span class="source-line-no">3628</span><span id="line-3628">        this.regionServerAccounting.getRetainedRegionRWRequestsCnt().put(</span>
<span class="source-line-no">3629</span><span id="line-3629">          r.getRegionInfo().getEncodedName(),</span>
<span class="source-line-no">3630</span><span id="line-3630">          new Pair&lt;&gt;(r.getReadRequestsCount(), r.getWriteRequestsCount()));</span>
<span class="source-line-no">3631</span><span id="line-3631">      }</span>
<span class="source-line-no">3632</span><span id="line-3632">    }</span>
<span class="source-line-no">3633</span><span id="line-3633">    this.regionFavoredNodesMap.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3634</span><span id="line-3634">    return toReturn != null;</span>
<span class="source-line-no">3635</span><span id="line-3635">  }</span>
<span class="source-line-no">3636</span><span id="line-3636"></span>
<span class="source-line-no">3637</span><span id="line-3637">  /**</span>
<span class="source-line-no">3638</span><span id="line-3638">   * Protected Utility method for safely obtaining an HRegion handle.</span>
<span class="source-line-no">3639</span><span id="line-3639">   * @param regionName Name of online {@link HRegion} to return</span>
<span class="source-line-no">3640</span><span id="line-3640">   * @return {@link HRegion} for &lt;code&gt;regionName&lt;/code&gt;</span>
<span class="source-line-no">3641</span><span id="line-3641">   */</span>
<span class="source-line-no">3642</span><span id="line-3642">  protected HRegion getRegion(final byte[] regionName) throws NotServingRegionException {</span>
<span class="source-line-no">3643</span><span id="line-3643">    String encodedRegionName = RegionInfo.encodeRegionName(regionName);</span>
<span class="source-line-no">3644</span><span id="line-3644">    return getRegionByEncodedName(regionName, encodedRegionName);</span>
<span class="source-line-no">3645</span><span id="line-3645">  }</span>
<span class="source-line-no">3646</span><span id="line-3646"></span>
<span class="source-line-no">3647</span><span id="line-3647">  public HRegion getRegionByEncodedName(String encodedRegionName) throws NotServingRegionException {</span>
<span class="source-line-no">3648</span><span id="line-3648">    return getRegionByEncodedName(null, encodedRegionName);</span>
<span class="source-line-no">3649</span><span id="line-3649">  }</span>
<span class="source-line-no">3650</span><span id="line-3650"></span>
<span class="source-line-no">3651</span><span id="line-3651">  private HRegion getRegionByEncodedName(byte[] regionName, String encodedRegionName)</span>
<span class="source-line-no">3652</span><span id="line-3652">    throws NotServingRegionException {</span>
<span class="source-line-no">3653</span><span id="line-3653">    HRegion region = this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3654</span><span id="line-3654">    if (region == null) {</span>
<span class="source-line-no">3655</span><span id="line-3655">      MovedRegionInfo moveInfo = getMovedRegion(encodedRegionName);</span>
<span class="source-line-no">3656</span><span id="line-3656">      if (moveInfo != null) {</span>
<span class="source-line-no">3657</span><span id="line-3657">        throw new RegionMovedException(moveInfo.getServerName(), moveInfo.getSeqNum());</span>
<span class="source-line-no">3658</span><span id="line-3658">      }</span>
<span class="source-line-no">3659</span><span id="line-3659">      Boolean isOpening = this.regionsInTransitionInRS.get(Bytes.toBytes(encodedRegionName));</span>
<span class="source-line-no">3660</span><span id="line-3660">      String regionNameStr =</span>
<span class="source-line-no">3661</span><span id="line-3661">        regionName == null ? encodedRegionName : Bytes.toStringBinary(regionName);</span>
<span class="source-line-no">3662</span><span id="line-3662">      if (isOpening != null &amp;&amp; isOpening) {</span>
<span class="source-line-no">3663</span><span id="line-3663">        throw new RegionOpeningException(</span>
<span class="source-line-no">3664</span><span id="line-3664">          "Region " + regionNameStr + " is opening on " + this.serverName);</span>
<span class="source-line-no">3665</span><span id="line-3665">      }</span>
<span class="source-line-no">3666</span><span id="line-3666">      throw new NotServingRegionException(</span>
<span class="source-line-no">3667</span><span id="line-3667">        "" + regionNameStr + " is not online on " + this.serverName);</span>
<span class="source-line-no">3668</span><span id="line-3668">    }</span>
<span class="source-line-no">3669</span><span id="line-3669">    return region;</span>
<span class="source-line-no">3670</span><span id="line-3670">  }</span>
<span class="source-line-no">3671</span><span id="line-3671"></span>
<span class="source-line-no">3672</span><span id="line-3672">  /**</span>
<span class="source-line-no">3673</span><span id="line-3673">   * Cleanup after Throwable caught invoking method. Converts &lt;code&gt;t&lt;/code&gt; to IOE if it isn't</span>
<span class="source-line-no">3674</span><span id="line-3674">   * already.</span>
<span class="source-line-no">3675</span><span id="line-3675">   * @param t   Throwable</span>
<span class="source-line-no">3676</span><span id="line-3676">   * @param msg Message to log in error. Can be null.</span>
<span class="source-line-no">3677</span><span id="line-3677">   * @return Throwable converted to an IOE; methods can only let out IOEs.</span>
<span class="source-line-no">3678</span><span id="line-3678">   */</span>
<span class="source-line-no">3679</span><span id="line-3679">  private Throwable cleanup(final Throwable t, final String msg) {</span>
<span class="source-line-no">3680</span><span id="line-3680">    // Don't log as error if NSRE; NSRE is 'normal' operation.</span>
<span class="source-line-no">3681</span><span id="line-3681">    if (t instanceof NotServingRegionException) {</span>
<span class="source-line-no">3682</span><span id="line-3682">      LOG.debug("NotServingRegionException; " + t.getMessage());</span>
<span class="source-line-no">3683</span><span id="line-3683">      return t;</span>
<span class="source-line-no">3684</span><span id="line-3684">    }</span>
<span class="source-line-no">3685</span><span id="line-3685">    Throwable e = t instanceof RemoteException ? ((RemoteException) t).unwrapRemoteException() : t;</span>
<span class="source-line-no">3686</span><span id="line-3686">    if (msg == null) {</span>
<span class="source-line-no">3687</span><span id="line-3687">      LOG.error("", e);</span>
<span class="source-line-no">3688</span><span id="line-3688">    } else {</span>
<span class="source-line-no">3689</span><span id="line-3689">      LOG.error(msg, e);</span>
<span class="source-line-no">3690</span><span id="line-3690">    }</span>
<span class="source-line-no">3691</span><span id="line-3691">    if (!rpcServices.checkOOME(t)) {</span>
<span class="source-line-no">3692</span><span id="line-3692">      checkFileSystem();</span>
<span class="source-line-no">3693</span><span id="line-3693">    }</span>
<span class="source-line-no">3694</span><span id="line-3694">    return t;</span>
<span class="source-line-no">3695</span><span id="line-3695">  }</span>
<span class="source-line-no">3696</span><span id="line-3696"></span>
<span class="source-line-no">3697</span><span id="line-3697">  /**</span>
<span class="source-line-no">3698</span><span id="line-3698">   * @param msg Message to put in new IOE if passed &lt;code&gt;t&lt;/code&gt; is not an IOE</span>
<span class="source-line-no">3699</span><span id="line-3699">   * @return Make &lt;code&gt;t&lt;/code&gt; an IOE if it isn't already.</span>
<span class="source-line-no">3700</span><span id="line-3700">   */</span>
<span class="source-line-no">3701</span><span id="line-3701">  private IOException convertThrowableToIOE(final Throwable t, final String msg) {</span>
<span class="source-line-no">3702</span><span id="line-3702">    return (t instanceof IOException ? (IOException) t</span>
<span class="source-line-no">3703</span><span id="line-3703">      : msg == null || msg.length() == 0 ? new IOException(t)</span>
<span class="source-line-no">3704</span><span id="line-3704">      : new IOException(msg, t));</span>
<span class="source-line-no">3705</span><span id="line-3705">  }</span>
<span class="source-line-no">3706</span><span id="line-3706"></span>
<span class="source-line-no">3707</span><span id="line-3707">  /**</span>
<span class="source-line-no">3708</span><span id="line-3708">   * Checks to see if the file system is still accessible. If not, sets abortRequested and</span>
<span class="source-line-no">3709</span><span id="line-3709">   * stopRequested</span>
<span class="source-line-no">3710</span><span id="line-3710">   * @return false if file system is not available</span>
<span class="source-line-no">3711</span><span id="line-3711">   */</span>
<span class="source-line-no">3712</span><span id="line-3712">  boolean checkFileSystem() {</span>
<span class="source-line-no">3713</span><span id="line-3713">    if (this.dataFsOk &amp;&amp; this.dataFs != null) {</span>
<span class="source-line-no">3714</span><span id="line-3714">      try {</span>
<span class="source-line-no">3715</span><span id="line-3715">        FSUtils.checkFileSystemAvailable(this.dataFs);</span>
<span class="source-line-no">3716</span><span id="line-3716">      } catch (IOException e) {</span>
<span class="source-line-no">3717</span><span id="line-3717">        abort("File System not available", e);</span>
<span class="source-line-no">3718</span><span id="line-3718">        this.dataFsOk = false;</span>
<span class="source-line-no">3719</span><span id="line-3719">      }</span>
<span class="source-line-no">3720</span><span id="line-3720">    }</span>
<span class="source-line-no">3721</span><span id="line-3721">    return this.dataFsOk;</span>
<span class="source-line-no">3722</span><span id="line-3722">  }</span>
<span class="source-line-no">3723</span><span id="line-3723"></span>
<span class="source-line-no">3724</span><span id="line-3724">  @Override</span>
<span class="source-line-no">3725</span><span id="line-3725">  public void updateRegionFavoredNodesMapping(String encodedRegionName,</span>
<span class="source-line-no">3726</span><span id="line-3726">    List&lt;org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName&gt; favoredNodes) {</span>
<span class="source-line-no">3727</span><span id="line-3727">    Address[] addr = new Address[favoredNodes.size()];</span>
<span class="source-line-no">3728</span><span id="line-3728">    // Refer to the comment on the declaration of regionFavoredNodesMap on why</span>
<span class="source-line-no">3729</span><span id="line-3729">    // it is a map of region name to Address[]</span>
<span class="source-line-no">3730</span><span id="line-3730">    for (int i = 0; i &lt; favoredNodes.size(); i++) {</span>
<span class="source-line-no">3731</span><span id="line-3731">      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(), favoredNodes.get(i).getPort());</span>
<span class="source-line-no">3732</span><span id="line-3732">    }</span>
<span class="source-line-no">3733</span><span id="line-3733">    regionFavoredNodesMap.put(encodedRegionName, addr);</span>
<span class="source-line-no">3734</span><span id="line-3734">  }</span>
<span class="source-line-no">3735</span><span id="line-3735"></span>
<span class="source-line-no">3736</span><span id="line-3736">  /**</span>
<span class="source-line-no">3737</span><span id="line-3737">   * Return the favored nodes for a region given its encoded name. Look at the comment around</span>
<span class="source-line-no">3738</span><span id="line-3738">   * {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[] here.</span>
<span class="source-line-no">3739</span><span id="line-3739">   * @param encodedRegionName the encoded region name.</span>
<span class="source-line-no">3740</span><span id="line-3740">   * @return array of favored locations</span>
<span class="source-line-no">3741</span><span id="line-3741">   */</span>
<span class="source-line-no">3742</span><span id="line-3742">  @Override</span>
<span class="source-line-no">3743</span><span id="line-3743">  public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {</span>
<span class="source-line-no">3744</span><span id="line-3744">    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));</span>
<span class="source-line-no">3745</span><span id="line-3745">  }</span>
<span class="source-line-no">3746</span><span id="line-3746"></span>
<span class="source-line-no">3747</span><span id="line-3747">  @Override</span>
<span class="source-line-no">3748</span><span id="line-3748">  public ServerNonceManager getNonceManager() {</span>
<span class="source-line-no">3749</span><span id="line-3749">    return this.nonceManager;</span>
<span class="source-line-no">3750</span><span id="line-3750">  }</span>
<span class="source-line-no">3751</span><span id="line-3751"></span>
<span class="source-line-no">3752</span><span id="line-3752">  private static class MovedRegionInfo {</span>
<span class="source-line-no">3753</span><span id="line-3753">    private final ServerName serverName;</span>
<span class="source-line-no">3754</span><span id="line-3754">    private final long seqNum;</span>
<span class="source-line-no">3755</span><span id="line-3755"></span>
<span class="source-line-no">3756</span><span id="line-3756">    MovedRegionInfo(ServerName serverName, long closeSeqNum) {</span>
<span class="source-line-no">3757</span><span id="line-3757">      this.serverName = serverName;</span>
<span class="source-line-no">3758</span><span id="line-3758">      this.seqNum = closeSeqNum;</span>
<span class="source-line-no">3759</span><span id="line-3759">    }</span>
<span class="source-line-no">3760</span><span id="line-3760"></span>
<span class="source-line-no">3761</span><span id="line-3761">    public ServerName getServerName() {</span>
<span class="source-line-no">3762</span><span id="line-3762">      return serverName;</span>
<span class="source-line-no">3763</span><span id="line-3763">    }</span>
<span class="source-line-no">3764</span><span id="line-3764"></span>
<span class="source-line-no">3765</span><span id="line-3765">    public long getSeqNum() {</span>
<span class="source-line-no">3766</span><span id="line-3766">      return seqNum;</span>
<span class="source-line-no">3767</span><span id="line-3767">    }</span>
<span class="source-line-no">3768</span><span id="line-3768">  }</span>
<span class="source-line-no">3769</span><span id="line-3769"></span>
<span class="source-line-no">3770</span><span id="line-3770">  /**</span>
<span class="source-line-no">3771</span><span id="line-3771">   * We need a timeout. If not there is a risk of giving a wrong information: this would double the</span>
<span class="source-line-no">3772</span><span id="line-3772">   * number of network calls instead of reducing them.</span>
<span class="source-line-no">3773</span><span id="line-3773">   */</span>
<span class="source-line-no">3774</span><span id="line-3774">  private static final int TIMEOUT_REGION_MOVED = (2 * 60 * 1000);</span>
<span class="source-line-no">3775</span><span id="line-3775"></span>
<span class="source-line-no">3776</span><span id="line-3776">  private void addToMovedRegions(String encodedName, ServerName destination, long closeSeqNum,</span>
<span class="source-line-no">3777</span><span id="line-3777">    boolean selfMove) {</span>
<span class="source-line-no">3778</span><span id="line-3778">    if (selfMove) {</span>
<span class="source-line-no">3779</span><span id="line-3779">      LOG.warn("Not adding moved region record: " + encodedName + " to self.");</span>
<span class="source-line-no">3780</span><span id="line-3780">      return;</span>
<span class="source-line-no">3781</span><span id="line-3781">    }</span>
<span class="source-line-no">3782</span><span id="line-3782">    LOG.info("Adding " + encodedName + " move to " + destination + " record at close sequenceid="</span>
<span class="source-line-no">3783</span><span id="line-3783">      + closeSeqNum);</span>
<span class="source-line-no">3784</span><span id="line-3784">    movedRegionInfoCache.put(encodedName, new MovedRegionInfo(destination, closeSeqNum));</span>
<span class="source-line-no">3785</span><span id="line-3785">  }</span>
<span class="source-line-no">3786</span><span id="line-3786"></span>
<span class="source-line-no">3787</span><span id="line-3787">  void removeFromMovedRegions(String encodedName) {</span>
<span class="source-line-no">3788</span><span id="line-3788">    movedRegionInfoCache.invalidate(encodedName);</span>
<span class="source-line-no">3789</span><span id="line-3789">  }</span>
<span class="source-line-no">3790</span><span id="line-3790"></span>
<span class="source-line-no">3791</span><span id="line-3791">  @InterfaceAudience.Private</span>
<span class="source-line-no">3792</span><span id="line-3792">  public MovedRegionInfo getMovedRegion(String encodedRegionName) {</span>
<span class="source-line-no">3793</span><span id="line-3793">    return movedRegionInfoCache.getIfPresent(encodedRegionName);</span>
<span class="source-line-no">3794</span><span id="line-3794">  }</span>
<span class="source-line-no">3795</span><span id="line-3795"></span>
<span class="source-line-no">3796</span><span id="line-3796">  @InterfaceAudience.Private</span>
<span class="source-line-no">3797</span><span id="line-3797">  public int movedRegionCacheExpiredTime() {</span>
<span class="source-line-no">3798</span><span id="line-3798">    return TIMEOUT_REGION_MOVED;</span>
<span class="source-line-no">3799</span><span id="line-3799">  }</span>
<span class="source-line-no">3800</span><span id="line-3800"></span>
<span class="source-line-no">3801</span><span id="line-3801">  private String getMyEphemeralNodePath() {</span>
<span class="source-line-no">3802</span><span id="line-3802">    return zooKeeper.getZNodePaths().getRsPath(serverName);</span>
<span class="source-line-no">3803</span><span id="line-3803">  }</span>
<span class="source-line-no">3804</span><span id="line-3804"></span>
<span class="source-line-no">3805</span><span id="line-3805">  private boolean isHealthCheckerConfigured() {</span>
<span class="source-line-no">3806</span><span id="line-3806">    String healthScriptLocation = this.conf.get(HConstants.HEALTH_SCRIPT_LOC);</span>
<span class="source-line-no">3807</span><span id="line-3807">    return org.apache.commons.lang3.StringUtils.isNotBlank(healthScriptLocation);</span>
<span class="source-line-no">3808</span><span id="line-3808">  }</span>
<span class="source-line-no">3809</span><span id="line-3809"></span>
<span class="source-line-no">3810</span><span id="line-3810">  /** Returns the underlying {@link CompactSplit} for the servers */</span>
<span class="source-line-no">3811</span><span id="line-3811">  public CompactSplit getCompactSplitThread() {</span>
<span class="source-line-no">3812</span><span id="line-3812">    return this.compactSplitThread;</span>
<span class="source-line-no">3813</span><span id="line-3813">  }</span>
<span class="source-line-no">3814</span><span id="line-3814"></span>
<span class="source-line-no">3815</span><span id="line-3815">  CoprocessorServiceResponse execRegionServerService(</span>
<span class="source-line-no">3816</span><span id="line-3816">    @SuppressWarnings("UnusedParameters") final RpcController controller,</span>
<span class="source-line-no">3817</span><span id="line-3817">    final CoprocessorServiceRequest serviceRequest) throws ServiceException {</span>
<span class="source-line-no">3818</span><span id="line-3818">    try {</span>
<span class="source-line-no">3819</span><span id="line-3819">      ServerRpcController serviceController = new ServerRpcController();</span>
<span class="source-line-no">3820</span><span id="line-3820">      CoprocessorServiceCall call = serviceRequest.getCall();</span>
<span class="source-line-no">3821</span><span id="line-3821">      String serviceName = call.getServiceName();</span>
<span class="source-line-no">3822</span><span id="line-3822">      com.google.protobuf.Service service = coprocessorServiceHandlers.get(serviceName);</span>
<span class="source-line-no">3823</span><span id="line-3823">      if (service == null) {</span>
<span class="source-line-no">3824</span><span id="line-3824">        throw new UnknownProtocolException(null,</span>
<span class="source-line-no">3825</span><span id="line-3825">          "No registered coprocessor executorService found for " + serviceName);</span>
<span class="source-line-no">3826</span><span id="line-3826">      }</span>
<span class="source-line-no">3827</span><span id="line-3827">      com.google.protobuf.Descriptors.ServiceDescriptor serviceDesc =</span>
<span class="source-line-no">3828</span><span id="line-3828">        service.getDescriptorForType();</span>
<span class="source-line-no">3829</span><span id="line-3829"></span>
<span class="source-line-no">3830</span><span id="line-3830">      String methodName = call.getMethodName();</span>
<span class="source-line-no">3831</span><span id="line-3831">      com.google.protobuf.Descriptors.MethodDescriptor methodDesc =</span>
<span class="source-line-no">3832</span><span id="line-3832">        serviceDesc.findMethodByName(methodName);</span>
<span class="source-line-no">3833</span><span id="line-3833">      if (methodDesc == null) {</span>
<span class="source-line-no">3834</span><span id="line-3834">        throw new UnknownProtocolException(service.getClass(),</span>
<span class="source-line-no">3835</span><span id="line-3835">          "Unknown method " + methodName + " called on executorService " + serviceName);</span>
<span class="source-line-no">3836</span><span id="line-3836">      }</span>
<span class="source-line-no">3837</span><span id="line-3837"></span>
<span class="source-line-no">3838</span><span id="line-3838">      com.google.protobuf.Message request =</span>
<span class="source-line-no">3839</span><span id="line-3839">        CoprocessorRpcUtils.getRequest(service, methodDesc, call.getRequest());</span>
<span class="source-line-no">3840</span><span id="line-3840">      final com.google.protobuf.Message.Builder responseBuilder =</span>
<span class="source-line-no">3841</span><span id="line-3841">        service.getResponsePrototype(methodDesc).newBuilderForType();</span>
<span class="source-line-no">3842</span><span id="line-3842">      service.callMethod(methodDesc, serviceController, request, message -&gt; {</span>
<span class="source-line-no">3843</span><span id="line-3843">        if (message != null) {</span>
<span class="source-line-no">3844</span><span id="line-3844">          responseBuilder.mergeFrom(message);</span>
<span class="source-line-no">3845</span><span id="line-3845">        }</span>
<span class="source-line-no">3846</span><span id="line-3846">      });</span>
<span class="source-line-no">3847</span><span id="line-3847">      IOException exception = CoprocessorRpcUtils.getControllerException(serviceController);</span>
<span class="source-line-no">3848</span><span id="line-3848">      if (exception != null) {</span>
<span class="source-line-no">3849</span><span id="line-3849">        throw exception;</span>
<span class="source-line-no">3850</span><span id="line-3850">      }</span>
<span class="source-line-no">3851</span><span id="line-3851">      return CoprocessorRpcUtils.getResponse(responseBuilder.build(), HConstants.EMPTY_BYTE_ARRAY);</span>
<span class="source-line-no">3852</span><span id="line-3852">    } catch (IOException ie) {</span>
<span class="source-line-no">3853</span><span id="line-3853">      throw new ServiceException(ie);</span>
<span class="source-line-no">3854</span><span id="line-3854">    }</span>
<span class="source-line-no">3855</span><span id="line-3855">  }</span>
<span class="source-line-no">3856</span><span id="line-3856"></span>
<span class="source-line-no">3857</span><span id="line-3857">  /**</span>
<span class="source-line-no">3858</span><span id="line-3858">   * May be null if this is a master which not carry table.</span>
<span class="source-line-no">3859</span><span id="line-3859">   * @return The block cache instance used by the regionserver.</span>
<span class="source-line-no">3860</span><span id="line-3860">   */</span>
<span class="source-line-no">3861</span><span id="line-3861">  @Override</span>
<span class="source-line-no">3862</span><span id="line-3862">  public Optional&lt;BlockCache&gt; getBlockCache() {</span>
<span class="source-line-no">3863</span><span id="line-3863">    return Optional.ofNullable(this.blockCache);</span>
<span class="source-line-no">3864</span><span id="line-3864">  }</span>
<span class="source-line-no">3865</span><span id="line-3865"></span>
<span class="source-line-no">3866</span><span id="line-3866">  /**</span>
<span class="source-line-no">3867</span><span id="line-3867">   * May be null if this is a master which not carry table.</span>
<span class="source-line-no">3868</span><span id="line-3868">   * @return The cache for mob files used by the regionserver.</span>
<span class="source-line-no">3869</span><span id="line-3869">   */</span>
<span class="source-line-no">3870</span><span id="line-3870">  @Override</span>
<span class="source-line-no">3871</span><span id="line-3871">  public Optional&lt;MobFileCache&gt; getMobFileCache() {</span>
<span class="source-line-no">3872</span><span id="line-3872">    return Optional.ofNullable(this.mobFileCache);</span>
<span class="source-line-no">3873</span><span id="line-3873">  }</span>
<span class="source-line-no">3874</span><span id="line-3874"></span>
<span class="source-line-no">3875</span><span id="line-3875">  @Override</span>
<span class="source-line-no">3876</span><span id="line-3876">  public AccessChecker getAccessChecker() {</span>
<span class="source-line-no">3877</span><span id="line-3877">    return rpcServices.getAccessChecker();</span>
<span class="source-line-no">3878</span><span id="line-3878">  }</span>
<span class="source-line-no">3879</span><span id="line-3879"></span>
<span class="source-line-no">3880</span><span id="line-3880">  @Override</span>
<span class="source-line-no">3881</span><span id="line-3881">  public ZKPermissionWatcher getZKPermissionWatcher() {</span>
<span class="source-line-no">3882</span><span id="line-3882">    return rpcServices.getZkPermissionWatcher();</span>
<span class="source-line-no">3883</span><span id="line-3883">  }</span>
<span class="source-line-no">3884</span><span id="line-3884"></span>
<span class="source-line-no">3885</span><span id="line-3885">  /** Returns : Returns the ConfigurationManager object for testing purposes. */</span>
<span class="source-line-no">3886</span><span id="line-3886">  @RestrictedApi(explanation = "Should only be called in tests", link = "",</span>
<span class="source-line-no">3887</span><span id="line-3887">      allowedOnPath = ".*/src/test/.*")</span>
<span class="source-line-no">3888</span><span id="line-3888">  public ConfigurationManager getConfigurationManager() {</span>
<span class="source-line-no">3889</span><span id="line-3889">    return configurationManager;</span>
<span class="source-line-no">3890</span><span id="line-3890">  }</span>
<span class="source-line-no">3891</span><span id="line-3891"></span>
<span class="source-line-no">3892</span><span id="line-3892">  /** Returns Return table descriptors implementation. */</span>
<span class="source-line-no">3893</span><span id="line-3893">  @Override</span>
<span class="source-line-no">3894</span><span id="line-3894">  public TableDescriptors getTableDescriptors() {</span>
<span class="source-line-no">3895</span><span id="line-3895">    return this.tableDescriptors;</span>
<span class="source-line-no">3896</span><span id="line-3896">  }</span>
<span class="source-line-no">3897</span><span id="line-3897"></span>
<span class="source-line-no">3898</span><span id="line-3898">  /**</span>
<span class="source-line-no">3899</span><span id="line-3899">   * Reload the configuration from disk.</span>
<span class="source-line-no">3900</span><span id="line-3900">   */</span>
<span class="source-line-no">3901</span><span id="line-3901">  void updateConfiguration() throws IOException {</span>
<span class="source-line-no">3902</span><span id="line-3902">    LOG.info("Reloading the configuration from disk.");</span>
<span class="source-line-no">3903</span><span id="line-3903">    // Reload the configuration from disk.</span>
<span class="source-line-no">3904</span><span id="line-3904">    preUpdateConfiguration();</span>
<span class="source-line-no">3905</span><span id="line-3905">    conf.reloadConfiguration();</span>
<span class="source-line-no">3906</span><span id="line-3906">    configurationManager.notifyAllObservers(conf);</span>
<span class="source-line-no">3907</span><span id="line-3907">    postUpdateConfiguration();</span>
<span class="source-line-no">3908</span><span id="line-3908">  }</span>
<span class="source-line-no">3909</span><span id="line-3909"></span>
<span class="source-line-no">3910</span><span id="line-3910">  protected void preUpdateConfiguration() throws IOException {</span>
<span class="source-line-no">3911</span><span id="line-3911">    if (rsHost != null) {</span>
<span class="source-line-no">3912</span><span id="line-3912">      rsHost.preUpdateConfiguration(conf);</span>
<span class="source-line-no">3913</span><span id="line-3913">    }</span>
<span class="source-line-no">3914</span><span id="line-3914">  }</span>
<span class="source-line-no">3915</span><span id="line-3915"></span>
<span class="source-line-no">3916</span><span id="line-3916">  protected void postUpdateConfiguration() throws IOException {</span>
<span class="source-line-no">3917</span><span id="line-3917">    if (rsHost != null) {</span>
<span class="source-line-no">3918</span><span id="line-3918">      rsHost.postUpdateConfiguration(conf);</span>
<span class="source-line-no">3919</span><span id="line-3919">    }</span>
<span class="source-line-no">3920</span><span id="line-3920">  }</span>
<span class="source-line-no">3921</span><span id="line-3921"></span>
<span class="source-line-no">3922</span><span id="line-3922">  CacheEvictionStats clearRegionBlockCache(Region region) {</span>
<span class="source-line-no">3923</span><span id="line-3923">    long evictedBlocks = 0;</span>
<span class="source-line-no">3924</span><span id="line-3924"></span>
<span class="source-line-no">3925</span><span id="line-3925">    for (Store store : region.getStores()) {</span>
<span class="source-line-no">3926</span><span id="line-3926">      for (StoreFile hFile : store.getStorefiles()) {</span>
<span class="source-line-no">3927</span><span id="line-3927">        evictedBlocks += blockCache.evictBlocksByHfileName(hFile.getPath().getName());</span>
<span class="source-line-no">3928</span><span id="line-3928">      }</span>
<span class="source-line-no">3929</span><span id="line-3929">    }</span>
<span class="source-line-no">3930</span><span id="line-3930"></span>
<span class="source-line-no">3931</span><span id="line-3931">    return CacheEvictionStats.builder().withEvictedBlocks(evictedBlocks).build();</span>
<span class="source-line-no">3932</span><span id="line-3932">  }</span>
<span class="source-line-no">3933</span><span id="line-3933"></span>
<span class="source-line-no">3934</span><span id="line-3934">  @Override</span>
<span class="source-line-no">3935</span><span id="line-3935">  public double getCompactionPressure() {</span>
<span class="source-line-no">3936</span><span id="line-3936">    double max = 0;</span>
<span class="source-line-no">3937</span><span id="line-3937">    for (Region region : onlineRegions.values()) {</span>
<span class="source-line-no">3938</span><span id="line-3938">      for (Store store : region.getStores()) {</span>
<span class="source-line-no">3939</span><span id="line-3939">        double normCount = store.getCompactionPressure();</span>
<span class="source-line-no">3940</span><span id="line-3940">        if (normCount &gt; max) {</span>
<span class="source-line-no">3941</span><span id="line-3941">          max = normCount;</span>
<span class="source-line-no">3942</span><span id="line-3942">        }</span>
<span class="source-line-no">3943</span><span id="line-3943">      }</span>
<span class="source-line-no">3944</span><span id="line-3944">    }</span>
<span class="source-line-no">3945</span><span id="line-3945">    return max;</span>
<span class="source-line-no">3946</span><span id="line-3946">  }</span>
<span class="source-line-no">3947</span><span id="line-3947"></span>
<span class="source-line-no">3948</span><span id="line-3948">  @Override</span>
<span class="source-line-no">3949</span><span id="line-3949">  public HeapMemoryManager getHeapMemoryManager() {</span>
<span class="source-line-no">3950</span><span id="line-3950">    return hMemManager;</span>
<span class="source-line-no">3951</span><span id="line-3951">  }</span>
<span class="source-line-no">3952</span><span id="line-3952"></span>
<span class="source-line-no">3953</span><span id="line-3953">  public MemStoreFlusher getMemStoreFlusher() {</span>
<span class="source-line-no">3954</span><span id="line-3954">    return cacheFlusher;</span>
<span class="source-line-no">3955</span><span id="line-3955">  }</span>
<span class="source-line-no">3956</span><span id="line-3956"></span>
<span class="source-line-no">3957</span><span id="line-3957">  /**</span>
<span class="source-line-no">3958</span><span id="line-3958">   * For testing</span>
<span class="source-line-no">3959</span><span id="line-3959">   * @return whether all wal roll request finished for this regionserver</span>
<span class="source-line-no">3960</span><span id="line-3960">   */</span>
<span class="source-line-no">3961</span><span id="line-3961">  @InterfaceAudience.Private</span>
<span class="source-line-no">3962</span><span id="line-3962">  public boolean walRollRequestFinished() {</span>
<span class="source-line-no">3963</span><span id="line-3963">    return this.walRoller.walRollFinished();</span>
<span class="source-line-no">3964</span><span id="line-3964">  }</span>
<span class="source-line-no">3965</span><span id="line-3965"></span>
<span class="source-line-no">3966</span><span id="line-3966">  @Override</span>
<span class="source-line-no">3967</span><span id="line-3967">  public ThroughputController getFlushThroughputController() {</span>
<span class="source-line-no">3968</span><span id="line-3968">    return flushThroughputController;</span>
<span class="source-line-no">3969</span><span id="line-3969">  }</span>
<span class="source-line-no">3970</span><span id="line-3970"></span>
<span class="source-line-no">3971</span><span id="line-3971">  @Override</span>
<span class="source-line-no">3972</span><span id="line-3972">  public double getFlushPressure() {</span>
<span class="source-line-no">3973</span><span id="line-3973">    if (getRegionServerAccounting() == null || cacheFlusher == null) {</span>
<span class="source-line-no">3974</span><span id="line-3974">      // return 0 during RS initialization</span>
<span class="source-line-no">3975</span><span id="line-3975">      return 0.0;</span>
<span class="source-line-no">3976</span><span id="line-3976">    }</span>
<span class="source-line-no">3977</span><span id="line-3977">    return getRegionServerAccounting().getFlushPressure();</span>
<span class="source-line-no">3978</span><span id="line-3978">  }</span>
<span class="source-line-no">3979</span><span id="line-3979"></span>
<span class="source-line-no">3980</span><span id="line-3980">  @Override</span>
<span class="source-line-no">3981</span><span id="line-3981">  public void onConfigurationChange(Configuration newConf) {</span>
<span class="source-line-no">3982</span><span id="line-3982">    ThroughputController old = this.flushThroughputController;</span>
<span class="source-line-no">3983</span><span id="line-3983">    if (old != null) {</span>
<span class="source-line-no">3984</span><span id="line-3984">      old.stop("configuration change");</span>
<span class="source-line-no">3985</span><span id="line-3985">    }</span>
<span class="source-line-no">3986</span><span id="line-3986">    this.flushThroughputController = FlushThroughputControllerFactory.create(this, newConf);</span>
<span class="source-line-no">3987</span><span id="line-3987">    try {</span>
<span class="source-line-no">3988</span><span id="line-3988">      Superusers.initialize(newConf);</span>
<span class="source-line-no">3989</span><span id="line-3989">    } catch (IOException e) {</span>
<span class="source-line-no">3990</span><span id="line-3990">      LOG.warn("Failed to initialize SuperUsers on reloading of the configuration");</span>
<span class="source-line-no">3991</span><span id="line-3991">    }</span>
<span class="source-line-no">3992</span><span id="line-3992"></span>
<span class="source-line-no">3993</span><span id="line-3993">    // update region server coprocessor if the configuration has changed.</span>
<span class="source-line-no">3994</span><span id="line-3994">    if (</span>
<span class="source-line-no">3995</span><span id="line-3995">      CoprocessorConfigurationUtil.checkConfigurationChange(getConfiguration(), newConf,</span>
<span class="source-line-no">3996</span><span id="line-3996">        CoprocessorHost.REGIONSERVER_COPROCESSOR_CONF_KEY)</span>
<span class="source-line-no">3997</span><span id="line-3997">    ) {</span>
<span class="source-line-no">3998</span><span id="line-3998">      LOG.info("Update region server coprocessors because the configuration has changed");</span>
<span class="source-line-no">3999</span><span id="line-3999">      this.rsHost = new RegionServerCoprocessorHost(this, newConf);</span>
<span class="source-line-no">4000</span><span id="line-4000">    }</span>
<span class="source-line-no">4001</span><span id="line-4001">  }</span>
<span class="source-line-no">4002</span><span id="line-4002"></span>
<span class="source-line-no">4003</span><span id="line-4003">  @Override</span>
<span class="source-line-no">4004</span><span id="line-4004">  public MetricsRegionServer getMetrics() {</span>
<span class="source-line-no">4005</span><span id="line-4005">    return metricsRegionServer;</span>
<span class="source-line-no">4006</span><span id="line-4006">  }</span>
<span class="source-line-no">4007</span><span id="line-4007"></span>
<span class="source-line-no">4008</span><span id="line-4008">  @Override</span>
<span class="source-line-no">4009</span><span id="line-4009">  public SecureBulkLoadManager getSecureBulkLoadManager() {</span>
<span class="source-line-no">4010</span><span id="line-4010">    return this.secureBulkLoadManager;</span>
<span class="source-line-no">4011</span><span id="line-4011">  }</span>
<span class="source-line-no">4012</span><span id="line-4012"></span>
<span class="source-line-no">4013</span><span id="line-4013">  @Override</span>
<span class="source-line-no">4014</span><span id="line-4014">  public EntityLock regionLock(final List&lt;RegionInfo&gt; regionInfos, final String description,</span>
<span class="source-line-no">4015</span><span id="line-4015">    final Abortable abort) {</span>
<span class="source-line-no">4016</span><span id="line-4016">    return new LockServiceClient(conf, lockStub, clusterConnection.getNonceGenerator())</span>
<span class="source-line-no">4017</span><span id="line-4017">      .regionLock(regionInfos, description, abort);</span>
<span class="source-line-no">4018</span><span id="line-4018">  }</span>
<span class="source-line-no">4019</span><span id="line-4019"></span>
<span class="source-line-no">4020</span><span id="line-4020">  @Override</span>
<span class="source-line-no">4021</span><span id="line-4021">  public void unassign(byte[] regionName) throws IOException {</span>
<span class="source-line-no">4022</span><span id="line-4022">    clusterConnection.getAdmin().unassign(regionName, false);</span>
<span class="source-line-no">4023</span><span id="line-4023">  }</span>
<span class="source-line-no">4024</span><span id="line-4024"></span>
<span class="source-line-no">4025</span><span id="line-4025">  @Override</span>
<span class="source-line-no">4026</span><span id="line-4026">  public RegionServerSpaceQuotaManager getRegionServerSpaceQuotaManager() {</span>
<span class="source-line-no">4027</span><span id="line-4027">    return this.rsSpaceQuotaManager;</span>
<span class="source-line-no">4028</span><span id="line-4028">  }</span>
<span class="source-line-no">4029</span><span id="line-4029"></span>
<span class="source-line-no">4030</span><span id="line-4030">  @Override</span>
<span class="source-line-no">4031</span><span id="line-4031">  public boolean reportFileArchivalForQuotas(TableName tableName,</span>
<span class="source-line-no">4032</span><span id="line-4032">    Collection&lt;Entry&lt;String, Long&gt;&gt; archivedFiles) {</span>
<span class="source-line-no">4033</span><span id="line-4033">    if (TEST_SKIP_REPORTING_TRANSITION) {</span>
<span class="source-line-no">4034</span><span id="line-4034">      return false;</span>
<span class="source-line-no">4035</span><span id="line-4035">    }</span>
<span class="source-line-no">4036</span><span id="line-4036">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">4037</span><span id="line-4037">    if (rss == null || rsSpaceQuotaManager == null) {</span>
<span class="source-line-no">4038</span><span id="line-4038">      // the current server could be stopping.</span>
<span class="source-line-no">4039</span><span id="line-4039">      LOG.trace("Skipping file archival reporting to HMaster as stub is null");</span>
<span class="source-line-no">4040</span><span id="line-4040">      return false;</span>
<span class="source-line-no">4041</span><span id="line-4041">    }</span>
<span class="source-line-no">4042</span><span id="line-4042">    try {</span>
<span class="source-line-no">4043</span><span id="line-4043">      RegionServerStatusProtos.FileArchiveNotificationRequest request =</span>
<span class="source-line-no">4044</span><span id="line-4044">        rsSpaceQuotaManager.buildFileArchiveRequest(tableName, archivedFiles);</span>
<span class="source-line-no">4045</span><span id="line-4045">      rss.reportFileArchival(null, request);</span>
<span class="source-line-no">4046</span><span id="line-4046">    } catch (ServiceException se) {</span>
<span class="source-line-no">4047</span><span id="line-4047">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">4048</span><span id="line-4048">      if (ioe instanceof PleaseHoldException) {</span>
<span class="source-line-no">4049</span><span id="line-4049">        if (LOG.isTraceEnabled()) {</span>
<span class="source-line-no">4050</span><span id="line-4050">          LOG.trace("Failed to report file archival(s) to Master because it is initializing."</span>
<span class="source-line-no">4051</span><span id="line-4051">            + " This will be retried.", ioe);</span>
<span class="source-line-no">4052</span><span id="line-4052">        }</span>
<span class="source-line-no">4053</span><span id="line-4053">        // The Master is coming up. Will retry the report later. Avoid re-creating the stub.</span>
<span class="source-line-no">4054</span><span id="line-4054">        return false;</span>
<span class="source-line-no">4055</span><span id="line-4055">      }</span>
<span class="source-line-no">4056</span><span id="line-4056">      if (rssStub == rss) {</span>
<span class="source-line-no">4057</span><span id="line-4057">        rssStub = null;</span>
<span class="source-line-no">4058</span><span id="line-4058">      }</span>
<span class="source-line-no">4059</span><span id="line-4059">      // re-create the stub if we failed to report the archival</span>
<span class="source-line-no">4060</span><span id="line-4060">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">4061</span><span id="line-4061">      LOG.debug("Failed to report file archival(s) to Master. This will be retried.", ioe);</span>
<span class="source-line-no">4062</span><span id="line-4062">      return false;</span>
<span class="source-line-no">4063</span><span id="line-4063">    }</span>
<span class="source-line-no">4064</span><span id="line-4064">    return true;</span>
<span class="source-line-no">4065</span><span id="line-4065">  }</span>
<span class="source-line-no">4066</span><span id="line-4066"></span>
<span class="source-line-no">4067</span><span id="line-4067">  public NettyEventLoopGroupConfig getEventLoopGroupConfig() {</span>
<span class="source-line-no">4068</span><span id="line-4068">    return eventLoopGroupConfig;</span>
<span class="source-line-no">4069</span><span id="line-4069">  }</span>
<span class="source-line-no">4070</span><span id="line-4070"></span>
<span class="source-line-no">4071</span><span id="line-4071">  @Override</span>
<span class="source-line-no">4072</span><span id="line-4072">  public Connection createConnection(Configuration conf) throws IOException {</span>
<span class="source-line-no">4073</span><span id="line-4073">    User user = UserProvider.instantiate(conf).getCurrent();</span>
<span class="source-line-no">4074</span><span id="line-4074">    return ServerConnectionUtils.createShortCircuitConnection(conf, user, this.serverName,</span>
<span class="source-line-no">4075</span><span id="line-4075">      this.rpcServices, this.rpcServices, new RegionServerRegistry(this));</span>
<span class="source-line-no">4076</span><span id="line-4076">  }</span>
<span class="source-line-no">4077</span><span id="line-4077"></span>
<span class="source-line-no">4078</span><span id="line-4078">  void executeProcedure(long procId, RSProcedureCallable callable) {</span>
<span class="source-line-no">4079</span><span id="line-4079">    executorService.submit(new RSProcedureHandler(this, procId, callable));</span>
<span class="source-line-no">4080</span><span id="line-4080">  }</span>
<span class="source-line-no">4081</span><span id="line-4081"></span>
<span class="source-line-no">4082</span><span id="line-4082">  public void remoteProcedureComplete(long procId, Throwable error) {</span>
<span class="source-line-no">4083</span><span id="line-4083">    procedureResultReporter.complete(procId, error);</span>
<span class="source-line-no">4084</span><span id="line-4084">  }</span>
<span class="source-line-no">4085</span><span id="line-4085"></span>
<span class="source-line-no">4086</span><span id="line-4086">  void reportProcedureDone(ReportProcedureDoneRequest request) throws IOException {</span>
<span class="source-line-no">4087</span><span id="line-4087">    RegionServerStatusService.BlockingInterface rss;</span>
<span class="source-line-no">4088</span><span id="line-4088">    // TODO: juggling class state with an instance variable, outside of a synchronized block :'(</span>
<span class="source-line-no">4089</span><span id="line-4089">    for (;;) {</span>
<span class="source-line-no">4090</span><span id="line-4090">      rss = rssStub;</span>
<span class="source-line-no">4091</span><span id="line-4091">      if (rss != null) {</span>
<span class="source-line-no">4092</span><span id="line-4092">        break;</span>
<span class="source-line-no">4093</span><span id="line-4093">      }</span>
<span class="source-line-no">4094</span><span id="line-4094">      createRegionServerStatusStub();</span>
<span class="source-line-no">4095</span><span id="line-4095">    }</span>
<span class="source-line-no">4096</span><span id="line-4096">    try {</span>
<span class="source-line-no">4097</span><span id="line-4097">      rss.reportProcedureDone(null, request);</span>
<span class="source-line-no">4098</span><span id="line-4098">    } catch (ServiceException se) {</span>
<span class="source-line-no">4099</span><span id="line-4099">      if (rssStub == rss) {</span>
<span class="source-line-no">4100</span><span id="line-4100">        rssStub = null;</span>
<span class="source-line-no">4101</span><span id="line-4101">      }</span>
<span class="source-line-no">4102</span><span id="line-4102">      throw ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">4103</span><span id="line-4103">    }</span>
<span class="source-line-no">4104</span><span id="line-4104">  }</span>
<span class="source-line-no">4105</span><span id="line-4105"></span>
<span class="source-line-no">4106</span><span id="line-4106">  /**</span>
<span class="source-line-no">4107</span><span id="line-4107">   * Will ignore the open/close region procedures which already submitted or executed. When master</span>
<span class="source-line-no">4108</span><span id="line-4108">   * had unfinished open/close region procedure and restarted, new active master may send duplicate</span>
<span class="source-line-no">4109</span><span id="line-4109">   * open/close region request to regionserver. The open/close request is submitted to a thread pool</span>
<span class="source-line-no">4110</span><span id="line-4110">   * and execute. So first need a cache for submitted open/close region procedures. After the</span>
<span class="source-line-no">4111</span><span id="line-4111">   * open/close region request executed and report region transition succeed, cache it in executed</span>
<span class="source-line-no">4112</span><span id="line-4112">   * region procedures cache. See {@link #finishRegionProcedure(long)}. After report region</span>
<span class="source-line-no">4113</span><span id="line-4113">   * transition succeed, master will not send the open/close region request to regionserver again.</span>
<span class="source-line-no">4114</span><span id="line-4114">   * And we thought that the ongoing duplicate open/close region request should not be delayed more</span>
<span class="source-line-no">4115</span><span id="line-4115">   * than 600 seconds. So the executed region procedures cache will expire after 600 seconds. See</span>
<span class="source-line-no">4116</span><span id="line-4116">   * HBASE-22404 for more details.</span>
<span class="source-line-no">4117</span><span id="line-4117">   * @param procId the id of the open/close region procedure</span>
<span class="source-line-no">4118</span><span id="line-4118">   * @return true if the procedure can be submitted.</span>
<span class="source-line-no">4119</span><span id="line-4119">   */</span>
<span class="source-line-no">4120</span><span id="line-4120">  boolean submitRegionProcedure(long procId) {</span>
<span class="source-line-no">4121</span><span id="line-4121">    if (procId == -1) {</span>
<span class="source-line-no">4122</span><span id="line-4122">      return true;</span>
<span class="source-line-no">4123</span><span id="line-4123">    }</span>
<span class="source-line-no">4124</span><span id="line-4124">    // Ignore the region procedures which already submitted.</span>
<span class="source-line-no">4125</span><span id="line-4125">    Long previous = submittedRegionProcedures.putIfAbsent(procId, procId);</span>
<span class="source-line-no">4126</span><span id="line-4126">    if (previous != null) {</span>
<span class="source-line-no">4127</span><span id="line-4127">      LOG.warn("Received procedure pid={}, which already submitted, just ignore it", procId);</span>
<span class="source-line-no">4128</span><span id="line-4128">      return false;</span>
<span class="source-line-no">4129</span><span id="line-4129">    }</span>
<span class="source-line-no">4130</span><span id="line-4130">    // Ignore the region procedures which already executed.</span>
<span class="source-line-no">4131</span><span id="line-4131">    if (executedRegionProcedures.getIfPresent(procId) != null) {</span>
<span class="source-line-no">4132</span><span id="line-4132">      LOG.warn("Received procedure pid={}, which already executed, just ignore it", procId);</span>
<span class="source-line-no">4133</span><span id="line-4133">      return false;</span>
<span class="source-line-no">4134</span><span id="line-4134">    }</span>
<span class="source-line-no">4135</span><span id="line-4135">    return true;</span>
<span class="source-line-no">4136</span><span id="line-4136">  }</span>
<span class="source-line-no">4137</span><span id="line-4137"></span>
<span class="source-line-no">4138</span><span id="line-4138">  /**</span>
<span class="source-line-no">4139</span><span id="line-4139">   * See {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">4140</span><span id="line-4140">   * @param procId the id of the open/close region procedure</span>
<span class="source-line-no">4141</span><span id="line-4141">   */</span>
<span class="source-line-no">4142</span><span id="line-4142">  public void finishRegionProcedure(long procId) {</span>
<span class="source-line-no">4143</span><span id="line-4143">    executedRegionProcedures.put(procId, procId);</span>
<span class="source-line-no">4144</span><span id="line-4144">    submittedRegionProcedures.remove(procId);</span>
<span class="source-line-no">4145</span><span id="line-4145">  }</span>
<span class="source-line-no">4146</span><span id="line-4146"></span>
<span class="source-line-no">4147</span><span id="line-4147">  public boolean isShutDown() {</span>
<span class="source-line-no">4148</span><span id="line-4148">    return shutDown;</span>
<span class="source-line-no">4149</span><span id="line-4149">  }</span>
<span class="source-line-no">4150</span><span id="line-4150"></span>
<span class="source-line-no">4151</span><span id="line-4151">  /**</span>
<span class="source-line-no">4152</span><span id="line-4152">   * Force to terminate region server when abort timeout.</span>
<span class="source-line-no">4153</span><span id="line-4153">   */</span>
<span class="source-line-no">4154</span><span id="line-4154">  private static class SystemExitWhenAbortTimeout extends TimerTask {</span>
<span class="source-line-no">4155</span><span id="line-4155"></span>
<span class="source-line-no">4156</span><span id="line-4156">    public SystemExitWhenAbortTimeout() {</span>
<span class="source-line-no">4157</span><span id="line-4157">    }</span>
<span class="source-line-no">4158</span><span id="line-4158"></span>
<span class="source-line-no">4159</span><span id="line-4159">    @Override</span>
<span class="source-line-no">4160</span><span id="line-4160">    public void run() {</span>
<span class="source-line-no">4161</span><span id="line-4161">      LOG.warn("Aborting region server timed out, terminating forcibly"</span>
<span class="source-line-no">4162</span><span id="line-4162">        + " and does not wait for any running shutdown hooks or finalizers to finish their work."</span>
<span class="source-line-no">4163</span><span id="line-4163">        + " Thread dump to stdout.");</span>
<span class="source-line-no">4164</span><span id="line-4164">      Threads.printThreadInfo(System.out, "Zombie HRegionServer");</span>
<span class="source-line-no">4165</span><span id="line-4165">      Runtime.getRuntime().halt(1);</span>
<span class="source-line-no">4166</span><span id="line-4166">    }</span>
<span class="source-line-no">4167</span><span id="line-4167">  }</span>
<span class="source-line-no">4168</span><span id="line-4168"></span>
<span class="source-line-no">4169</span><span id="line-4169">  @InterfaceAudience.Private</span>
<span class="source-line-no">4170</span><span id="line-4170">  public CompactedHFilesDischarger getCompactedHFilesDischarger() {</span>
<span class="source-line-no">4171</span><span id="line-4171">    return compactedFileDischarger;</span>
<span class="source-line-no">4172</span><span id="line-4172">  }</span>
<span class="source-line-no">4173</span><span id="line-4173"></span>
<span class="source-line-no">4174</span><span id="line-4174">  /**</span>
<span class="source-line-no">4175</span><span id="line-4175">   * Return pause time configured in {@link HConstants#HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME}}</span>
<span class="source-line-no">4176</span><span id="line-4176">   * @return pause time</span>
<span class="source-line-no">4177</span><span id="line-4177">   */</span>
<span class="source-line-no">4178</span><span id="line-4178">  @InterfaceAudience.Private</span>
<span class="source-line-no">4179</span><span id="line-4179">  public long getRetryPauseTime() {</span>
<span class="source-line-no">4180</span><span id="line-4180">    return this.retryPauseTime;</span>
<span class="source-line-no">4181</span><span id="line-4181">  }</span>
<span class="source-line-no">4182</span><span id="line-4182"></span>
<span class="source-line-no">4183</span><span id="line-4183">  public Optional&lt;ServerName&gt; getActiveMaster() {</span>
<span class="source-line-no">4184</span><span id="line-4184">    return Optional.ofNullable(masterAddressTracker.getMasterAddress());</span>
<span class="source-line-no">4185</span><span id="line-4185">  }</span>
<span class="source-line-no">4186</span><span id="line-4186"></span>
<span class="source-line-no">4187</span><span id="line-4187">  public List&lt;ServerName&gt; getBackupMasters() {</span>
<span class="source-line-no">4188</span><span id="line-4188">    return masterAddressTracker.getBackupMasters();</span>
<span class="source-line-no">4189</span><span id="line-4189">  }</span>
<span class="source-line-no">4190</span><span id="line-4190"></span>
<span class="source-line-no">4191</span><span id="line-4191">  public Iterator&lt;ServerName&gt; getBootstrapNodes() {</span>
<span class="source-line-no">4192</span><span id="line-4192">    return bootstrapNodeManager.getBootstrapNodes().iterator();</span>
<span class="source-line-no">4193</span><span id="line-4193">  }</span>
<span class="source-line-no">4194</span><span id="line-4194"></span>
<span class="source-line-no">4195</span><span id="line-4195">  public MetaRegionLocationCache getMetaRegionLocationCache() {</span>
<span class="source-line-no">4196</span><span id="line-4196">    return this.metaRegionLocationCache;</span>
<span class="source-line-no">4197</span><span id="line-4197">  }</span>
<span class="source-line-no">4198</span><span id="line-4198"></span>
<span class="source-line-no">4199</span><span id="line-4199">  @InterfaceAudience.Private</span>
<span class="source-line-no">4200</span><span id="line-4200">  public BrokenStoreFileCleaner getBrokenStoreFileCleaner() {</span>
<span class="source-line-no">4201</span><span id="line-4201">    return brokenStoreFileCleaner;</span>
<span class="source-line-no">4202</span><span id="line-4202">  }</span>
<span class="source-line-no">4203</span><span id="line-4203"></span>
<span class="source-line-no">4204</span><span id="line-4204">  @InterfaceAudience.Private</span>
<span class="source-line-no">4205</span><span id="line-4205">  public RSMobFileCleanerChore getRSMobFileCleanerChore() {</span>
<span class="source-line-no">4206</span><span id="line-4206">    return rsMobFileCleanerChore;</span>
<span class="source-line-no">4207</span><span id="line-4207">  }</span>
<span class="source-line-no">4208</span><span id="line-4208"></span>
<span class="source-line-no">4209</span><span id="line-4209">  RSSnapshotVerifier getRsSnapshotVerifier() {</span>
<span class="source-line-no">4210</span><span id="line-4210">    return rsSnapshotVerifier;</span>
<span class="source-line-no">4211</span><span id="line-4211">  }</span>
<span class="source-line-no">4212</span><span id="line-4212">}</span>




























































</pre>
</div>
</main>
</body>
</html>

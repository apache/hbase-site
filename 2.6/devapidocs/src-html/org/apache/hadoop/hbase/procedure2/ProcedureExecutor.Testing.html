<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.hadoop.hbase.procedure2, class: ProcedureExecutor, class: Testing">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="source-line-no">003</span><span id="line-3"> * or more contributor license agreements.  See the NOTICE file</span>
<span class="source-line-no">004</span><span id="line-4"> * distributed with this work for additional information</span>
<span class="source-line-no">005</span><span id="line-5"> * regarding copyright ownership.  The ASF licenses this file</span>
<span class="source-line-no">006</span><span id="line-6"> * to you under the Apache License, Version 2.0 (the</span>
<span class="source-line-no">007</span><span id="line-7"> * "License"); you may not use this file except in compliance</span>
<span class="source-line-no">008</span><span id="line-8"> * with the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">011</span><span id="line-11"> *</span>
<span class="source-line-no">012</span><span id="line-12"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">013</span><span id="line-13"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">014</span><span id="line-14"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">015</span><span id="line-15"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">016</span><span id="line-16"> * limitations under the License.</span>
<span class="source-line-no">017</span><span id="line-17"> */</span>
<span class="source-line-no">018</span><span id="line-18">package org.apache.hadoop.hbase.procedure2;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import edu.umd.cs.findbugs.annotations.Nullable;</span>
<span class="source-line-no">021</span><span id="line-21">import java.io.IOException;</span>
<span class="source-line-no">022</span><span id="line-22">import java.io.UncheckedIOException;</span>
<span class="source-line-no">023</span><span id="line-23">import java.util.ArrayDeque;</span>
<span class="source-line-no">024</span><span id="line-24">import java.util.ArrayList;</span>
<span class="source-line-no">025</span><span id="line-25">import java.util.Arrays;</span>
<span class="source-line-no">026</span><span id="line-26">import java.util.Collection;</span>
<span class="source-line-no">027</span><span id="line-27">import java.util.Comparator;</span>
<span class="source-line-no">028</span><span id="line-28">import java.util.Deque;</span>
<span class="source-line-no">029</span><span id="line-29">import java.util.HashSet;</span>
<span class="source-line-no">030</span><span id="line-30">import java.util.List;</span>
<span class="source-line-no">031</span><span id="line-31">import java.util.PriorityQueue;</span>
<span class="source-line-no">032</span><span id="line-32">import java.util.Set;</span>
<span class="source-line-no">033</span><span id="line-33">import java.util.concurrent.ConcurrentHashMap;</span>
<span class="source-line-no">034</span><span id="line-34">import java.util.concurrent.CopyOnWriteArrayList;</span>
<span class="source-line-no">035</span><span id="line-35">import java.util.concurrent.Executor;</span>
<span class="source-line-no">036</span><span id="line-36">import java.util.concurrent.Executors;</span>
<span class="source-line-no">037</span><span id="line-37">import java.util.concurrent.TimeUnit;</span>
<span class="source-line-no">038</span><span id="line-38">import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="source-line-no">039</span><span id="line-39">import java.util.concurrent.atomic.AtomicInteger;</span>
<span class="source-line-no">040</span><span id="line-40">import java.util.concurrent.atomic.AtomicLong;</span>
<span class="source-line-no">041</span><span id="line-41">import java.util.stream.Collectors;</span>
<span class="source-line-no">042</span><span id="line-42">import java.util.stream.Stream;</span>
<span class="source-line-no">043</span><span id="line-43">import org.apache.hadoop.conf.Configuration;</span>
<span class="source-line-no">044</span><span id="line-44">import org.apache.hadoop.hbase.HConstants;</span>
<span class="source-line-no">045</span><span id="line-45">import org.apache.hadoop.hbase.exceptions.IllegalArgumentIOException;</span>
<span class="source-line-no">046</span><span id="line-46">import org.apache.hadoop.hbase.log.HBaseMarkers;</span>
<span class="source-line-no">047</span><span id="line-47">import org.apache.hadoop.hbase.procedure2.Procedure.LockState;</span>
<span class="source-line-no">048</span><span id="line-48">import org.apache.hadoop.hbase.procedure2.store.ProcedureStore;</span>
<span class="source-line-no">049</span><span id="line-49">import org.apache.hadoop.hbase.procedure2.store.ProcedureStore.ProcedureIterator;</span>
<span class="source-line-no">050</span><span id="line-50">import org.apache.hadoop.hbase.procedure2.store.ProcedureStore.ProcedureStoreListener;</span>
<span class="source-line-no">051</span><span id="line-51">import org.apache.hadoop.hbase.procedure2.trace.ProcedureSpanBuilder;</span>
<span class="source-line-no">052</span><span id="line-52">import org.apache.hadoop.hbase.procedure2.util.StringUtils;</span>
<span class="source-line-no">053</span><span id="line-53">import org.apache.hadoop.hbase.security.User;</span>
<span class="source-line-no">054</span><span id="line-54">import org.apache.hadoop.hbase.trace.TraceUtil;</span>
<span class="source-line-no">055</span><span id="line-55">import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;</span>
<span class="source-line-no">056</span><span id="line-56">import org.apache.hadoop.hbase.util.IdLock;</span>
<span class="source-line-no">057</span><span id="line-57">import org.apache.hadoop.hbase.util.NonceKey;</span>
<span class="source-line-no">058</span><span id="line-58">import org.apache.hadoop.hbase.util.Threads;</span>
<span class="source-line-no">059</span><span id="line-59">import org.apache.yetus.audience.InterfaceAudience;</span>
<span class="source-line-no">060</span><span id="line-60">import org.slf4j.Logger;</span>
<span class="source-line-no">061</span><span id="line-61">import org.slf4j.LoggerFactory;</span>
<span class="source-line-no">062</span><span id="line-62"></span>
<span class="source-line-no">063</span><span id="line-63">import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;</span>
<span class="source-line-no">064</span><span id="line-64">import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;</span>
<span class="source-line-no">065</span><span id="line-65"></span>
<span class="source-line-no">066</span><span id="line-66">import org.apache.hadoop.hbase.shaded.protobuf.generated.ProcedureProtos.ProcedureState;</span>
<span class="source-line-no">067</span><span id="line-67"></span>
<span class="source-line-no">068</span><span id="line-68">/**</span>
<span class="source-line-no">069</span><span id="line-69"> * Thread Pool that executes the submitted procedures. The executor has a ProcedureStore associated.</span>
<span class="source-line-no">070</span><span id="line-70"> * Each operation is logged and on restart the pending procedures are resumed. Unless the Procedure</span>
<span class="source-line-no">071</span><span id="line-71"> * code throws an error (e.g. invalid user input) the procedure will complete (at some point in</span>
<span class="source-line-no">072</span><span id="line-72"> * time), On restart the pending procedures are resumed and the once failed will be rolledback. The</span>
<span class="source-line-no">073</span><span id="line-73"> * user can add procedures to the executor via submitProcedure(proc) check for the finished state</span>
<span class="source-line-no">074</span><span id="line-74"> * via isFinished(procId) and get the result via getResult(procId)</span>
<span class="source-line-no">075</span><span id="line-75"> */</span>
<span class="source-line-no">076</span><span id="line-76">@InterfaceAudience.Private</span>
<span class="source-line-no">077</span><span id="line-77">public class ProcedureExecutor&lt;TEnvironment&gt; {</span>
<span class="source-line-no">078</span><span id="line-78">  private static final Logger LOG = LoggerFactory.getLogger(ProcedureExecutor.class);</span>
<span class="source-line-no">079</span><span id="line-79"></span>
<span class="source-line-no">080</span><span id="line-80">  public static final String CHECK_OWNER_SET_CONF_KEY = "hbase.procedure.check.owner.set";</span>
<span class="source-line-no">081</span><span id="line-81">  private static final boolean DEFAULT_CHECK_OWNER_SET = false;</span>
<span class="source-line-no">082</span><span id="line-82"></span>
<span class="source-line-no">083</span><span id="line-83">  public static final String WORKER_KEEP_ALIVE_TIME_CONF_KEY =</span>
<span class="source-line-no">084</span><span id="line-84">    "hbase.procedure.worker.keep.alive.time.msec";</span>
<span class="source-line-no">085</span><span id="line-85">  private static final long DEFAULT_WORKER_KEEP_ALIVE_TIME = TimeUnit.MINUTES.toMillis(1);</span>
<span class="source-line-no">086</span><span id="line-86"></span>
<span class="source-line-no">087</span><span id="line-87">  public static final String EVICT_TTL_CONF_KEY = "hbase.procedure.cleaner.evict.ttl";</span>
<span class="source-line-no">088</span><span id="line-88">  static final int DEFAULT_EVICT_TTL = 15 * 60000; // 15min</span>
<span class="source-line-no">089</span><span id="line-89"></span>
<span class="source-line-no">090</span><span id="line-90">  public static final String EVICT_ACKED_TTL_CONF_KEY = "hbase.procedure.cleaner.acked.evict.ttl";</span>
<span class="source-line-no">091</span><span id="line-91">  static final int DEFAULT_ACKED_EVICT_TTL = 5 * 60000; // 5min</span>
<span class="source-line-no">092</span><span id="line-92"></span>
<span class="source-line-no">093</span><span id="line-93">  /**</span>
<span class="source-line-no">094</span><span id="line-94">   * {@link #testing} is non-null when ProcedureExecutor is being tested. Tests will try to break PE</span>
<span class="source-line-no">095</span><span id="line-95">   * having it fail at various junctures. When non-null, testing is set to an instance of the below</span>
<span class="source-line-no">096</span><span id="line-96">   * internal {@link Testing} class with flags set for the particular test.</span>
<span class="source-line-no">097</span><span id="line-97">   */</span>
<span class="source-line-no">098</span><span id="line-98">  volatile Testing testing = null;</span>
<span class="source-line-no">099</span><span id="line-99"></span>
<span class="source-line-no">100</span><span id="line-100">  /**</span>
<span class="source-line-no">101</span><span id="line-101">   * Class with parameters describing how to fail/die when in testing-context.</span>
<span class="source-line-no">102</span><span id="line-102">   */</span>
<span class="source-line-no">103</span><span id="line-103">  public static class Testing {</span>
<span class="source-line-no">104</span><span id="line-104">    protected volatile boolean killIfHasParent = true;</span>
<span class="source-line-no">105</span><span id="line-105">    protected volatile boolean killIfSuspended = false;</span>
<span class="source-line-no">106</span><span id="line-106"></span>
<span class="source-line-no">107</span><span id="line-107">    /**</span>
<span class="source-line-no">108</span><span id="line-108">     * Kill the PE BEFORE we store state to the WAL. Good for figuring out if a Procedure is</span>
<span class="source-line-no">109</span><span id="line-109">     * persisting all the state it needs to recover after a crash.</span>
<span class="source-line-no">110</span><span id="line-110">     */</span>
<span class="source-line-no">111</span><span id="line-111">    protected volatile boolean killBeforeStoreUpdate = false;</span>
<span class="source-line-no">112</span><span id="line-112">    protected volatile boolean toggleKillBeforeStoreUpdate = false;</span>
<span class="source-line-no">113</span><span id="line-113"></span>
<span class="source-line-no">114</span><span id="line-114">    /**</span>
<span class="source-line-no">115</span><span id="line-115">     * Set when we want to fail AFTER state has been stored into the WAL. Rarely used. HBASE-20978</span>
<span class="source-line-no">116</span><span id="line-116">     * is about a case where memory-state was being set after store to WAL where a crash could cause</span>
<span class="source-line-no">117</span><span id="line-117">     * us to get stuck. This flag allows killing at what was a vulnerable time.</span>
<span class="source-line-no">118</span><span id="line-118">     */</span>
<span class="source-line-no">119</span><span id="line-119">    protected volatile boolean killAfterStoreUpdate = false;</span>
<span class="source-line-no">120</span><span id="line-120">    protected volatile boolean toggleKillAfterStoreUpdate = false;</span>
<span class="source-line-no">121</span><span id="line-121"></span>
<span class="source-line-no">122</span><span id="line-122">    protected volatile boolean killBeforeStoreUpdateInRollback = false;</span>
<span class="source-line-no">123</span><span id="line-123">    protected volatile boolean toggleKillBeforeStoreUpdateInRollback = false;</span>
<span class="source-line-no">124</span><span id="line-124"></span>
<span class="source-line-no">125</span><span id="line-125">    protected boolean shouldKillBeforeStoreUpdate() {</span>
<span class="source-line-no">126</span><span id="line-126">      final boolean kill = this.killBeforeStoreUpdate;</span>
<span class="source-line-no">127</span><span id="line-127">      if (this.toggleKillBeforeStoreUpdate) {</span>
<span class="source-line-no">128</span><span id="line-128">        this.killBeforeStoreUpdate = !kill;</span>
<span class="source-line-no">129</span><span id="line-129">        LOG.warn("Toggle KILL before store update to: " + this.killBeforeStoreUpdate);</span>
<span class="source-line-no">130</span><span id="line-130">      }</span>
<span class="source-line-no">131</span><span id="line-131">      return kill;</span>
<span class="source-line-no">132</span><span id="line-132">    }</span>
<span class="source-line-no">133</span><span id="line-133"></span>
<span class="source-line-no">134</span><span id="line-134">    protected boolean shouldKillBeforeStoreUpdate(boolean isSuspended, boolean hasParent) {</span>
<span class="source-line-no">135</span><span id="line-135">      if (isSuspended &amp;&amp; !killIfSuspended) {</span>
<span class="source-line-no">136</span><span id="line-136">        return false;</span>
<span class="source-line-no">137</span><span id="line-137">      }</span>
<span class="source-line-no">138</span><span id="line-138">      if (hasParent &amp;&amp; !killIfHasParent) {</span>
<span class="source-line-no">139</span><span id="line-139">        return false;</span>
<span class="source-line-no">140</span><span id="line-140">      }</span>
<span class="source-line-no">141</span><span id="line-141">      return shouldKillBeforeStoreUpdate();</span>
<span class="source-line-no">142</span><span id="line-142">    }</span>
<span class="source-line-no">143</span><span id="line-143"></span>
<span class="source-line-no">144</span><span id="line-144">    protected boolean shouldKillAfterStoreUpdate() {</span>
<span class="source-line-no">145</span><span id="line-145">      final boolean kill = this.killAfterStoreUpdate;</span>
<span class="source-line-no">146</span><span id="line-146">      if (this.toggleKillAfterStoreUpdate) {</span>
<span class="source-line-no">147</span><span id="line-147">        this.killAfterStoreUpdate = !kill;</span>
<span class="source-line-no">148</span><span id="line-148">        LOG.warn("Toggle KILL after store update to: " + this.killAfterStoreUpdate);</span>
<span class="source-line-no">149</span><span id="line-149">      }</span>
<span class="source-line-no">150</span><span id="line-150">      return kill;</span>
<span class="source-line-no">151</span><span id="line-151">    }</span>
<span class="source-line-no">152</span><span id="line-152"></span>
<span class="source-line-no">153</span><span id="line-153">    protected boolean shouldKillAfterStoreUpdate(final boolean isSuspended) {</span>
<span class="source-line-no">154</span><span id="line-154">      return (isSuspended &amp;&amp; !killIfSuspended) ? false : shouldKillAfterStoreUpdate();</span>
<span class="source-line-no">155</span><span id="line-155">    }</span>
<span class="source-line-no">156</span><span id="line-156"></span>
<span class="source-line-no">157</span><span id="line-157">    protected boolean shouldKillBeforeStoreUpdateInRollback() {</span>
<span class="source-line-no">158</span><span id="line-158">      final boolean kill = this.killBeforeStoreUpdateInRollback;</span>
<span class="source-line-no">159</span><span id="line-159">      if (this.toggleKillBeforeStoreUpdateInRollback) {</span>
<span class="source-line-no">160</span><span id="line-160">        this.killBeforeStoreUpdateInRollback = !kill;</span>
<span class="source-line-no">161</span><span id="line-161">        LOG.warn("Toggle KILL before store update in rollback to: "</span>
<span class="source-line-no">162</span><span id="line-162">          + this.killBeforeStoreUpdateInRollback);</span>
<span class="source-line-no">163</span><span id="line-163">      }</span>
<span class="source-line-no">164</span><span id="line-164">      return kill;</span>
<span class="source-line-no">165</span><span id="line-165">    }</span>
<span class="source-line-no">166</span><span id="line-166">  }</span>
<span class="source-line-no">167</span><span id="line-167"></span>
<span class="source-line-no">168</span><span id="line-168">  public interface ProcedureExecutorListener {</span>
<span class="source-line-no">169</span><span id="line-169">    void procedureLoaded(long procId);</span>
<span class="source-line-no">170</span><span id="line-170"></span>
<span class="source-line-no">171</span><span id="line-171">    void procedureAdded(long procId);</span>
<span class="source-line-no">172</span><span id="line-172"></span>
<span class="source-line-no">173</span><span id="line-173">    void procedureFinished(long procId);</span>
<span class="source-line-no">174</span><span id="line-174">  }</span>
<span class="source-line-no">175</span><span id="line-175"></span>
<span class="source-line-no">176</span><span id="line-176">  /**</span>
<span class="source-line-no">177</span><span id="line-177">   * Map the the procId returned by submitProcedure(), the Root-ProcID, to the Procedure. Once a</span>
<span class="source-line-no">178</span><span id="line-178">   * Root-Procedure completes (success or failure), the result will be added to this map. The user</span>
<span class="source-line-no">179</span><span id="line-179">   * of ProcedureExecutor should call getResult(procId) to get the result.</span>
<span class="source-line-no">180</span><span id="line-180">   */</span>
<span class="source-line-no">181</span><span id="line-181">  private final ConcurrentHashMap&lt;Long, CompletedProcedureRetainer&lt;TEnvironment&gt;&gt; completed =</span>
<span class="source-line-no">182</span><span id="line-182">    new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">183</span><span id="line-183"></span>
<span class="source-line-no">184</span><span id="line-184">  /**</span>
<span class="source-line-no">185</span><span id="line-185">   * Map the the procId returned by submitProcedure(), the Root-ProcID, to the RootProcedureState.</span>
<span class="source-line-no">186</span><span id="line-186">   * The RootProcedureState contains the execution stack of the Root-Procedure, It is added to the</span>
<span class="source-line-no">187</span><span id="line-187">   * map by submitProcedure() and removed on procedure completion.</span>
<span class="source-line-no">188</span><span id="line-188">   */</span>
<span class="source-line-no">189</span><span id="line-189">  private final ConcurrentHashMap&lt;Long, RootProcedureState&lt;TEnvironment&gt;&gt; rollbackStack =</span>
<span class="source-line-no">190</span><span id="line-190">    new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">191</span><span id="line-191"></span>
<span class="source-line-no">192</span><span id="line-192">  /**</span>
<span class="source-line-no">193</span><span id="line-193">   * Helper map to lookup the live procedures by ID. This map contains every procedure.</span>
<span class="source-line-no">194</span><span id="line-194">   * root-procedures and subprocedures.</span>
<span class="source-line-no">195</span><span id="line-195">   */</span>
<span class="source-line-no">196</span><span id="line-196">  private final ConcurrentHashMap&lt;Long, Procedure&lt;TEnvironment&gt;&gt; procedures =</span>
<span class="source-line-no">197</span><span id="line-197">    new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">198</span><span id="line-198"></span>
<span class="source-line-no">199</span><span id="line-199">  /**</span>
<span class="source-line-no">200</span><span id="line-200">   * Helper map to lookup whether the procedure already issued from the same client. This map</span>
<span class="source-line-no">201</span><span id="line-201">   * contains every root procedure.</span>
<span class="source-line-no">202</span><span id="line-202">   */</span>
<span class="source-line-no">203</span><span id="line-203">  private final ConcurrentHashMap&lt;NonceKey, Long&gt; nonceKeysToProcIdsMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">204</span><span id="line-204"></span>
<span class="source-line-no">205</span><span id="line-205">  private final CopyOnWriteArrayList&lt;ProcedureExecutorListener&gt; listeners =</span>
<span class="source-line-no">206</span><span id="line-206">    new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="source-line-no">207</span><span id="line-207"></span>
<span class="source-line-no">208</span><span id="line-208">  private Configuration conf;</span>
<span class="source-line-no">209</span><span id="line-209"></span>
<span class="source-line-no">210</span><span id="line-210">  /**</span>
<span class="source-line-no">211</span><span id="line-211">   * Created in the {@link #init(int, boolean)} method. Destroyed in {@link #join()} (FIX! Doing</span>
<span class="source-line-no">212</span><span id="line-212">   * resource handling rather than observing in a #join is unexpected). Overridden when we do the</span>
<span class="source-line-no">213</span><span id="line-213">   * ProcedureTestingUtility.testRecoveryAndDoubleExecution trickery (Should be ok).</span>
<span class="source-line-no">214</span><span id="line-214">   */</span>
<span class="source-line-no">215</span><span id="line-215">  private ThreadGroup threadGroup;</span>
<span class="source-line-no">216</span><span id="line-216"></span>
<span class="source-line-no">217</span><span id="line-217">  /**</span>
<span class="source-line-no">218</span><span id="line-218">   * Created in the {@link #init(int, boolean)} method. Terminated in {@link #join()} (FIX! Doing</span>
<span class="source-line-no">219</span><span id="line-219">   * resource handling rather than observing in a #join is unexpected). Overridden when we do the</span>
<span class="source-line-no">220</span><span id="line-220">   * ProcedureTestingUtility.testRecoveryAndDoubleExecution trickery (Should be ok).</span>
<span class="source-line-no">221</span><span id="line-221">   */</span>
<span class="source-line-no">222</span><span id="line-222">  private CopyOnWriteArrayList&lt;WorkerThread&gt; workerThreads;</span>
<span class="source-line-no">223</span><span id="line-223"></span>
<span class="source-line-no">224</span><span id="line-224">  /**</span>
<span class="source-line-no">225</span><span id="line-225">   * Created in the {@link #init(int, boolean)} method. Terminated in {@link #join()} (FIX! Doing</span>
<span class="source-line-no">226</span><span id="line-226">   * resource handling rather than observing in a #join is unexpected). Overridden when we do the</span>
<span class="source-line-no">227</span><span id="line-227">   * ProcedureTestingUtility.testRecoveryAndDoubleExecution trickery (Should be ok).</span>
<span class="source-line-no">228</span><span id="line-228">   */</span>
<span class="source-line-no">229</span><span id="line-229">  private TimeoutExecutorThread&lt;TEnvironment&gt; timeoutExecutor;</span>
<span class="source-line-no">230</span><span id="line-230"></span>
<span class="source-line-no">231</span><span id="line-231">  /**</span>
<span class="source-line-no">232</span><span id="line-232">   * WorkerMonitor check for stuck workers and new worker thread when necessary, for example if</span>
<span class="source-line-no">233</span><span id="line-233">   * there is no worker to assign meta, it will new worker thread for it, so it is very important.</span>
<span class="source-line-no">234</span><span id="line-234">   * TimeoutExecutor execute many tasks like DeadServerMetricRegionChore RegionInTransitionChore and</span>
<span class="source-line-no">235</span><span id="line-235">   * so on, some tasks may execute for a long time so will block other tasks like WorkerMonitor, so</span>
<span class="source-line-no">236</span><span id="line-236">   * use a dedicated thread for executing WorkerMonitor.</span>
<span class="source-line-no">237</span><span id="line-237">   */</span>
<span class="source-line-no">238</span><span id="line-238">  private TimeoutExecutorThread&lt;TEnvironment&gt; workerMonitorExecutor;</span>
<span class="source-line-no">239</span><span id="line-239"></span>
<span class="source-line-no">240</span><span id="line-240">  private int corePoolSize;</span>
<span class="source-line-no">241</span><span id="line-241">  private int maxPoolSize;</span>
<span class="source-line-no">242</span><span id="line-242"></span>
<span class="source-line-no">243</span><span id="line-243">  private volatile long keepAliveTime;</span>
<span class="source-line-no">244</span><span id="line-244"></span>
<span class="source-line-no">245</span><span id="line-245">  /**</span>
<span class="source-line-no">246</span><span id="line-246">   * Scheduler/Queue that contains runnable procedures.</span>
<span class="source-line-no">247</span><span id="line-247">   */</span>
<span class="source-line-no">248</span><span id="line-248">  private final ProcedureScheduler scheduler;</span>
<span class="source-line-no">249</span><span id="line-249"></span>
<span class="source-line-no">250</span><span id="line-250">  private final Executor forceUpdateExecutor = Executors.newSingleThreadExecutor(</span>
<span class="source-line-no">251</span><span id="line-251">    new ThreadFactoryBuilder().setDaemon(true).setNameFormat("Force-Update-PEWorker-%d").build());</span>
<span class="source-line-no">252</span><span id="line-252"></span>
<span class="source-line-no">253</span><span id="line-253">  private final AtomicLong lastProcId = new AtomicLong(-1);</span>
<span class="source-line-no">254</span><span id="line-254">  private final AtomicLong workerId = new AtomicLong(0);</span>
<span class="source-line-no">255</span><span id="line-255">  private final AtomicInteger activeExecutorCount = new AtomicInteger(0);</span>
<span class="source-line-no">256</span><span id="line-256">  private final AtomicBoolean running = new AtomicBoolean(false);</span>
<span class="source-line-no">257</span><span id="line-257">  private final TEnvironment environment;</span>
<span class="source-line-no">258</span><span id="line-258">  private final ProcedureStore store;</span>
<span class="source-line-no">259</span><span id="line-259"></span>
<span class="source-line-no">260</span><span id="line-260">  private final boolean checkOwnerSet;</span>
<span class="source-line-no">261</span><span id="line-261"></span>
<span class="source-line-no">262</span><span id="line-262">  // To prevent concurrent execution of the same procedure.</span>
<span class="source-line-no">263</span><span id="line-263">  // For some rare cases, especially if the procedure uses ProcedureEvent, it is possible that the</span>
<span class="source-line-no">264</span><span id="line-264">  // procedure is woken up before we finish the suspend which causes the same procedures to be</span>
<span class="source-line-no">265</span><span id="line-265">  // executed in parallel. This does lead to some problems, see HBASE-20939&amp;HBASE-20949, and is also</span>
<span class="source-line-no">266</span><span id="line-266">  // a bit confusing to the developers. So here we introduce this lock to prevent the concurrent</span>
<span class="source-line-no">267</span><span id="line-267">  // execution of the same procedure.</span>
<span class="source-line-no">268</span><span id="line-268">  private final IdLock procExecutionLock = new IdLock();</span>
<span class="source-line-no">269</span><span id="line-269"></span>
<span class="source-line-no">270</span><span id="line-270">  public ProcedureExecutor(final Configuration conf, final TEnvironment environment,</span>
<span class="source-line-no">271</span><span id="line-271">    final ProcedureStore store) {</span>
<span class="source-line-no">272</span><span id="line-272">    this(conf, environment, store, new SimpleProcedureScheduler());</span>
<span class="source-line-no">273</span><span id="line-273">  }</span>
<span class="source-line-no">274</span><span id="line-274"></span>
<span class="source-line-no">275</span><span id="line-275">  private boolean isRootFinished(Procedure&lt;?&gt; proc) {</span>
<span class="source-line-no">276</span><span id="line-276">    Procedure&lt;?&gt; rootProc = procedures.get(proc.getRootProcId());</span>
<span class="source-line-no">277</span><span id="line-277">    return rootProc == null || rootProc.isFinished();</span>
<span class="source-line-no">278</span><span id="line-278">  }</span>
<span class="source-line-no">279</span><span id="line-279"></span>
<span class="source-line-no">280</span><span id="line-280">  private void forceUpdateProcedure(long procId) throws IOException {</span>
<span class="source-line-no">281</span><span id="line-281">    IdLock.Entry lockEntry = procExecutionLock.getLockEntry(procId);</span>
<span class="source-line-no">282</span><span id="line-282">    try {</span>
<span class="source-line-no">283</span><span id="line-283">      Procedure&lt;TEnvironment&gt; proc = procedures.get(procId);</span>
<span class="source-line-no">284</span><span id="line-284">      if (proc != null) {</span>
<span class="source-line-no">285</span><span id="line-285">        if (proc.isFinished() &amp;&amp; proc.hasParent() &amp;&amp; isRootFinished(proc)) {</span>
<span class="source-line-no">286</span><span id="line-286">          LOG.debug("Procedure {} has already been finished and parent is succeeded,"</span>
<span class="source-line-no">287</span><span id="line-287">            + " skip force updating", proc);</span>
<span class="source-line-no">288</span><span id="line-288">          return;</span>
<span class="source-line-no">289</span><span id="line-289">        }</span>
<span class="source-line-no">290</span><span id="line-290">      } else {</span>
<span class="source-line-no">291</span><span id="line-291">        CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = completed.get(procId);</span>
<span class="source-line-no">292</span><span id="line-292">        if (retainer == null || retainer.getProcedure() instanceof FailedProcedure) {</span>
<span class="source-line-no">293</span><span id="line-293">          LOG.debug("No pending procedure with id = {}, skip force updating.", procId);</span>
<span class="source-line-no">294</span><span id="line-294">          return;</span>
<span class="source-line-no">295</span><span id="line-295">        }</span>
<span class="source-line-no">296</span><span id="line-296">        long evictTtl = conf.getInt(EVICT_TTL_CONF_KEY, DEFAULT_EVICT_TTL);</span>
<span class="source-line-no">297</span><span id="line-297">        long evictAckTtl = conf.getInt(EVICT_ACKED_TTL_CONF_KEY, DEFAULT_ACKED_EVICT_TTL);</span>
<span class="source-line-no">298</span><span id="line-298">        if (retainer.isExpired(EnvironmentEdgeManager.currentTime(), evictTtl, evictAckTtl)) {</span>
<span class="source-line-no">299</span><span id="line-299">          LOG.debug("Procedure {} has already been finished and expired, skip force updating",</span>
<span class="source-line-no">300</span><span id="line-300">            procId);</span>
<span class="source-line-no">301</span><span id="line-301">          return;</span>
<span class="source-line-no">302</span><span id="line-302">        }</span>
<span class="source-line-no">303</span><span id="line-303">        proc = retainer.getProcedure();</span>
<span class="source-line-no">304</span><span id="line-304">      }</span>
<span class="source-line-no">305</span><span id="line-305">      LOG.debug("Force update procedure {}", proc);</span>
<span class="source-line-no">306</span><span id="line-306">      store.update(proc);</span>
<span class="source-line-no">307</span><span id="line-307">    } finally {</span>
<span class="source-line-no">308</span><span id="line-308">      procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">309</span><span id="line-309">    }</span>
<span class="source-line-no">310</span><span id="line-310">  }</span>
<span class="source-line-no">311</span><span id="line-311"></span>
<span class="source-line-no">312</span><span id="line-312">  public ProcedureExecutor(final Configuration conf, final TEnvironment environment,</span>
<span class="source-line-no">313</span><span id="line-313">    final ProcedureStore store, final ProcedureScheduler scheduler) {</span>
<span class="source-line-no">314</span><span id="line-314">    this.environment = environment;</span>
<span class="source-line-no">315</span><span id="line-315">    this.scheduler = scheduler;</span>
<span class="source-line-no">316</span><span id="line-316">    this.store = store;</span>
<span class="source-line-no">317</span><span id="line-317">    this.conf = conf;</span>
<span class="source-line-no">318</span><span id="line-318">    this.checkOwnerSet = conf.getBoolean(CHECK_OWNER_SET_CONF_KEY, DEFAULT_CHECK_OWNER_SET);</span>
<span class="source-line-no">319</span><span id="line-319">    refreshConfiguration(conf);</span>
<span class="source-line-no">320</span><span id="line-320">    store.registerListener(new ProcedureStoreListener() {</span>
<span class="source-line-no">321</span><span id="line-321"></span>
<span class="source-line-no">322</span><span id="line-322">      @Override</span>
<span class="source-line-no">323</span><span id="line-323">      public void forceUpdate(long[] procIds) {</span>
<span class="source-line-no">324</span><span id="line-324">        Arrays.stream(procIds).forEach(procId -&gt; forceUpdateExecutor.execute(() -&gt; {</span>
<span class="source-line-no">325</span><span id="line-325">          try {</span>
<span class="source-line-no">326</span><span id="line-326">            forceUpdateProcedure(procId);</span>
<span class="source-line-no">327</span><span id="line-327">          } catch (IOException e) {</span>
<span class="source-line-no">328</span><span id="line-328">            LOG.warn("Failed to force update procedure with pid={}", procId);</span>
<span class="source-line-no">329</span><span id="line-329">          }</span>
<span class="source-line-no">330</span><span id="line-330">        }));</span>
<span class="source-line-no">331</span><span id="line-331">      }</span>
<span class="source-line-no">332</span><span id="line-332">    });</span>
<span class="source-line-no">333</span><span id="line-333">  }</span>
<span class="source-line-no">334</span><span id="line-334"></span>
<span class="source-line-no">335</span><span id="line-335">  private void load(final boolean abortOnCorruption) throws IOException {</span>
<span class="source-line-no">336</span><span id="line-336">    Preconditions.checkArgument(completed.isEmpty(), "completed not empty: %s", completed);</span>
<span class="source-line-no">337</span><span id="line-337">    Preconditions.checkArgument(rollbackStack.isEmpty(), "rollback state not empty: %s",</span>
<span class="source-line-no">338</span><span id="line-338">      rollbackStack);</span>
<span class="source-line-no">339</span><span id="line-339">    Preconditions.checkArgument(procedures.isEmpty(), "procedure map not empty: %s", procedures);</span>
<span class="source-line-no">340</span><span id="line-340">    Preconditions.checkArgument(scheduler.size() == 0, "scheduler queue not empty: %s", scheduler);</span>
<span class="source-line-no">341</span><span id="line-341"></span>
<span class="source-line-no">342</span><span id="line-342">    store.load(new ProcedureStore.ProcedureLoader() {</span>
<span class="source-line-no">343</span><span id="line-343">      @Override</span>
<span class="source-line-no">344</span><span id="line-344">      public void setMaxProcId(long maxProcId) {</span>
<span class="source-line-no">345</span><span id="line-345">        assert lastProcId.get() &lt; 0 : "expected only one call to setMaxProcId()";</span>
<span class="source-line-no">346</span><span id="line-346">        lastProcId.set(maxProcId);</span>
<span class="source-line-no">347</span><span id="line-347">      }</span>
<span class="source-line-no">348</span><span id="line-348"></span>
<span class="source-line-no">349</span><span id="line-349">      @Override</span>
<span class="source-line-no">350</span><span id="line-350">      public void load(ProcedureIterator procIter) throws IOException {</span>
<span class="source-line-no">351</span><span id="line-351">        loadProcedures(procIter);</span>
<span class="source-line-no">352</span><span id="line-352">      }</span>
<span class="source-line-no">353</span><span id="line-353"></span>
<span class="source-line-no">354</span><span id="line-354">      @Override</span>
<span class="source-line-no">355</span><span id="line-355">      public void handleCorrupted(ProcedureIterator procIter) throws IOException {</span>
<span class="source-line-no">356</span><span id="line-356">        int corruptedCount = 0;</span>
<span class="source-line-no">357</span><span id="line-357">        while (procIter.hasNext()) {</span>
<span class="source-line-no">358</span><span id="line-358">          Procedure&lt;?&gt; proc = procIter.next();</span>
<span class="source-line-no">359</span><span id="line-359">          LOG.error("Corrupt " + proc);</span>
<span class="source-line-no">360</span><span id="line-360">          corruptedCount++;</span>
<span class="source-line-no">361</span><span id="line-361">        }</span>
<span class="source-line-no">362</span><span id="line-362">        if (abortOnCorruption &amp;&amp; corruptedCount &gt; 0) {</span>
<span class="source-line-no">363</span><span id="line-363">          throw new IOException("found " + corruptedCount + " corrupted procedure(s) on replay");</span>
<span class="source-line-no">364</span><span id="line-364">        }</span>
<span class="source-line-no">365</span><span id="line-365">      }</span>
<span class="source-line-no">366</span><span id="line-366">    });</span>
<span class="source-line-no">367</span><span id="line-367">  }</span>
<span class="source-line-no">368</span><span id="line-368"></span>
<span class="source-line-no">369</span><span id="line-369">  private void restoreLock(Procedure&lt;TEnvironment&gt; proc, Set&lt;Long&gt; restored) {</span>
<span class="source-line-no">370</span><span id="line-370">    proc.restoreLock(getEnvironment());</span>
<span class="source-line-no">371</span><span id="line-371">    restored.add(proc.getProcId());</span>
<span class="source-line-no">372</span><span id="line-372">  }</span>
<span class="source-line-no">373</span><span id="line-373"></span>
<span class="source-line-no">374</span><span id="line-374">  private void restoreLocks(Deque&lt;Procedure&lt;TEnvironment&gt;&gt; stack, Set&lt;Long&gt; restored) {</span>
<span class="source-line-no">375</span><span id="line-375">    while (!stack.isEmpty()) {</span>
<span class="source-line-no">376</span><span id="line-376">      restoreLock(stack.pop(), restored);</span>
<span class="source-line-no">377</span><span id="line-377">    }</span>
<span class="source-line-no">378</span><span id="line-378">  }</span>
<span class="source-line-no">379</span><span id="line-379"></span>
<span class="source-line-no">380</span><span id="line-380">  // Restore the locks for all the procedures.</span>
<span class="source-line-no">381</span><span id="line-381">  // Notice that we need to restore the locks starting from the root proc, otherwise there will be</span>
<span class="source-line-no">382</span><span id="line-382">  // problem that a sub procedure may hold the exclusive lock first and then we are stuck when</span>
<span class="source-line-no">383</span><span id="line-383">  // calling the acquireLock method for the parent procedure.</span>
<span class="source-line-no">384</span><span id="line-384">  // The algorithm is straight-forward:</span>
<span class="source-line-no">385</span><span id="line-385">  // 1. Use a set to record the procedures which locks have already been restored.</span>
<span class="source-line-no">386</span><span id="line-386">  // 2. Use a stack to store the hierarchy of the procedures</span>
<span class="source-line-no">387</span><span id="line-387">  // 3. For all the procedure, we will first try to find its parent and push it into the stack,</span>
<span class="source-line-no">388</span><span id="line-388">  // unless</span>
<span class="source-line-no">389</span><span id="line-389">  // a. We have no parent, i.e, we are the root procedure</span>
<span class="source-line-no">390</span><span id="line-390">  // b. The lock has already been restored(by checking the set introduced in #1)</span>
<span class="source-line-no">391</span><span id="line-391">  // then we start to pop the stack and call acquireLock for each procedure.</span>
<span class="source-line-no">392</span><span id="line-392">  // Notice that this should be done for all procedures, not only the ones in runnableList.</span>
<span class="source-line-no">393</span><span id="line-393">  private void restoreLocks() {</span>
<span class="source-line-no">394</span><span id="line-394">    Set&lt;Long&gt; restored = new HashSet&lt;&gt;();</span>
<span class="source-line-no">395</span><span id="line-395">    Deque&lt;Procedure&lt;TEnvironment&gt;&gt; stack = new ArrayDeque&lt;&gt;();</span>
<span class="source-line-no">396</span><span id="line-396">    procedures.values().forEach(proc -&gt; {</span>
<span class="source-line-no">397</span><span id="line-397">      for (;;) {</span>
<span class="source-line-no">398</span><span id="line-398">        if (restored.contains(proc.getProcId())) {</span>
<span class="source-line-no">399</span><span id="line-399">          restoreLocks(stack, restored);</span>
<span class="source-line-no">400</span><span id="line-400">          return;</span>
<span class="source-line-no">401</span><span id="line-401">        }</span>
<span class="source-line-no">402</span><span id="line-402">        if (!proc.hasParent()) {</span>
<span class="source-line-no">403</span><span id="line-403">          restoreLock(proc, restored);</span>
<span class="source-line-no">404</span><span id="line-404">          restoreLocks(stack, restored);</span>
<span class="source-line-no">405</span><span id="line-405">          return;</span>
<span class="source-line-no">406</span><span id="line-406">        }</span>
<span class="source-line-no">407</span><span id="line-407">        stack.push(proc);</span>
<span class="source-line-no">408</span><span id="line-408">        proc = procedures.get(proc.getParentProcId());</span>
<span class="source-line-no">409</span><span id="line-409">      }</span>
<span class="source-line-no">410</span><span id="line-410">    });</span>
<span class="source-line-no">411</span><span id="line-411">  }</span>
<span class="source-line-no">412</span><span id="line-412"></span>
<span class="source-line-no">413</span><span id="line-413">  private void initializeStacks(ProcedureIterator procIter,</span>
<span class="source-line-no">414</span><span id="line-414">    List&lt;Procedure&lt;TEnvironment&gt;&gt; runnableList, List&lt;Procedure&lt;TEnvironment&gt;&gt; failedList,</span>
<span class="source-line-no">415</span><span id="line-415">    List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingList, List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingTimeoutList)</span>
<span class="source-line-no">416</span><span id="line-416">    throws IOException {</span>
<span class="source-line-no">417</span><span id="line-417">    procIter.reset();</span>
<span class="source-line-no">418</span><span id="line-418">    while (procIter.hasNext()) {</span>
<span class="source-line-no">419</span><span id="line-419">      if (procIter.isNextFinished()) {</span>
<span class="source-line-no">420</span><span id="line-420">        procIter.skipNext();</span>
<span class="source-line-no">421</span><span id="line-421">        continue;</span>
<span class="source-line-no">422</span><span id="line-422">      }</span>
<span class="source-line-no">423</span><span id="line-423"></span>
<span class="source-line-no">424</span><span id="line-424">      @SuppressWarnings("unchecked")</span>
<span class="source-line-no">425</span><span id="line-425">      Procedure&lt;TEnvironment&gt; proc = procIter.next();</span>
<span class="source-line-no">426</span><span id="line-426">      assert !(proc.isFinished() &amp;&amp; !proc.hasParent()) : "unexpected completed proc=" + proc;</span>
<span class="source-line-no">427</span><span id="line-427">      LOG.debug("Loading {}", proc);</span>
<span class="source-line-no">428</span><span id="line-428">      Long rootProcId = getRootProcedureId(proc);</span>
<span class="source-line-no">429</span><span id="line-429">      // The orphan procedures will be passed to handleCorrupted, so add an assert here</span>
<span class="source-line-no">430</span><span id="line-430">      assert rootProcId != null;</span>
<span class="source-line-no">431</span><span id="line-431"></span>
<span class="source-line-no">432</span><span id="line-432">      if (proc.hasParent()) {</span>
<span class="source-line-no">433</span><span id="line-433">        Procedure&lt;TEnvironment&gt; parent = procedures.get(proc.getParentProcId());</span>
<span class="source-line-no">434</span><span id="line-434">        if (parent != null &amp;&amp; !proc.isFinished()) {</span>
<span class="source-line-no">435</span><span id="line-435">          parent.incChildrenLatch();</span>
<span class="source-line-no">436</span><span id="line-436">        }</span>
<span class="source-line-no">437</span><span id="line-437">      }</span>
<span class="source-line-no">438</span><span id="line-438"></span>
<span class="source-line-no">439</span><span id="line-439">      RootProcedureState&lt;TEnvironment&gt; procStack = rollbackStack.get(rootProcId);</span>
<span class="source-line-no">440</span><span id="line-440">      procStack.loadStack(proc);</span>
<span class="source-line-no">441</span><span id="line-441"></span>
<span class="source-line-no">442</span><span id="line-442">      proc.setRootProcId(rootProcId);</span>
<span class="source-line-no">443</span><span id="line-443">      switch (proc.getState()) {</span>
<span class="source-line-no">444</span><span id="line-444">        case RUNNABLE:</span>
<span class="source-line-no">445</span><span id="line-445">          runnableList.add(proc);</span>
<span class="source-line-no">446</span><span id="line-446">          break;</span>
<span class="source-line-no">447</span><span id="line-447">        case WAITING:</span>
<span class="source-line-no">448</span><span id="line-448">          waitingList.add(proc);</span>
<span class="source-line-no">449</span><span id="line-449">          break;</span>
<span class="source-line-no">450</span><span id="line-450">        case WAITING_TIMEOUT:</span>
<span class="source-line-no">451</span><span id="line-451">          waitingTimeoutList.add(proc);</span>
<span class="source-line-no">452</span><span id="line-452">          break;</span>
<span class="source-line-no">453</span><span id="line-453">        case FAILED:</span>
<span class="source-line-no">454</span><span id="line-454">          failedList.add(proc);</span>
<span class="source-line-no">455</span><span id="line-455">          break;</span>
<span class="source-line-no">456</span><span id="line-456">        case ROLLEDBACK:</span>
<span class="source-line-no">457</span><span id="line-457">        case INITIALIZING:</span>
<span class="source-line-no">458</span><span id="line-458">          String msg = "Unexpected " + proc.getState() + " state for " + proc;</span>
<span class="source-line-no">459</span><span id="line-459">          LOG.error(msg);</span>
<span class="source-line-no">460</span><span id="line-460">          throw new UnsupportedOperationException(msg);</span>
<span class="source-line-no">461</span><span id="line-461">        default:</span>
<span class="source-line-no">462</span><span id="line-462">          break;</span>
<span class="source-line-no">463</span><span id="line-463">      }</span>
<span class="source-line-no">464</span><span id="line-464">    }</span>
<span class="source-line-no">465</span><span id="line-465">    rollbackStack.forEach((rootProcId, procStack) -&gt; {</span>
<span class="source-line-no">466</span><span id="line-466">      if (procStack.getSubproceduresStack() != null) {</span>
<span class="source-line-no">467</span><span id="line-467">        // if we have already record some stack ids, it means we support rollback</span>
<span class="source-line-no">468</span><span id="line-468">        procStack.setRollbackSupported(true);</span>
<span class="source-line-no">469</span><span id="line-469">      } else {</span>
<span class="source-line-no">470</span><span id="line-470">        // otherwise, test the root procedure to see if we support rollback</span>
<span class="source-line-no">471</span><span id="line-471">        procStack.setRollbackSupported(procedures.get(rootProcId).isRollbackSupported());</span>
<span class="source-line-no">472</span><span id="line-472">      }</span>
<span class="source-line-no">473</span><span id="line-473">    });</span>
<span class="source-line-no">474</span><span id="line-474">  }</span>
<span class="source-line-no">475</span><span id="line-475"></span>
<span class="source-line-no">476</span><span id="line-476">  private void processWaitingProcedures(List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingList,</span>
<span class="source-line-no">477</span><span id="line-477">    List&lt;Procedure&lt;TEnvironment&gt;&gt; runnableList) {</span>
<span class="source-line-no">478</span><span id="line-478">    waitingList.forEach(proc -&gt; {</span>
<span class="source-line-no">479</span><span id="line-479">      if (!proc.hasChildren()) {</span>
<span class="source-line-no">480</span><span id="line-480">        // Normally, WAITING procedures should be waken by its children. But, there is a case that,</span>
<span class="source-line-no">481</span><span id="line-481">        // all the children are successful and before they can wake up their parent procedure, the</span>
<span class="source-line-no">482</span><span id="line-482">        // master was killed. So, during recovering the procedures from ProcedureWal, its children</span>
<span class="source-line-no">483</span><span id="line-483">        // are not loaded because of their SUCCESS state. So we need to continue to run this WAITING</span>
<span class="source-line-no">484</span><span id="line-484">        // procedure. But before executing, we need to set its state to RUNNABLE, otherwise, a</span>
<span class="source-line-no">485</span><span id="line-485">        // exception will throw:</span>
<span class="source-line-no">486</span><span id="line-486">        // Preconditions.checkArgument(procedure.getState() == ProcedureState.RUNNABLE,</span>
<span class="source-line-no">487</span><span id="line-487">        // "NOT RUNNABLE! " + procedure.toString());</span>
<span class="source-line-no">488</span><span id="line-488">        proc.setState(ProcedureState.RUNNABLE);</span>
<span class="source-line-no">489</span><span id="line-489">        runnableList.add(proc);</span>
<span class="source-line-no">490</span><span id="line-490">      } else {</span>
<span class="source-line-no">491</span><span id="line-491">        proc.afterReplay(getEnvironment());</span>
<span class="source-line-no">492</span><span id="line-492">      }</span>
<span class="source-line-no">493</span><span id="line-493">    });</span>
<span class="source-line-no">494</span><span id="line-494">  }</span>
<span class="source-line-no">495</span><span id="line-495"></span>
<span class="source-line-no">496</span><span id="line-496">  private void processWaitingTimeoutProcedures(List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingTimeoutList) {</span>
<span class="source-line-no">497</span><span id="line-497">    waitingTimeoutList.forEach(proc -&gt; {</span>
<span class="source-line-no">498</span><span id="line-498">      proc.afterReplay(getEnvironment());</span>
<span class="source-line-no">499</span><span id="line-499">      timeoutExecutor.add(proc);</span>
<span class="source-line-no">500</span><span id="line-500">    });</span>
<span class="source-line-no">501</span><span id="line-501">  }</span>
<span class="source-line-no">502</span><span id="line-502"></span>
<span class="source-line-no">503</span><span id="line-503">  private void pushProceduresAfterLoad(List&lt;Procedure&lt;TEnvironment&gt;&gt; runnableList,</span>
<span class="source-line-no">504</span><span id="line-504">    List&lt;Procedure&lt;TEnvironment&gt;&gt; failedList) {</span>
<span class="source-line-no">505</span><span id="line-505">    failedList.forEach(scheduler::addBack);</span>
<span class="source-line-no">506</span><span id="line-506">    runnableList.forEach(p -&gt; {</span>
<span class="source-line-no">507</span><span id="line-507">      p.afterReplay(getEnvironment());</span>
<span class="source-line-no">508</span><span id="line-508">      if (!p.hasParent()) {</span>
<span class="source-line-no">509</span><span id="line-509">        sendProcedureLoadedNotification(p.getProcId());</span>
<span class="source-line-no">510</span><span id="line-510">      }</span>
<span class="source-line-no">511</span><span id="line-511">      scheduler.addBack(p);</span>
<span class="source-line-no">512</span><span id="line-512">    });</span>
<span class="source-line-no">513</span><span id="line-513">  }</span>
<span class="source-line-no">514</span><span id="line-514"></span>
<span class="source-line-no">515</span><span id="line-515">  private void loadProcedures(ProcedureIterator procIter) throws IOException {</span>
<span class="source-line-no">516</span><span id="line-516">    // 1. Build the rollback stack</span>
<span class="source-line-no">517</span><span id="line-517">    int runnableCount = 0;</span>
<span class="source-line-no">518</span><span id="line-518">    int failedCount = 0;</span>
<span class="source-line-no">519</span><span id="line-519">    int waitingCount = 0;</span>
<span class="source-line-no">520</span><span id="line-520">    int waitingTimeoutCount = 0;</span>
<span class="source-line-no">521</span><span id="line-521">    while (procIter.hasNext()) {</span>
<span class="source-line-no">522</span><span id="line-522">      boolean finished = procIter.isNextFinished();</span>
<span class="source-line-no">523</span><span id="line-523">      @SuppressWarnings("unchecked")</span>
<span class="source-line-no">524</span><span id="line-524">      Procedure&lt;TEnvironment&gt; proc = procIter.next();</span>
<span class="source-line-no">525</span><span id="line-525">      NonceKey nonceKey = proc.getNonceKey();</span>
<span class="source-line-no">526</span><span id="line-526">      long procId = proc.getProcId();</span>
<span class="source-line-no">527</span><span id="line-527"></span>
<span class="source-line-no">528</span><span id="line-528">      if (finished) {</span>
<span class="source-line-no">529</span><span id="line-529">        completed.put(proc.getProcId(), new CompletedProcedureRetainer&lt;&gt;(proc));</span>
<span class="source-line-no">530</span><span id="line-530">        LOG.debug("Completed {}", proc);</span>
<span class="source-line-no">531</span><span id="line-531">      } else {</span>
<span class="source-line-no">532</span><span id="line-532">        if (!proc.hasParent()) {</span>
<span class="source-line-no">533</span><span id="line-533">          assert !proc.isFinished() : "unexpected finished procedure";</span>
<span class="source-line-no">534</span><span id="line-534">          rollbackStack.put(proc.getProcId(), new RootProcedureState&lt;&gt;());</span>
<span class="source-line-no">535</span><span id="line-535">        }</span>
<span class="source-line-no">536</span><span id="line-536"></span>
<span class="source-line-no">537</span><span id="line-537">        // add the procedure to the map</span>
<span class="source-line-no">538</span><span id="line-538">        proc.beforeReplay(getEnvironment());</span>
<span class="source-line-no">539</span><span id="line-539">        procedures.put(proc.getProcId(), proc);</span>
<span class="source-line-no">540</span><span id="line-540">        switch (proc.getState()) {</span>
<span class="source-line-no">541</span><span id="line-541">          case RUNNABLE:</span>
<span class="source-line-no">542</span><span id="line-542">            runnableCount++;</span>
<span class="source-line-no">543</span><span id="line-543">            break;</span>
<span class="source-line-no">544</span><span id="line-544">          case FAILED:</span>
<span class="source-line-no">545</span><span id="line-545">            failedCount++;</span>
<span class="source-line-no">546</span><span id="line-546">            break;</span>
<span class="source-line-no">547</span><span id="line-547">          case WAITING:</span>
<span class="source-line-no">548</span><span id="line-548">            waitingCount++;</span>
<span class="source-line-no">549</span><span id="line-549">            break;</span>
<span class="source-line-no">550</span><span id="line-550">          case WAITING_TIMEOUT:</span>
<span class="source-line-no">551</span><span id="line-551">            waitingTimeoutCount++;</span>
<span class="source-line-no">552</span><span id="line-552">            break;</span>
<span class="source-line-no">553</span><span id="line-553">          default:</span>
<span class="source-line-no">554</span><span id="line-554">            break;</span>
<span class="source-line-no">555</span><span id="line-555">        }</span>
<span class="source-line-no">556</span><span id="line-556">      }</span>
<span class="source-line-no">557</span><span id="line-557"></span>
<span class="source-line-no">558</span><span id="line-558">      if (nonceKey != null) {</span>
<span class="source-line-no">559</span><span id="line-559">        nonceKeysToProcIdsMap.put(nonceKey, procId); // add the nonce to the map</span>
<span class="source-line-no">560</span><span id="line-560">      }</span>
<span class="source-line-no">561</span><span id="line-561">    }</span>
<span class="source-line-no">562</span><span id="line-562"></span>
<span class="source-line-no">563</span><span id="line-563">    // 2. Initialize the stacks: In the old implementation, for procedures in FAILED state, we will</span>
<span class="source-line-no">564</span><span id="line-564">    // push it into the ProcedureScheduler directly to execute the rollback. But this does not work</span>
<span class="source-line-no">565</span><span id="line-565">    // after we introduce the restore lock stage. For now, when we acquire a xlock, we will remove</span>
<span class="source-line-no">566</span><span id="line-566">    // the queue from runQueue in scheduler, and then when a procedure which has lock access, for</span>
<span class="source-line-no">567</span><span id="line-567">    // example, a sub procedure of the procedure which has the xlock, is pushed into the scheduler,</span>
<span class="source-line-no">568</span><span id="line-568">    // we will add the queue back to let the workers poll from it. The assumption here is that, the</span>
<span class="source-line-no">569</span><span id="line-569">    // procedure which has the xlock should have been polled out already, so when loading we can not</span>
<span class="source-line-no">570</span><span id="line-570">    // add the procedure to scheduler first and then call acquireLock, since the procedure is still</span>
<span class="source-line-no">571</span><span id="line-571">    // in the queue, and since we will remove the queue from runQueue, then no one can poll it out,</span>
<span class="source-line-no">572</span><span id="line-572">    // then there is a dead lock</span>
<span class="source-line-no">573</span><span id="line-573">    List&lt;Procedure&lt;TEnvironment&gt;&gt; runnableList = new ArrayList&lt;&gt;(runnableCount);</span>
<span class="source-line-no">574</span><span id="line-574">    List&lt;Procedure&lt;TEnvironment&gt;&gt; failedList = new ArrayList&lt;&gt;(failedCount);</span>
<span class="source-line-no">575</span><span id="line-575">    List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingList = new ArrayList&lt;&gt;(waitingCount);</span>
<span class="source-line-no">576</span><span id="line-576">    List&lt;Procedure&lt;TEnvironment&gt;&gt; waitingTimeoutList = new ArrayList&lt;&gt;(waitingTimeoutCount);</span>
<span class="source-line-no">577</span><span id="line-577"></span>
<span class="source-line-no">578</span><span id="line-578">    initializeStacks(procIter, runnableList, failedList, waitingList, waitingTimeoutList);</span>
<span class="source-line-no">579</span><span id="line-579"></span>
<span class="source-line-no">580</span><span id="line-580">    // 3. Check the waiting procedures to see if some of them can be added to runnable.</span>
<span class="source-line-no">581</span><span id="line-581">    processWaitingProcedures(waitingList, runnableList);</span>
<span class="source-line-no">582</span><span id="line-582"></span>
<span class="source-line-no">583</span><span id="line-583">    // 4. restore locks</span>
<span class="source-line-no">584</span><span id="line-584">    restoreLocks();</span>
<span class="source-line-no">585</span><span id="line-585"></span>
<span class="source-line-no">586</span><span id="line-586">    // 5. Push the procedures to the timeout executor</span>
<span class="source-line-no">587</span><span id="line-587">    processWaitingTimeoutProcedures(waitingTimeoutList);</span>
<span class="source-line-no">588</span><span id="line-588"></span>
<span class="source-line-no">589</span><span id="line-589">    // 6. Push the procedure to the scheduler</span>
<span class="source-line-no">590</span><span id="line-590">    pushProceduresAfterLoad(runnableList, failedList);</span>
<span class="source-line-no">591</span><span id="line-591">    // After all procedures put into the queue, signal the worker threads.</span>
<span class="source-line-no">592</span><span id="line-592">    // Otherwise, there is a race condition. See HBASE-21364.</span>
<span class="source-line-no">593</span><span id="line-593">    scheduler.signalAll();</span>
<span class="source-line-no">594</span><span id="line-594">  }</span>
<span class="source-line-no">595</span><span id="line-595"></span>
<span class="source-line-no">596</span><span id="line-596">  /**</span>
<span class="source-line-no">597</span><span id="line-597">   * Initialize the procedure executor, but do not start workers. We will start them later.</span>
<span class="source-line-no">598</span><span id="line-598">   * &lt;p/&gt;</span>
<span class="source-line-no">599</span><span id="line-599">   * It calls ProcedureStore.recoverLease() and ProcedureStore.load() to recover the lease, and</span>
<span class="source-line-no">600</span><span id="line-600">   * ensure a single executor, and start the procedure replay to resume and recover the previous</span>
<span class="source-line-no">601</span><span id="line-601">   * pending and in-progress procedures.</span>
<span class="source-line-no">602</span><span id="line-602">   * @param numThreads        number of threads available for procedure execution.</span>
<span class="source-line-no">603</span><span id="line-603">   * @param abortOnCorruption true if you want to abort your service in case a corrupted procedure</span>
<span class="source-line-no">604</span><span id="line-604">   *                          is found on replay. otherwise false.</span>
<span class="source-line-no">605</span><span id="line-605">   */</span>
<span class="source-line-no">606</span><span id="line-606">  public void init(int numThreads, boolean abortOnCorruption) throws IOException {</span>
<span class="source-line-no">607</span><span id="line-607">    // We have numThreads executor + one timer thread used for timing out</span>
<span class="source-line-no">608</span><span id="line-608">    // procedures and triggering periodic procedures.</span>
<span class="source-line-no">609</span><span id="line-609">    this.corePoolSize = numThreads;</span>
<span class="source-line-no">610</span><span id="line-610">    this.maxPoolSize = 10 * numThreads;</span>
<span class="source-line-no">611</span><span id="line-611">    LOG.info("Starting {} core workers (bigger of cpus/4 or 16) with max (burst) worker count={}",</span>
<span class="source-line-no">612</span><span id="line-612">      corePoolSize, maxPoolSize);</span>
<span class="source-line-no">613</span><span id="line-613"></span>
<span class="source-line-no">614</span><span id="line-614">    this.threadGroup = new ThreadGroup("PEWorkerGroup");</span>
<span class="source-line-no">615</span><span id="line-615">    this.timeoutExecutor = new TimeoutExecutorThread&lt;&gt;(this, threadGroup, "ProcExecTimeout");</span>
<span class="source-line-no">616</span><span id="line-616">    this.workerMonitorExecutor = new TimeoutExecutorThread&lt;&gt;(this, threadGroup, "WorkerMonitor");</span>
<span class="source-line-no">617</span><span id="line-617"></span>
<span class="source-line-no">618</span><span id="line-618">    // Create the workers</span>
<span class="source-line-no">619</span><span id="line-619">    workerId.set(0);</span>
<span class="source-line-no">620</span><span id="line-620">    workerThreads = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="source-line-no">621</span><span id="line-621">    for (int i = 0; i &lt; corePoolSize; ++i) {</span>
<span class="source-line-no">622</span><span id="line-622">      workerThreads.add(new WorkerThread(threadGroup));</span>
<span class="source-line-no">623</span><span id="line-623">    }</span>
<span class="source-line-no">624</span><span id="line-624"></span>
<span class="source-line-no">625</span><span id="line-625">    long st, et;</span>
<span class="source-line-no">626</span><span id="line-626"></span>
<span class="source-line-no">627</span><span id="line-627">    // Acquire the store lease.</span>
<span class="source-line-no">628</span><span id="line-628">    st = System.nanoTime();</span>
<span class="source-line-no">629</span><span id="line-629">    store.recoverLease();</span>
<span class="source-line-no">630</span><span id="line-630">    et = System.nanoTime();</span>
<span class="source-line-no">631</span><span id="line-631">    LOG.info("Recovered {} lease in {}", store.getClass().getSimpleName(),</span>
<span class="source-line-no">632</span><span id="line-632">      StringUtils.humanTimeDiff(TimeUnit.NANOSECONDS.toMillis(et - st)));</span>
<span class="source-line-no">633</span><span id="line-633"></span>
<span class="source-line-no">634</span><span id="line-634">    // start the procedure scheduler</span>
<span class="source-line-no">635</span><span id="line-635">    scheduler.start();</span>
<span class="source-line-no">636</span><span id="line-636"></span>
<span class="source-line-no">637</span><span id="line-637">    // TODO: Split in two steps.</span>
<span class="source-line-no">638</span><span id="line-638">    // TODO: Handle corrupted procedures (currently just a warn)</span>
<span class="source-line-no">639</span><span id="line-639">    // The first one will make sure that we have the latest id,</span>
<span class="source-line-no">640</span><span id="line-640">    // so we can start the threads and accept new procedures.</span>
<span class="source-line-no">641</span><span id="line-641">    // The second step will do the actual load of old procedures.</span>
<span class="source-line-no">642</span><span id="line-642">    st = System.nanoTime();</span>
<span class="source-line-no">643</span><span id="line-643">    load(abortOnCorruption);</span>
<span class="source-line-no">644</span><span id="line-644">    et = System.nanoTime();</span>
<span class="source-line-no">645</span><span id="line-645">    LOG.info("Loaded {} in {}", store.getClass().getSimpleName(),</span>
<span class="source-line-no">646</span><span id="line-646">      StringUtils.humanTimeDiff(TimeUnit.NANOSECONDS.toMillis(et - st)));</span>
<span class="source-line-no">647</span><span id="line-647">  }</span>
<span class="source-line-no">648</span><span id="line-648"></span>
<span class="source-line-no">649</span><span id="line-649">  /**</span>
<span class="source-line-no">650</span><span id="line-650">   * Start the workers.</span>
<span class="source-line-no">651</span><span id="line-651">   */</span>
<span class="source-line-no">652</span><span id="line-652">  public void startWorkers() throws IOException {</span>
<span class="source-line-no">653</span><span id="line-653">    if (!running.compareAndSet(false, true)) {</span>
<span class="source-line-no">654</span><span id="line-654">      LOG.warn("Already running");</span>
<span class="source-line-no">655</span><span id="line-655">      return;</span>
<span class="source-line-no">656</span><span id="line-656">    }</span>
<span class="source-line-no">657</span><span id="line-657">    // Start the executors. Here we must have the lastProcId set.</span>
<span class="source-line-no">658</span><span id="line-658">    LOG.trace("Start workers {}", workerThreads.size());</span>
<span class="source-line-no">659</span><span id="line-659">    timeoutExecutor.start();</span>
<span class="source-line-no">660</span><span id="line-660">    workerMonitorExecutor.start();</span>
<span class="source-line-no">661</span><span id="line-661">    for (WorkerThread worker : workerThreads) {</span>
<span class="source-line-no">662</span><span id="line-662">      worker.start();</span>
<span class="source-line-no">663</span><span id="line-663">    }</span>
<span class="source-line-no">664</span><span id="line-664"></span>
<span class="source-line-no">665</span><span id="line-665">    // Internal chores</span>
<span class="source-line-no">666</span><span id="line-666">    workerMonitorExecutor.add(new WorkerMonitor());</span>
<span class="source-line-no">667</span><span id="line-667"></span>
<span class="source-line-no">668</span><span id="line-668">    // Add completed cleaner chore</span>
<span class="source-line-no">669</span><span id="line-669">    addChore(new CompletedProcedureCleaner&lt;&gt;(conf, store, procExecutionLock, completed,</span>
<span class="source-line-no">670</span><span id="line-670">      nonceKeysToProcIdsMap));</span>
<span class="source-line-no">671</span><span id="line-671">  }</span>
<span class="source-line-no">672</span><span id="line-672"></span>
<span class="source-line-no">673</span><span id="line-673">  public void stop() {</span>
<span class="source-line-no">674</span><span id="line-674">    if (!running.getAndSet(false)) {</span>
<span class="source-line-no">675</span><span id="line-675">      return;</span>
<span class="source-line-no">676</span><span id="line-676">    }</span>
<span class="source-line-no">677</span><span id="line-677"></span>
<span class="source-line-no">678</span><span id="line-678">    LOG.info("Stopping");</span>
<span class="source-line-no">679</span><span id="line-679">    scheduler.stop();</span>
<span class="source-line-no">680</span><span id="line-680">    timeoutExecutor.sendStopSignal();</span>
<span class="source-line-no">681</span><span id="line-681">    workerMonitorExecutor.sendStopSignal();</span>
<span class="source-line-no">682</span><span id="line-682">  }</span>
<span class="source-line-no">683</span><span id="line-683"></span>
<span class="source-line-no">684</span><span id="line-684">  public void join() {</span>
<span class="source-line-no">685</span><span id="line-685">    assert !isRunning() : "expected not running";</span>
<span class="source-line-no">686</span><span id="line-686"></span>
<span class="source-line-no">687</span><span id="line-687">    // stop the timeout executor</span>
<span class="source-line-no">688</span><span id="line-688">    timeoutExecutor.awaitTermination();</span>
<span class="source-line-no">689</span><span id="line-689">    // stop the work monitor executor</span>
<span class="source-line-no">690</span><span id="line-690">    workerMonitorExecutor.awaitTermination();</span>
<span class="source-line-no">691</span><span id="line-691"></span>
<span class="source-line-no">692</span><span id="line-692">    // stop the worker threads</span>
<span class="source-line-no">693</span><span id="line-693">    for (WorkerThread worker : workerThreads) {</span>
<span class="source-line-no">694</span><span id="line-694">      worker.awaitTermination();</span>
<span class="source-line-no">695</span><span id="line-695">    }</span>
<span class="source-line-no">696</span><span id="line-696"></span>
<span class="source-line-no">697</span><span id="line-697">    // Destroy the Thread Group for the executors</span>
<span class="source-line-no">698</span><span id="line-698">    // TODO: Fix. #join is not place to destroy resources.</span>
<span class="source-line-no">699</span><span id="line-699">    try {</span>
<span class="source-line-no">700</span><span id="line-700">      threadGroup.destroy();</span>
<span class="source-line-no">701</span><span id="line-701">    } catch (IllegalThreadStateException e) {</span>
<span class="source-line-no">702</span><span id="line-702">      LOG.error("ThreadGroup {} contains running threads; {}: See STDOUT", this.threadGroup,</span>
<span class="source-line-no">703</span><span id="line-703">        e.getMessage());</span>
<span class="source-line-no">704</span><span id="line-704">      // This dumps list of threads on STDOUT.</span>
<span class="source-line-no">705</span><span id="line-705">      this.threadGroup.list();</span>
<span class="source-line-no">706</span><span id="line-706">    }</span>
<span class="source-line-no">707</span><span id="line-707"></span>
<span class="source-line-no">708</span><span id="line-708">    // reset the in-memory state for testing</span>
<span class="source-line-no">709</span><span id="line-709">    completed.clear();</span>
<span class="source-line-no">710</span><span id="line-710">    rollbackStack.clear();</span>
<span class="source-line-no">711</span><span id="line-711">    procedures.clear();</span>
<span class="source-line-no">712</span><span id="line-712">    nonceKeysToProcIdsMap.clear();</span>
<span class="source-line-no">713</span><span id="line-713">    scheduler.clear();</span>
<span class="source-line-no">714</span><span id="line-714">    lastProcId.set(-1);</span>
<span class="source-line-no">715</span><span id="line-715">  }</span>
<span class="source-line-no">716</span><span id="line-716"></span>
<span class="source-line-no">717</span><span id="line-717">  public void refreshConfiguration(final Configuration conf) {</span>
<span class="source-line-no">718</span><span id="line-718">    this.conf = conf;</span>
<span class="source-line-no">719</span><span id="line-719">    setKeepAliveTime(conf.getLong(WORKER_KEEP_ALIVE_TIME_CONF_KEY, DEFAULT_WORKER_KEEP_ALIVE_TIME),</span>
<span class="source-line-no">720</span><span id="line-720">      TimeUnit.MILLISECONDS);</span>
<span class="source-line-no">721</span><span id="line-721">  }</span>
<span class="source-line-no">722</span><span id="line-722"></span>
<span class="source-line-no">723</span><span id="line-723">  // ==========================================================================</span>
<span class="source-line-no">724</span><span id="line-724">  // Accessors</span>
<span class="source-line-no">725</span><span id="line-725">  // ==========================================================================</span>
<span class="source-line-no">726</span><span id="line-726">  public boolean isRunning() {</span>
<span class="source-line-no">727</span><span id="line-727">    return running.get();</span>
<span class="source-line-no">728</span><span id="line-728">  }</span>
<span class="source-line-no">729</span><span id="line-729"></span>
<span class="source-line-no">730</span><span id="line-730">  /** Returns the current number of worker threads. */</span>
<span class="source-line-no">731</span><span id="line-731">  public int getWorkerThreadCount() {</span>
<span class="source-line-no">732</span><span id="line-732">    return workerThreads.size();</span>
<span class="source-line-no">733</span><span id="line-733">  }</span>
<span class="source-line-no">734</span><span id="line-734"></span>
<span class="source-line-no">735</span><span id="line-735">  /** Returns the core pool size settings. */</span>
<span class="source-line-no">736</span><span id="line-736">  public int getCorePoolSize() {</span>
<span class="source-line-no">737</span><span id="line-737">    return corePoolSize;</span>
<span class="source-line-no">738</span><span id="line-738">  }</span>
<span class="source-line-no">739</span><span id="line-739"></span>
<span class="source-line-no">740</span><span id="line-740">  public int getActiveExecutorCount() {</span>
<span class="source-line-no">741</span><span id="line-741">    return activeExecutorCount.get();</span>
<span class="source-line-no">742</span><span id="line-742">  }</span>
<span class="source-line-no">743</span><span id="line-743"></span>
<span class="source-line-no">744</span><span id="line-744">  public TEnvironment getEnvironment() {</span>
<span class="source-line-no">745</span><span id="line-745">    return this.environment;</span>
<span class="source-line-no">746</span><span id="line-746">  }</span>
<span class="source-line-no">747</span><span id="line-747"></span>
<span class="source-line-no">748</span><span id="line-748">  public ProcedureStore getStore() {</span>
<span class="source-line-no">749</span><span id="line-749">    return this.store;</span>
<span class="source-line-no">750</span><span id="line-750">  }</span>
<span class="source-line-no">751</span><span id="line-751"></span>
<span class="source-line-no">752</span><span id="line-752">  ProcedureScheduler getScheduler() {</span>
<span class="source-line-no">753</span><span id="line-753">    return scheduler;</span>
<span class="source-line-no">754</span><span id="line-754">  }</span>
<span class="source-line-no">755</span><span id="line-755"></span>
<span class="source-line-no">756</span><span id="line-756">  public void setKeepAliveTime(final long keepAliveTime, final TimeUnit timeUnit) {</span>
<span class="source-line-no">757</span><span id="line-757">    this.keepAliveTime = timeUnit.toMillis(keepAliveTime);</span>
<span class="source-line-no">758</span><span id="line-758">    this.scheduler.signalAll();</span>
<span class="source-line-no">759</span><span id="line-759">  }</span>
<span class="source-line-no">760</span><span id="line-760"></span>
<span class="source-line-no">761</span><span id="line-761">  public long getKeepAliveTime(final TimeUnit timeUnit) {</span>
<span class="source-line-no">762</span><span id="line-762">    return timeUnit.convert(keepAliveTime, TimeUnit.MILLISECONDS);</span>
<span class="source-line-no">763</span><span id="line-763">  }</span>
<span class="source-line-no">764</span><span id="line-764"></span>
<span class="source-line-no">765</span><span id="line-765">  // ==========================================================================</span>
<span class="source-line-no">766</span><span id="line-766">  // Submit/Remove Chores</span>
<span class="source-line-no">767</span><span id="line-767">  // ==========================================================================</span>
<span class="source-line-no">768</span><span id="line-768"></span>
<span class="source-line-no">769</span><span id="line-769">  /**</span>
<span class="source-line-no">770</span><span id="line-770">   * Add a chore procedure to the executor</span>
<span class="source-line-no">771</span><span id="line-771">   * @param chore the chore to add</span>
<span class="source-line-no">772</span><span id="line-772">   */</span>
<span class="source-line-no">773</span><span id="line-773">  public void addChore(@Nullable ProcedureInMemoryChore&lt;TEnvironment&gt; chore) {</span>
<span class="source-line-no">774</span><span id="line-774">    if (chore == null) {</span>
<span class="source-line-no">775</span><span id="line-775">      return;</span>
<span class="source-line-no">776</span><span id="line-776">    }</span>
<span class="source-line-no">777</span><span id="line-777">    chore.setState(ProcedureState.WAITING_TIMEOUT);</span>
<span class="source-line-no">778</span><span id="line-778">    timeoutExecutor.add(chore);</span>
<span class="source-line-no">779</span><span id="line-779">  }</span>
<span class="source-line-no">780</span><span id="line-780"></span>
<span class="source-line-no">781</span><span id="line-781">  /**</span>
<span class="source-line-no">782</span><span id="line-782">   * Remove a chore procedure from the executor</span>
<span class="source-line-no">783</span><span id="line-783">   * @param chore the chore to remove</span>
<span class="source-line-no">784</span><span id="line-784">   * @return whether the chore is removed, or it will be removed later</span>
<span class="source-line-no">785</span><span id="line-785">   */</span>
<span class="source-line-no">786</span><span id="line-786">  public boolean removeChore(@Nullable ProcedureInMemoryChore&lt;TEnvironment&gt; chore) {</span>
<span class="source-line-no">787</span><span id="line-787">    if (chore == null) {</span>
<span class="source-line-no">788</span><span id="line-788">      return true;</span>
<span class="source-line-no">789</span><span id="line-789">    }</span>
<span class="source-line-no">790</span><span id="line-790">    chore.setState(ProcedureState.SUCCESS);</span>
<span class="source-line-no">791</span><span id="line-791">    return timeoutExecutor.remove(chore);</span>
<span class="source-line-no">792</span><span id="line-792">  }</span>
<span class="source-line-no">793</span><span id="line-793"></span>
<span class="source-line-no">794</span><span id="line-794">  // ==========================================================================</span>
<span class="source-line-no">795</span><span id="line-795">  // Nonce Procedure helpers</span>
<span class="source-line-no">796</span><span id="line-796">  // ==========================================================================</span>
<span class="source-line-no">797</span><span id="line-797">  /**</span>
<span class="source-line-no">798</span><span id="line-798">   * Create a NonceKey from the specified nonceGroup and nonce.</span>
<span class="source-line-no">799</span><span id="line-799">   * @param nonceGroup the group to use for the {@link NonceKey}</span>
<span class="source-line-no">800</span><span id="line-800">   * @param nonce      the nonce to use in the {@link NonceKey}</span>
<span class="source-line-no">801</span><span id="line-801">   * @return the generated NonceKey</span>
<span class="source-line-no">802</span><span id="line-802">   */</span>
<span class="source-line-no">803</span><span id="line-803">  public NonceKey createNonceKey(final long nonceGroup, final long nonce) {</span>
<span class="source-line-no">804</span><span id="line-804">    return (nonce == HConstants.NO_NONCE) ? null : new NonceKey(nonceGroup, nonce);</span>
<span class="source-line-no">805</span><span id="line-805">  }</span>
<span class="source-line-no">806</span><span id="line-806"></span>
<span class="source-line-no">807</span><span id="line-807">  /**</span>
<span class="source-line-no">808</span><span id="line-808">   * Register a nonce for a procedure that is going to be submitted. A procId will be reserved and</span>
<span class="source-line-no">809</span><span id="line-809">   * on submitProcedure(), the procedure with the specified nonce will take the reserved ProcId. If</span>
<span class="source-line-no">810</span><span id="line-810">   * someone already reserved the nonce, this method will return the procId reserved, otherwise an</span>
<span class="source-line-no">811</span><span id="line-811">   * invalid procId will be returned. and the caller should procede and submit the procedure.</span>
<span class="source-line-no">812</span><span id="line-812">   * @param nonceKey A unique identifier for this operation from the client or process.</span>
<span class="source-line-no">813</span><span id="line-813">   * @return the procId associated with the nonce, if any otherwise an invalid procId.</span>
<span class="source-line-no">814</span><span id="line-814">   */</span>
<span class="source-line-no">815</span><span id="line-815">  public long registerNonce(final NonceKey nonceKey) {</span>
<span class="source-line-no">816</span><span id="line-816">    if (nonceKey == null) {</span>
<span class="source-line-no">817</span><span id="line-817">      return -1;</span>
<span class="source-line-no">818</span><span id="line-818">    }</span>
<span class="source-line-no">819</span><span id="line-819"></span>
<span class="source-line-no">820</span><span id="line-820">    // check if we have already a Reserved ID for the nonce</span>
<span class="source-line-no">821</span><span id="line-821">    Long oldProcId = nonceKeysToProcIdsMap.get(nonceKey);</span>
<span class="source-line-no">822</span><span id="line-822">    if (oldProcId == null) {</span>
<span class="source-line-no">823</span><span id="line-823">      // reserve a new Procedure ID, this will be associated with the nonce</span>
<span class="source-line-no">824</span><span id="line-824">      // and the procedure submitted with the specified nonce will use this ID.</span>
<span class="source-line-no">825</span><span id="line-825">      final long newProcId = nextProcId();</span>
<span class="source-line-no">826</span><span id="line-826">      oldProcId = nonceKeysToProcIdsMap.putIfAbsent(nonceKey, newProcId);</span>
<span class="source-line-no">827</span><span id="line-827">      if (oldProcId == null) {</span>
<span class="source-line-no">828</span><span id="line-828">        return -1;</span>
<span class="source-line-no">829</span><span id="line-829">      }</span>
<span class="source-line-no">830</span><span id="line-830">    }</span>
<span class="source-line-no">831</span><span id="line-831"></span>
<span class="source-line-no">832</span><span id="line-832">    // we found a registered nonce, but the procedure may not have been submitted yet.</span>
<span class="source-line-no">833</span><span id="line-833">    // since the client expect the procedure to be submitted, spin here until it is.</span>
<span class="source-line-no">834</span><span id="line-834">    final boolean traceEnabled = LOG.isTraceEnabled();</span>
<span class="source-line-no">835</span><span id="line-835">    while (</span>
<span class="source-line-no">836</span><span id="line-836">      isRunning() &amp;&amp; !(procedures.containsKey(oldProcId) || completed.containsKey(oldProcId))</span>
<span class="source-line-no">837</span><span id="line-837">        &amp;&amp; nonceKeysToProcIdsMap.containsKey(nonceKey)</span>
<span class="source-line-no">838</span><span id="line-838">    ) {</span>
<span class="source-line-no">839</span><span id="line-839">      if (traceEnabled) {</span>
<span class="source-line-no">840</span><span id="line-840">        LOG.trace("Waiting for pid=" + oldProcId.longValue() + " to be submitted");</span>
<span class="source-line-no">841</span><span id="line-841">      }</span>
<span class="source-line-no">842</span><span id="line-842">      Threads.sleep(100);</span>
<span class="source-line-no">843</span><span id="line-843">    }</span>
<span class="source-line-no">844</span><span id="line-844">    return oldProcId.longValue();</span>
<span class="source-line-no">845</span><span id="line-845">  }</span>
<span class="source-line-no">846</span><span id="line-846"></span>
<span class="source-line-no">847</span><span id="line-847">  /**</span>
<span class="source-line-no">848</span><span id="line-848">   * Remove the NonceKey if the procedure was not submitted to the executor.</span>
<span class="source-line-no">849</span><span id="line-849">   * @param nonceKey A unique identifier for this operation from the client or process.</span>
<span class="source-line-no">850</span><span id="line-850">   */</span>
<span class="source-line-no">851</span><span id="line-851">  public void unregisterNonceIfProcedureWasNotSubmitted(final NonceKey nonceKey) {</span>
<span class="source-line-no">852</span><span id="line-852">    if (nonceKey == null) {</span>
<span class="source-line-no">853</span><span id="line-853">      return;</span>
<span class="source-line-no">854</span><span id="line-854">    }</span>
<span class="source-line-no">855</span><span id="line-855"></span>
<span class="source-line-no">856</span><span id="line-856">    final Long procId = nonceKeysToProcIdsMap.get(nonceKey);</span>
<span class="source-line-no">857</span><span id="line-857">    if (procId == null) {</span>
<span class="source-line-no">858</span><span id="line-858">      return;</span>
<span class="source-line-no">859</span><span id="line-859">    }</span>
<span class="source-line-no">860</span><span id="line-860"></span>
<span class="source-line-no">861</span><span id="line-861">    // if the procedure was not submitted, remove the nonce</span>
<span class="source-line-no">862</span><span id="line-862">    if (!(procedures.containsKey(procId) || completed.containsKey(procId))) {</span>
<span class="source-line-no">863</span><span id="line-863">      nonceKeysToProcIdsMap.remove(nonceKey);</span>
<span class="source-line-no">864</span><span id="line-864">    }</span>
<span class="source-line-no">865</span><span id="line-865">  }</span>
<span class="source-line-no">866</span><span id="line-866"></span>
<span class="source-line-no">867</span><span id="line-867">  /**</span>
<span class="source-line-no">868</span><span id="line-868">   * If the failure failed before submitting it, we may want to give back the same error to the</span>
<span class="source-line-no">869</span><span id="line-869">   * requests with the same nonceKey.</span>
<span class="source-line-no">870</span><span id="line-870">   * @param nonceKey  A unique identifier for this operation from the client or process</span>
<span class="source-line-no">871</span><span id="line-871">   * @param procName  name of the procedure, used to inform the user</span>
<span class="source-line-no">872</span><span id="line-872">   * @param procOwner name of the owner of the procedure, used to inform the user</span>
<span class="source-line-no">873</span><span id="line-873">   * @param exception the failure to report to the user</span>
<span class="source-line-no">874</span><span id="line-874">   */</span>
<span class="source-line-no">875</span><span id="line-875">  public void setFailureResultForNonce(NonceKey nonceKey, String procName, User procOwner,</span>
<span class="source-line-no">876</span><span id="line-876">    IOException exception) {</span>
<span class="source-line-no">877</span><span id="line-877">    if (nonceKey == null) {</span>
<span class="source-line-no">878</span><span id="line-878">      return;</span>
<span class="source-line-no">879</span><span id="line-879">    }</span>
<span class="source-line-no">880</span><span id="line-880"></span>
<span class="source-line-no">881</span><span id="line-881">    Long procId = nonceKeysToProcIdsMap.get(nonceKey);</span>
<span class="source-line-no">882</span><span id="line-882">    if (procId == null || completed.containsKey(procId)) {</span>
<span class="source-line-no">883</span><span id="line-883">      return;</span>
<span class="source-line-no">884</span><span id="line-884">    }</span>
<span class="source-line-no">885</span><span id="line-885"></span>
<span class="source-line-no">886</span><span id="line-886">    completed.computeIfAbsent(procId, (key) -&gt; {</span>
<span class="source-line-no">887</span><span id="line-887">      Procedure&lt;TEnvironment&gt; proc =</span>
<span class="source-line-no">888</span><span id="line-888">        new FailedProcedure&lt;&gt;(procId.longValue(), procName, procOwner, nonceKey, exception);</span>
<span class="source-line-no">889</span><span id="line-889"></span>
<span class="source-line-no">890</span><span id="line-890">      return new CompletedProcedureRetainer&lt;&gt;(proc);</span>
<span class="source-line-no">891</span><span id="line-891">    });</span>
<span class="source-line-no">892</span><span id="line-892">  }</span>
<span class="source-line-no">893</span><span id="line-893"></span>
<span class="source-line-no">894</span><span id="line-894">  // ==========================================================================</span>
<span class="source-line-no">895</span><span id="line-895">  // Submit/Abort Procedure</span>
<span class="source-line-no">896</span><span id="line-896">  // ==========================================================================</span>
<span class="source-line-no">897</span><span id="line-897">  /**</span>
<span class="source-line-no">898</span><span id="line-898">   * Add a new root-procedure to the executor.</span>
<span class="source-line-no">899</span><span id="line-899">   * @param proc the new procedure to execute.</span>
<span class="source-line-no">900</span><span id="line-900">   * @return the procedure id, that can be used to monitor the operation</span>
<span class="source-line-no">901</span><span id="line-901">   */</span>
<span class="source-line-no">902</span><span id="line-902">  public long submitProcedure(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">903</span><span id="line-903">    return submitProcedure(proc, null);</span>
<span class="source-line-no">904</span><span id="line-904">  }</span>
<span class="source-line-no">905</span><span id="line-905"></span>
<span class="source-line-no">906</span><span id="line-906">  /**</span>
<span class="source-line-no">907</span><span id="line-907">   * Bypass a procedure. If the procedure is set to bypass, all the logic in execute/rollback will</span>
<span class="source-line-no">908</span><span id="line-908">   * be ignored and it will return success, whatever. It is used to recover buggy stuck procedures,</span>
<span class="source-line-no">909</span><span id="line-909">   * releasing the lock resources and letting other procedures run. Bypassing one procedure (and its</span>
<span class="source-line-no">910</span><span id="line-910">   * ancestors will be bypassed automatically) may leave the cluster in a middle state, e.g. region</span>
<span class="source-line-no">911</span><span id="line-911">   * not assigned, or some hdfs files left behind. After getting rid of those stuck procedures, the</span>
<span class="source-line-no">912</span><span id="line-912">   * operators may have to do some clean up on hdfs or schedule some assign procedures to let region</span>
<span class="source-line-no">913</span><span id="line-913">   * online. DO AT YOUR OWN RISK.</span>
<span class="source-line-no">914</span><span id="line-914">   * &lt;p&gt;</span>
<span class="source-line-no">915</span><span id="line-915">   * A procedure can be bypassed only if 1. The procedure is in state of RUNNABLE, WAITING,</span>
<span class="source-line-no">916</span><span id="line-916">   * WAITING_TIMEOUT or it is a root procedure without any child. 2. No other worker thread is</span>
<span class="source-line-no">917</span><span id="line-917">   * executing it 3. No child procedure has been submitted</span>
<span class="source-line-no">918</span><span id="line-918">   * &lt;p&gt;</span>
<span class="source-line-no">919</span><span id="line-919">   * If all the requirements are meet, the procedure and its ancestors will be bypassed and</span>
<span class="source-line-no">920</span><span id="line-920">   * persisted to WAL.</span>
<span class="source-line-no">921</span><span id="line-921">   * &lt;p&gt;</span>
<span class="source-line-no">922</span><span id="line-922">   * If the procedure is in WAITING state, will set it to RUNNABLE add it to run queue. TODO: What</span>
<span class="source-line-no">923</span><span id="line-923">   * about WAITING_TIMEOUT?</span>
<span class="source-line-no">924</span><span id="line-924">   * @param pids      the procedure id</span>
<span class="source-line-no">925</span><span id="line-925">   * @param lockWait  time to wait lock</span>
<span class="source-line-no">926</span><span id="line-926">   * @param force     if force set to true, we will bypass the procedure even if it is executing.</span>
<span class="source-line-no">927</span><span id="line-927">   *                  This is for procedures which can't break out during executing(due to bug,</span>
<span class="source-line-no">928</span><span id="line-928">   *                  mostly) In this case, bypassing the procedure is not enough, since it is</span>
<span class="source-line-no">929</span><span id="line-929">   *                  already stuck there. We need to restart the master after bypassing, and</span>
<span class="source-line-no">930</span><span id="line-930">   *                  letting the problematic procedure to execute wth bypass=true, so in that</span>
<span class="source-line-no">931</span><span id="line-931">   *                  condition, the procedure can be successfully bypassed.</span>
<span class="source-line-no">932</span><span id="line-932">   * @param recursive We will do an expensive search for children of each pid. EXPENSIVE!</span>
<span class="source-line-no">933</span><span id="line-933">   * @return true if bypass success</span>
<span class="source-line-no">934</span><span id="line-934">   * @throws IOException IOException</span>
<span class="source-line-no">935</span><span id="line-935">   */</span>
<span class="source-line-no">936</span><span id="line-936">  public List&lt;Boolean&gt; bypassProcedure(List&lt;Long&gt; pids, long lockWait, boolean force,</span>
<span class="source-line-no">937</span><span id="line-937">    boolean recursive) throws IOException {</span>
<span class="source-line-no">938</span><span id="line-938">    List&lt;Boolean&gt; result = new ArrayList&lt;Boolean&gt;(pids.size());</span>
<span class="source-line-no">939</span><span id="line-939">    for (long pid : pids) {</span>
<span class="source-line-no">940</span><span id="line-940">      result.add(bypassProcedure(pid, lockWait, force, recursive));</span>
<span class="source-line-no">941</span><span id="line-941">    }</span>
<span class="source-line-no">942</span><span id="line-942">    return result;</span>
<span class="source-line-no">943</span><span id="line-943">  }</span>
<span class="source-line-no">944</span><span id="line-944"></span>
<span class="source-line-no">945</span><span id="line-945">  boolean bypassProcedure(long pid, long lockWait, boolean override, boolean recursive)</span>
<span class="source-line-no">946</span><span id="line-946">    throws IOException {</span>
<span class="source-line-no">947</span><span id="line-947">    Preconditions.checkArgument(lockWait &gt; 0, "lockWait should be positive");</span>
<span class="source-line-no">948</span><span id="line-948">    final Procedure&lt;TEnvironment&gt; procedure = getProcedure(pid);</span>
<span class="source-line-no">949</span><span id="line-949">    if (procedure == null) {</span>
<span class="source-line-no">950</span><span id="line-950">      LOG.debug("Procedure pid={} does not exist, skipping bypass", pid);</span>
<span class="source-line-no">951</span><span id="line-951">      return false;</span>
<span class="source-line-no">952</span><span id="line-952">    }</span>
<span class="source-line-no">953</span><span id="line-953"></span>
<span class="source-line-no">954</span><span id="line-954">    LOG.debug("Begin bypass {} with lockWait={}, override={}, recursive={}", procedure, lockWait,</span>
<span class="source-line-no">955</span><span id="line-955">      override, recursive);</span>
<span class="source-line-no">956</span><span id="line-956">    IdLock.Entry lockEntry = procExecutionLock.tryLockEntry(procedure.getProcId(), lockWait);</span>
<span class="source-line-no">957</span><span id="line-957">    if (lockEntry == null &amp;&amp; !override) {</span>
<span class="source-line-no">958</span><span id="line-958">      LOG.debug("Waited {} ms, but {} is still running, skipping bypass with force={}", lockWait,</span>
<span class="source-line-no">959</span><span id="line-959">        procedure, override);</span>
<span class="source-line-no">960</span><span id="line-960">      return false;</span>
<span class="source-line-no">961</span><span id="line-961">    } else if (lockEntry == null) {</span>
<span class="source-line-no">962</span><span id="line-962">      LOG.debug("Waited {} ms, but {} is still running, begin bypass with force={}", lockWait,</span>
<span class="source-line-no">963</span><span id="line-963">        procedure, override);</span>
<span class="source-line-no">964</span><span id="line-964">    }</span>
<span class="source-line-no">965</span><span id="line-965">    try {</span>
<span class="source-line-no">966</span><span id="line-966">      // check whether the procedure is already finished</span>
<span class="source-line-no">967</span><span id="line-967">      if (procedure.isFinished()) {</span>
<span class="source-line-no">968</span><span id="line-968">        LOG.debug("{} is already finished, skipping bypass", procedure);</span>
<span class="source-line-no">969</span><span id="line-969">        return false;</span>
<span class="source-line-no">970</span><span id="line-970">      }</span>
<span class="source-line-no">971</span><span id="line-971"></span>
<span class="source-line-no">972</span><span id="line-972">      if (procedure.hasChildren()) {</span>
<span class="source-line-no">973</span><span id="line-973">        if (recursive) {</span>
<span class="source-line-no">974</span><span id="line-974">          // EXPENSIVE. Checks each live procedure of which there could be many!!!</span>
<span class="source-line-no">975</span><span id="line-975">          // Is there another way to get children of a procedure?</span>
<span class="source-line-no">976</span><span id="line-976">          LOG.info("Recursive bypass on children of pid={}", procedure.getProcId());</span>
<span class="source-line-no">977</span><span id="line-977">          this.procedures.forEachValue(1 /* Single-threaded */,</span>
<span class="source-line-no">978</span><span id="line-978">            // Transformer</span>
<span class="source-line-no">979</span><span id="line-979">            v -&gt; v.getParentProcId() == procedure.getProcId() ? v : null,</span>
<span class="source-line-no">980</span><span id="line-980">            // Consumer</span>
<span class="source-line-no">981</span><span id="line-981">            v -&gt; {</span>
<span class="source-line-no">982</span><span id="line-982">              try {</span>
<span class="source-line-no">983</span><span id="line-983">                bypassProcedure(v.getProcId(), lockWait, override, recursive);</span>
<span class="source-line-no">984</span><span id="line-984">              } catch (IOException e) {</span>
<span class="source-line-no">985</span><span id="line-985">                LOG.warn("Recursive bypass of pid={}", v.getProcId(), e);</span>
<span class="source-line-no">986</span><span id="line-986">              }</span>
<span class="source-line-no">987</span><span id="line-987">            });</span>
<span class="source-line-no">988</span><span id="line-988">        } else {</span>
<span class="source-line-no">989</span><span id="line-989">          LOG.debug("{} has children, skipping bypass", procedure);</span>
<span class="source-line-no">990</span><span id="line-990">          return false;</span>
<span class="source-line-no">991</span><span id="line-991">        }</span>
<span class="source-line-no">992</span><span id="line-992">      }</span>
<span class="source-line-no">993</span><span id="line-993"></span>
<span class="source-line-no">994</span><span id="line-994">      // If the procedure has no parent or no child, we are safe to bypass it in whatever state</span>
<span class="source-line-no">995</span><span id="line-995">      if (</span>
<span class="source-line-no">996</span><span id="line-996">        procedure.hasParent() &amp;&amp; procedure.getState() != ProcedureState.RUNNABLE</span>
<span class="source-line-no">997</span><span id="line-997">          &amp;&amp; procedure.getState() != ProcedureState.WAITING</span>
<span class="source-line-no">998</span><span id="line-998">          &amp;&amp; procedure.getState() != ProcedureState.WAITING_TIMEOUT</span>
<span class="source-line-no">999</span><span id="line-999">      ) {</span>
<span class="source-line-no">1000</span><span id="line-1000">        LOG.debug("Bypassing procedures in RUNNABLE, WAITING and WAITING_TIMEOUT states "</span>
<span class="source-line-no">1001</span><span id="line-1001">          + "(with no parent), {}", procedure);</span>
<span class="source-line-no">1002</span><span id="line-1002">        // Question: how is the bypass done here?</span>
<span class="source-line-no">1003</span><span id="line-1003">        return false;</span>
<span class="source-line-no">1004</span><span id="line-1004">      }</span>
<span class="source-line-no">1005</span><span id="line-1005"></span>
<span class="source-line-no">1006</span><span id="line-1006">      // Now, the procedure is not finished, and no one can execute it since we take the lock now</span>
<span class="source-line-no">1007</span><span id="line-1007">      // And we can be sure that its ancestor is not running too, since their child has not</span>
<span class="source-line-no">1008</span><span id="line-1008">      // finished yet</span>
<span class="source-line-no">1009</span><span id="line-1009">      Procedure&lt;TEnvironment&gt; current = procedure;</span>
<span class="source-line-no">1010</span><span id="line-1010">      while (current != null) {</span>
<span class="source-line-no">1011</span><span id="line-1011">        LOG.debug("Bypassing {}", current);</span>
<span class="source-line-no">1012</span><span id="line-1012">        current.bypass(getEnvironment());</span>
<span class="source-line-no">1013</span><span id="line-1013">        store.update(current);</span>
<span class="source-line-no">1014</span><span id="line-1014">        long parentID = current.getParentProcId();</span>
<span class="source-line-no">1015</span><span id="line-1015">        current = getProcedure(parentID);</span>
<span class="source-line-no">1016</span><span id="line-1016">      }</span>
<span class="source-line-no">1017</span><span id="line-1017"></span>
<span class="source-line-no">1018</span><span id="line-1018">      // wake up waiting procedure, already checked there is no child</span>
<span class="source-line-no">1019</span><span id="line-1019">      if (procedure.getState() == ProcedureState.WAITING) {</span>
<span class="source-line-no">1020</span><span id="line-1020">        procedure.setState(ProcedureState.RUNNABLE);</span>
<span class="source-line-no">1021</span><span id="line-1021">        store.update(procedure);</span>
<span class="source-line-no">1022</span><span id="line-1022">      }</span>
<span class="source-line-no">1023</span><span id="line-1023"></span>
<span class="source-line-no">1024</span><span id="line-1024">      // If state of procedure is WAITING_TIMEOUT, we can directly submit it to the scheduler.</span>
<span class="source-line-no">1025</span><span id="line-1025">      // Instead we should remove it from timeout Executor queue and tranfer its state to RUNNABLE</span>
<span class="source-line-no">1026</span><span id="line-1026">      if (procedure.getState() == ProcedureState.WAITING_TIMEOUT) {</span>
<span class="source-line-no">1027</span><span id="line-1027">        LOG.debug("transform procedure {} from WAITING_TIMEOUT to RUNNABLE", procedure);</span>
<span class="source-line-no">1028</span><span id="line-1028">        if (timeoutExecutor.remove(procedure)) {</span>
<span class="source-line-no">1029</span><span id="line-1029">          LOG.debug("removed procedure {} from timeoutExecutor", procedure);</span>
<span class="source-line-no">1030</span><span id="line-1030">          timeoutExecutor.executeTimedoutProcedure(procedure);</span>
<span class="source-line-no">1031</span><span id="line-1031">        }</span>
<span class="source-line-no">1032</span><span id="line-1032">      } else if (lockEntry != null) {</span>
<span class="source-line-no">1033</span><span id="line-1033">        scheduler.addFront(procedure);</span>
<span class="source-line-no">1034</span><span id="line-1034">        LOG.debug("Bypassing {} and its ancestors successfully, adding to queue", procedure);</span>
<span class="source-line-no">1035</span><span id="line-1035">      } else {</span>
<span class="source-line-no">1036</span><span id="line-1036">        // If we don't have the lock, we can't re-submit the queue,</span>
<span class="source-line-no">1037</span><span id="line-1037">        // since it is already executing. To get rid of the stuck situation, we</span>
<span class="source-line-no">1038</span><span id="line-1038">        // need to restart the master. With the procedure set to bypass, the procedureExecutor</span>
<span class="source-line-no">1039</span><span id="line-1039">        // will bypass it and won't get stuck again.</span>
<span class="source-line-no">1040</span><span id="line-1040">        LOG.debug("Bypassing {} and its ancestors successfully, but since it is already running, "</span>
<span class="source-line-no">1041</span><span id="line-1041">          + "skipping add to queue", procedure);</span>
<span class="source-line-no">1042</span><span id="line-1042">      }</span>
<span class="source-line-no">1043</span><span id="line-1043">      return true;</span>
<span class="source-line-no">1044</span><span id="line-1044"></span>
<span class="source-line-no">1045</span><span id="line-1045">    } finally {</span>
<span class="source-line-no">1046</span><span id="line-1046">      if (lockEntry != null) {</span>
<span class="source-line-no">1047</span><span id="line-1047">        procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">1048</span><span id="line-1048">      }</span>
<span class="source-line-no">1049</span><span id="line-1049">    }</span>
<span class="source-line-no">1050</span><span id="line-1050">  }</span>
<span class="source-line-no">1051</span><span id="line-1051"></span>
<span class="source-line-no">1052</span><span id="line-1052">  /**</span>
<span class="source-line-no">1053</span><span id="line-1053">   * Add a new root-procedure to the executor.</span>
<span class="source-line-no">1054</span><span id="line-1054">   * @param proc     the new procedure to execute.</span>
<span class="source-line-no">1055</span><span id="line-1055">   * @param nonceKey the registered unique identifier for this operation from the client or process.</span>
<span class="source-line-no">1056</span><span id="line-1056">   * @return the procedure id, that can be used to monitor the operation</span>
<span class="source-line-no">1057</span><span id="line-1057">   */</span>
<span class="source-line-no">1058</span><span id="line-1058">  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "NP_NULL_ON_SOME_PATH",</span>
<span class="source-line-no">1059</span><span id="line-1059">      justification = "FindBugs is blind to the check-for-null")</span>
<span class="source-line-no">1060</span><span id="line-1060">  public long submitProcedure(Procedure&lt;TEnvironment&gt; proc, NonceKey nonceKey) {</span>
<span class="source-line-no">1061</span><span id="line-1061">    Preconditions.checkArgument(lastProcId.get() &gt;= 0);</span>
<span class="source-line-no">1062</span><span id="line-1062"></span>
<span class="source-line-no">1063</span><span id="line-1063">    prepareProcedure(proc);</span>
<span class="source-line-no">1064</span><span id="line-1064"></span>
<span class="source-line-no">1065</span><span id="line-1065">    final Long currentProcId;</span>
<span class="source-line-no">1066</span><span id="line-1066">    if (nonceKey != null) {</span>
<span class="source-line-no">1067</span><span id="line-1067">      currentProcId = nonceKeysToProcIdsMap.get(nonceKey);</span>
<span class="source-line-no">1068</span><span id="line-1068">      Preconditions.checkArgument(currentProcId != null,</span>
<span class="source-line-no">1069</span><span id="line-1069">        "Expected nonceKey=" + nonceKey + " to be reserved, use registerNonce(); proc=" + proc);</span>
<span class="source-line-no">1070</span><span id="line-1070">    } else {</span>
<span class="source-line-no">1071</span><span id="line-1071">      currentProcId = nextProcId();</span>
<span class="source-line-no">1072</span><span id="line-1072">    }</span>
<span class="source-line-no">1073</span><span id="line-1073"></span>
<span class="source-line-no">1074</span><span id="line-1074">    // Initialize the procedure</span>
<span class="source-line-no">1075</span><span id="line-1075">    proc.setNonceKey(nonceKey);</span>
<span class="source-line-no">1076</span><span id="line-1076">    proc.setProcId(currentProcId.longValue());</span>
<span class="source-line-no">1077</span><span id="line-1077"></span>
<span class="source-line-no">1078</span><span id="line-1078">    // Commit the transaction</span>
<span class="source-line-no">1079</span><span id="line-1079">    store.insert(proc, null);</span>
<span class="source-line-no">1080</span><span id="line-1080">    LOG.debug("Stored {}", proc);</span>
<span class="source-line-no">1081</span><span id="line-1081"></span>
<span class="source-line-no">1082</span><span id="line-1082">    // Add the procedure to the executor</span>
<span class="source-line-no">1083</span><span id="line-1083">    return pushProcedure(proc);</span>
<span class="source-line-no">1084</span><span id="line-1084">  }</span>
<span class="source-line-no">1085</span><span id="line-1085"></span>
<span class="source-line-no">1086</span><span id="line-1086">  /**</span>
<span class="source-line-no">1087</span><span id="line-1087">   * Add a set of new root-procedure to the executor.</span>
<span class="source-line-no">1088</span><span id="line-1088">   * @param procs the new procedures to execute.</span>
<span class="source-line-no">1089</span><span id="line-1089">   */</span>
<span class="source-line-no">1090</span><span id="line-1090">  // TODO: Do we need to take nonces here?</span>
<span class="source-line-no">1091</span><span id="line-1091">  public void submitProcedures(Procedure&lt;TEnvironment&gt;[] procs) {</span>
<span class="source-line-no">1092</span><span id="line-1092">    Preconditions.checkArgument(lastProcId.get() &gt;= 0);</span>
<span class="source-line-no">1093</span><span id="line-1093">    if (procs == null || procs.length &lt;= 0) {</span>
<span class="source-line-no">1094</span><span id="line-1094">      return;</span>
<span class="source-line-no">1095</span><span id="line-1095">    }</span>
<span class="source-line-no">1096</span><span id="line-1096"></span>
<span class="source-line-no">1097</span><span id="line-1097">    // Prepare procedure</span>
<span class="source-line-no">1098</span><span id="line-1098">    for (int i = 0; i &lt; procs.length; ++i) {</span>
<span class="source-line-no">1099</span><span id="line-1099">      prepareProcedure(procs[i]).setProcId(nextProcId());</span>
<span class="source-line-no">1100</span><span id="line-1100">    }</span>
<span class="source-line-no">1101</span><span id="line-1101"></span>
<span class="source-line-no">1102</span><span id="line-1102">    // Commit the transaction</span>
<span class="source-line-no">1103</span><span id="line-1103">    store.insert(procs);</span>
<span class="source-line-no">1104</span><span id="line-1104">    if (LOG.isDebugEnabled()) {</span>
<span class="source-line-no">1105</span><span id="line-1105">      LOG.debug("Stored " + Arrays.toString(procs));</span>
<span class="source-line-no">1106</span><span id="line-1106">    }</span>
<span class="source-line-no">1107</span><span id="line-1107"></span>
<span class="source-line-no">1108</span><span id="line-1108">    // Add the procedure to the executor</span>
<span class="source-line-no">1109</span><span id="line-1109">    for (int i = 0; i &lt; procs.length; ++i) {</span>
<span class="source-line-no">1110</span><span id="line-1110">      pushProcedure(procs[i]);</span>
<span class="source-line-no">1111</span><span id="line-1111">    }</span>
<span class="source-line-no">1112</span><span id="line-1112">  }</span>
<span class="source-line-no">1113</span><span id="line-1113"></span>
<span class="source-line-no">1114</span><span id="line-1114">  private Procedure&lt;TEnvironment&gt; prepareProcedure(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1115</span><span id="line-1115">    Preconditions.checkArgument(proc.getState() == ProcedureState.INITIALIZING);</span>
<span class="source-line-no">1116</span><span id="line-1116">    Preconditions.checkArgument(!proc.hasParent(), "unexpected parent", proc);</span>
<span class="source-line-no">1117</span><span id="line-1117">    if (this.checkOwnerSet) {</span>
<span class="source-line-no">1118</span><span id="line-1118">      Preconditions.checkArgument(proc.hasOwner(), "missing owner");</span>
<span class="source-line-no">1119</span><span id="line-1119">    }</span>
<span class="source-line-no">1120</span><span id="line-1120">    return proc;</span>
<span class="source-line-no">1121</span><span id="line-1121">  }</span>
<span class="source-line-no">1122</span><span id="line-1122"></span>
<span class="source-line-no">1123</span><span id="line-1123">  private long pushProcedure(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1124</span><span id="line-1124">    final long currentProcId = proc.getProcId();</span>
<span class="source-line-no">1125</span><span id="line-1125"></span>
<span class="source-line-no">1126</span><span id="line-1126">    // Update metrics on start of a procedure</span>
<span class="source-line-no">1127</span><span id="line-1127">    proc.updateMetricsOnSubmit(getEnvironment());</span>
<span class="source-line-no">1128</span><span id="line-1128"></span>
<span class="source-line-no">1129</span><span id="line-1129">    // Create the rollback stack for the procedure</span>
<span class="source-line-no">1130</span><span id="line-1130">    RootProcedureState&lt;TEnvironment&gt; stack = new RootProcedureState&lt;&gt;();</span>
<span class="source-line-no">1131</span><span id="line-1131">    stack.setRollbackSupported(proc.isRollbackSupported());</span>
<span class="source-line-no">1132</span><span id="line-1132">    rollbackStack.put(currentProcId, stack);</span>
<span class="source-line-no">1133</span><span id="line-1133"></span>
<span class="source-line-no">1134</span><span id="line-1134">    // Submit the new subprocedures</span>
<span class="source-line-no">1135</span><span id="line-1135">    assert !procedures.containsKey(currentProcId);</span>
<span class="source-line-no">1136</span><span id="line-1136">    procedures.put(currentProcId, proc);</span>
<span class="source-line-no">1137</span><span id="line-1137">    sendProcedureAddedNotification(currentProcId);</span>
<span class="source-line-no">1138</span><span id="line-1138">    scheduler.addBack(proc);</span>
<span class="source-line-no">1139</span><span id="line-1139">    return proc.getProcId();</span>
<span class="source-line-no">1140</span><span id="line-1140">  }</span>
<span class="source-line-no">1141</span><span id="line-1141"></span>
<span class="source-line-no">1142</span><span id="line-1142">  /**</span>
<span class="source-line-no">1143</span><span id="line-1143">   * Send an abort notification the specified procedure. Depending on the procedure implementation</span>
<span class="source-line-no">1144</span><span id="line-1144">   * the abort can be considered or ignored.</span>
<span class="source-line-no">1145</span><span id="line-1145">   * @param procId the procedure to abort</span>
<span class="source-line-no">1146</span><span id="line-1146">   * @return true if the procedure exists and has received the abort, otherwise false.</span>
<span class="source-line-no">1147</span><span id="line-1147">   */</span>
<span class="source-line-no">1148</span><span id="line-1148">  public boolean abort(long procId) {</span>
<span class="source-line-no">1149</span><span id="line-1149">    return abort(procId, true);</span>
<span class="source-line-no">1150</span><span id="line-1150">  }</span>
<span class="source-line-no">1151</span><span id="line-1151"></span>
<span class="source-line-no">1152</span><span id="line-1152">  /**</span>
<span class="source-line-no">1153</span><span id="line-1153">   * Send an abort notification to the specified procedure. Depending on the procedure</span>
<span class="source-line-no">1154</span><span id="line-1154">   * implementation, the abort can be considered or ignored.</span>
<span class="source-line-no">1155</span><span id="line-1155">   * @param procId                the procedure to abort</span>
<span class="source-line-no">1156</span><span id="line-1156">   * @param mayInterruptIfRunning if the proc completed at least one step, should it be aborted?</span>
<span class="source-line-no">1157</span><span id="line-1157">   * @return true if the procedure exists and has received the abort, otherwise false.</span>
<span class="source-line-no">1158</span><span id="line-1158">   */</span>
<span class="source-line-no">1159</span><span id="line-1159">  public boolean abort(long procId, boolean mayInterruptIfRunning) {</span>
<span class="source-line-no">1160</span><span id="line-1160">    Procedure&lt;TEnvironment&gt; proc = procedures.get(procId);</span>
<span class="source-line-no">1161</span><span id="line-1161">    if (proc != null) {</span>
<span class="source-line-no">1162</span><span id="line-1162">      if (!mayInterruptIfRunning &amp;&amp; proc.wasExecuted()) {</span>
<span class="source-line-no">1163</span><span id="line-1163">        return false;</span>
<span class="source-line-no">1164</span><span id="line-1164">      }</span>
<span class="source-line-no">1165</span><span id="line-1165">      return proc.abort(getEnvironment());</span>
<span class="source-line-no">1166</span><span id="line-1166">    }</span>
<span class="source-line-no">1167</span><span id="line-1167">    return false;</span>
<span class="source-line-no">1168</span><span id="line-1168">  }</span>
<span class="source-line-no">1169</span><span id="line-1169"></span>
<span class="source-line-no">1170</span><span id="line-1170">  // ==========================================================================</span>
<span class="source-line-no">1171</span><span id="line-1171">  // Executor query helpers</span>
<span class="source-line-no">1172</span><span id="line-1172">  // ==========================================================================</span>
<span class="source-line-no">1173</span><span id="line-1173">  public Procedure&lt;TEnvironment&gt; getProcedure(final long procId) {</span>
<span class="source-line-no">1174</span><span id="line-1174">    return procedures.get(procId);</span>
<span class="source-line-no">1175</span><span id="line-1175">  }</span>
<span class="source-line-no">1176</span><span id="line-1176"></span>
<span class="source-line-no">1177</span><span id="line-1177">  public &lt;T extends Procedure&lt;TEnvironment&gt;&gt; T getProcedure(Class&lt;T&gt; clazz, long procId) {</span>
<span class="source-line-no">1178</span><span id="line-1178">    Procedure&lt;TEnvironment&gt; proc = getProcedure(procId);</span>
<span class="source-line-no">1179</span><span id="line-1179">    if (clazz.isInstance(proc)) {</span>
<span class="source-line-no">1180</span><span id="line-1180">      return clazz.cast(proc);</span>
<span class="source-line-no">1181</span><span id="line-1181">    }</span>
<span class="source-line-no">1182</span><span id="line-1182">    return null;</span>
<span class="source-line-no">1183</span><span id="line-1183">  }</span>
<span class="source-line-no">1184</span><span id="line-1184"></span>
<span class="source-line-no">1185</span><span id="line-1185">  public Procedure&lt;TEnvironment&gt; getResult(long procId) {</span>
<span class="source-line-no">1186</span><span id="line-1186">    CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = completed.get(procId);</span>
<span class="source-line-no">1187</span><span id="line-1187">    if (retainer == null) {</span>
<span class="source-line-no">1188</span><span id="line-1188">      return null;</span>
<span class="source-line-no">1189</span><span id="line-1189">    } else {</span>
<span class="source-line-no">1190</span><span id="line-1190">      return retainer.getProcedure();</span>
<span class="source-line-no">1191</span><span id="line-1191">    }</span>
<span class="source-line-no">1192</span><span id="line-1192">  }</span>
<span class="source-line-no">1193</span><span id="line-1193"></span>
<span class="source-line-no">1194</span><span id="line-1194">  /**</span>
<span class="source-line-no">1195</span><span id="line-1195">   * Return true if the procedure is finished. The state may be "completed successfully" or "failed</span>
<span class="source-line-no">1196</span><span id="line-1196">   * and rolledback". Use getResult() to check the state or get the result data.</span>
<span class="source-line-no">1197</span><span id="line-1197">   * @param procId the ID of the procedure to check</span>
<span class="source-line-no">1198</span><span id="line-1198">   * @return true if the procedure execution is finished, otherwise false.</span>
<span class="source-line-no">1199</span><span id="line-1199">   */</span>
<span class="source-line-no">1200</span><span id="line-1200">  public boolean isFinished(final long procId) {</span>
<span class="source-line-no">1201</span><span id="line-1201">    return !procedures.containsKey(procId);</span>
<span class="source-line-no">1202</span><span id="line-1202">  }</span>
<span class="source-line-no">1203</span><span id="line-1203"></span>
<span class="source-line-no">1204</span><span id="line-1204">  /**</span>
<span class="source-line-no">1205</span><span id="line-1205">   * Return true if the procedure is started.</span>
<span class="source-line-no">1206</span><span id="line-1206">   * @param procId the ID of the procedure to check</span>
<span class="source-line-no">1207</span><span id="line-1207">   * @return true if the procedure execution is started, otherwise false.</span>
<span class="source-line-no">1208</span><span id="line-1208">   */</span>
<span class="source-line-no">1209</span><span id="line-1209">  public boolean isStarted(long procId) {</span>
<span class="source-line-no">1210</span><span id="line-1210">    Procedure&lt;?&gt; proc = procedures.get(procId);</span>
<span class="source-line-no">1211</span><span id="line-1211">    if (proc == null) {</span>
<span class="source-line-no">1212</span><span id="line-1212">      return completed.get(procId) != null;</span>
<span class="source-line-no">1213</span><span id="line-1213">    }</span>
<span class="source-line-no">1214</span><span id="line-1214">    return proc.wasExecuted();</span>
<span class="source-line-no">1215</span><span id="line-1215">  }</span>
<span class="source-line-no">1216</span><span id="line-1216"></span>
<span class="source-line-no">1217</span><span id="line-1217">  /**</span>
<span class="source-line-no">1218</span><span id="line-1218">   * Mark the specified completed procedure, as ready to remove.</span>
<span class="source-line-no">1219</span><span id="line-1219">   * @param procId the ID of the procedure to remove</span>
<span class="source-line-no">1220</span><span id="line-1220">   */</span>
<span class="source-line-no">1221</span><span id="line-1221">  public void removeResult(long procId) {</span>
<span class="source-line-no">1222</span><span id="line-1222">    CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = completed.get(procId);</span>
<span class="source-line-no">1223</span><span id="line-1223">    if (retainer == null) {</span>
<span class="source-line-no">1224</span><span id="line-1224">      assert !procedures.containsKey(procId) : "pid=" + procId + " is still running";</span>
<span class="source-line-no">1225</span><span id="line-1225">      LOG.debug("pid={} already removed by the cleaner.", procId);</span>
<span class="source-line-no">1226</span><span id="line-1226">      return;</span>
<span class="source-line-no">1227</span><span id="line-1227">    }</span>
<span class="source-line-no">1228</span><span id="line-1228"></span>
<span class="source-line-no">1229</span><span id="line-1229">    // The CompletedProcedureCleaner will take care of deletion, once the TTL is expired.</span>
<span class="source-line-no">1230</span><span id="line-1230">    retainer.setClientAckTime(EnvironmentEdgeManager.currentTime());</span>
<span class="source-line-no">1231</span><span id="line-1231">  }</span>
<span class="source-line-no">1232</span><span id="line-1232"></span>
<span class="source-line-no">1233</span><span id="line-1233">  public Procedure&lt;TEnvironment&gt; getResultOrProcedure(long procId) {</span>
<span class="source-line-no">1234</span><span id="line-1234">    CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = completed.get(procId);</span>
<span class="source-line-no">1235</span><span id="line-1235">    if (retainer == null) {</span>
<span class="source-line-no">1236</span><span id="line-1236">      return procedures.get(procId);</span>
<span class="source-line-no">1237</span><span id="line-1237">    } else {</span>
<span class="source-line-no">1238</span><span id="line-1238">      return retainer.getProcedure();</span>
<span class="source-line-no">1239</span><span id="line-1239">    }</span>
<span class="source-line-no">1240</span><span id="line-1240">  }</span>
<span class="source-line-no">1241</span><span id="line-1241"></span>
<span class="source-line-no">1242</span><span id="line-1242">  /**</span>
<span class="source-line-no">1243</span><span id="line-1243">   * Check if the user is this procedure's owner</span>
<span class="source-line-no">1244</span><span id="line-1244">   * @param procId the target procedure</span>
<span class="source-line-no">1245</span><span id="line-1245">   * @param user   the user</span>
<span class="source-line-no">1246</span><span id="line-1246">   * @return true if the user is the owner of the procedure, false otherwise or the owner is</span>
<span class="source-line-no">1247</span><span id="line-1247">   *         unknown.</span>
<span class="source-line-no">1248</span><span id="line-1248">   */</span>
<span class="source-line-no">1249</span><span id="line-1249">  public boolean isProcedureOwner(long procId, User user) {</span>
<span class="source-line-no">1250</span><span id="line-1250">    if (user == null) {</span>
<span class="source-line-no">1251</span><span id="line-1251">      return false;</span>
<span class="source-line-no">1252</span><span id="line-1252">    }</span>
<span class="source-line-no">1253</span><span id="line-1253">    final Procedure&lt;TEnvironment&gt; runningProc = procedures.get(procId);</span>
<span class="source-line-no">1254</span><span id="line-1254">    if (runningProc != null) {</span>
<span class="source-line-no">1255</span><span id="line-1255">      return runningProc.getOwner().equals(user.getShortName());</span>
<span class="source-line-no">1256</span><span id="line-1256">    }</span>
<span class="source-line-no">1257</span><span id="line-1257"></span>
<span class="source-line-no">1258</span><span id="line-1258">    final CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = completed.get(procId);</span>
<span class="source-line-no">1259</span><span id="line-1259">    if (retainer != null) {</span>
<span class="source-line-no">1260</span><span id="line-1260">      return retainer.getProcedure().getOwner().equals(user.getShortName());</span>
<span class="source-line-no">1261</span><span id="line-1261">    }</span>
<span class="source-line-no">1262</span><span id="line-1262"></span>
<span class="source-line-no">1263</span><span id="line-1263">    // Procedure either does not exist or has already completed and got cleaned up.</span>
<span class="source-line-no">1264</span><span id="line-1264">    // At this time, we cannot check the owner of the procedure</span>
<span class="source-line-no">1265</span><span id="line-1265">    return false;</span>
<span class="source-line-no">1266</span><span id="line-1266">  }</span>
<span class="source-line-no">1267</span><span id="line-1267"></span>
<span class="source-line-no">1268</span><span id="line-1268">  /**</span>
<span class="source-line-no">1269</span><span id="line-1269">   * Should only be used when starting up, where the procedure workers have not been started.</span>
<span class="source-line-no">1270</span><span id="line-1270">   * &lt;p/&gt;</span>
<span class="source-line-no">1271</span><span id="line-1271">   * If the procedure works has been started, the return values maybe changed when you are</span>
<span class="source-line-no">1272</span><span id="line-1272">   * processing it so usually this is not safe. Use {@link #getProcedures()} below for most cases as</span>
<span class="source-line-no">1273</span><span id="line-1273">   * it will do a copy, and also include the finished procedures.</span>
<span class="source-line-no">1274</span><span id="line-1274">   */</span>
<span class="source-line-no">1275</span><span id="line-1275">  public Collection&lt;Procedure&lt;TEnvironment&gt;&gt; getActiveProceduresNoCopy() {</span>
<span class="source-line-no">1276</span><span id="line-1276">    return procedures.values();</span>
<span class="source-line-no">1277</span><span id="line-1277">  }</span>
<span class="source-line-no">1278</span><span id="line-1278"></span>
<span class="source-line-no">1279</span><span id="line-1279">  /**</span>
<span class="source-line-no">1280</span><span id="line-1280">   * Get procedures.</span>
<span class="source-line-no">1281</span><span id="line-1281">   * @return the procedures in a list</span>
<span class="source-line-no">1282</span><span id="line-1282">   */</span>
<span class="source-line-no">1283</span><span id="line-1283">  public List&lt;Procedure&lt;TEnvironment&gt;&gt; getProcedures() {</span>
<span class="source-line-no">1284</span><span id="line-1284">    List&lt;Procedure&lt;TEnvironment&gt;&gt; procedureList =</span>
<span class="source-line-no">1285</span><span id="line-1285">      new ArrayList&lt;&gt;(procedures.size() + completed.size());</span>
<span class="source-line-no">1286</span><span id="line-1286">    procedureList.addAll(procedures.values());</span>
<span class="source-line-no">1287</span><span id="line-1287">    // Note: The procedure could show up twice in the list with different state, as</span>
<span class="source-line-no">1288</span><span id="line-1288">    // it could complete after we walk through procedures list and insert into</span>
<span class="source-line-no">1289</span><span id="line-1289">    // procedureList - it is ok, as we will use the information in the Procedure</span>
<span class="source-line-no">1290</span><span id="line-1290">    // to figure it out; to prevent this would increase the complexity of the logic.</span>
<span class="source-line-no">1291</span><span id="line-1291">    completed.values().stream().map(CompletedProcedureRetainer::getProcedure)</span>
<span class="source-line-no">1292</span><span id="line-1292">      .forEach(procedureList::add);</span>
<span class="source-line-no">1293</span><span id="line-1293">    return procedureList;</span>
<span class="source-line-no">1294</span><span id="line-1294">  }</span>
<span class="source-line-no">1295</span><span id="line-1295"></span>
<span class="source-line-no">1296</span><span id="line-1296">  // ==========================================================================</span>
<span class="source-line-no">1297</span><span id="line-1297">  // Listeners helpers</span>
<span class="source-line-no">1298</span><span id="line-1298">  // ==========================================================================</span>
<span class="source-line-no">1299</span><span id="line-1299">  public void registerListener(ProcedureExecutorListener listener) {</span>
<span class="source-line-no">1300</span><span id="line-1300">    this.listeners.add(listener);</span>
<span class="source-line-no">1301</span><span id="line-1301">  }</span>
<span class="source-line-no">1302</span><span id="line-1302"></span>
<span class="source-line-no">1303</span><span id="line-1303">  public boolean unregisterListener(ProcedureExecutorListener listener) {</span>
<span class="source-line-no">1304</span><span id="line-1304">    return this.listeners.remove(listener);</span>
<span class="source-line-no">1305</span><span id="line-1305">  }</span>
<span class="source-line-no">1306</span><span id="line-1306"></span>
<span class="source-line-no">1307</span><span id="line-1307">  private void sendProcedureLoadedNotification(final long procId) {</span>
<span class="source-line-no">1308</span><span id="line-1308">    if (!this.listeners.isEmpty()) {</span>
<span class="source-line-no">1309</span><span id="line-1309">      for (ProcedureExecutorListener listener : this.listeners) {</span>
<span class="source-line-no">1310</span><span id="line-1310">        try {</span>
<span class="source-line-no">1311</span><span id="line-1311">          listener.procedureLoaded(procId);</span>
<span class="source-line-no">1312</span><span id="line-1312">        } catch (Throwable e) {</span>
<span class="source-line-no">1313</span><span id="line-1313">          LOG.error("Listener " + listener + " had an error: " + e.getMessage(), e);</span>
<span class="source-line-no">1314</span><span id="line-1314">        }</span>
<span class="source-line-no">1315</span><span id="line-1315">      }</span>
<span class="source-line-no">1316</span><span id="line-1316">    }</span>
<span class="source-line-no">1317</span><span id="line-1317">  }</span>
<span class="source-line-no">1318</span><span id="line-1318"></span>
<span class="source-line-no">1319</span><span id="line-1319">  private void sendProcedureAddedNotification(final long procId) {</span>
<span class="source-line-no">1320</span><span id="line-1320">    if (!this.listeners.isEmpty()) {</span>
<span class="source-line-no">1321</span><span id="line-1321">      for (ProcedureExecutorListener listener : this.listeners) {</span>
<span class="source-line-no">1322</span><span id="line-1322">        try {</span>
<span class="source-line-no">1323</span><span id="line-1323">          listener.procedureAdded(procId);</span>
<span class="source-line-no">1324</span><span id="line-1324">        } catch (Throwable e) {</span>
<span class="source-line-no">1325</span><span id="line-1325">          LOG.error("Listener " + listener + " had an error: " + e.getMessage(), e);</span>
<span class="source-line-no">1326</span><span id="line-1326">        }</span>
<span class="source-line-no">1327</span><span id="line-1327">      }</span>
<span class="source-line-no">1328</span><span id="line-1328">    }</span>
<span class="source-line-no">1329</span><span id="line-1329">  }</span>
<span class="source-line-no">1330</span><span id="line-1330"></span>
<span class="source-line-no">1331</span><span id="line-1331">  private void sendProcedureFinishedNotification(final long procId) {</span>
<span class="source-line-no">1332</span><span id="line-1332">    if (!this.listeners.isEmpty()) {</span>
<span class="source-line-no">1333</span><span id="line-1333">      for (ProcedureExecutorListener listener : this.listeners) {</span>
<span class="source-line-no">1334</span><span id="line-1334">        try {</span>
<span class="source-line-no">1335</span><span id="line-1335">          listener.procedureFinished(procId);</span>
<span class="source-line-no">1336</span><span id="line-1336">        } catch (Throwable e) {</span>
<span class="source-line-no">1337</span><span id="line-1337">          LOG.error("Listener " + listener + " had an error: " + e.getMessage(), e);</span>
<span class="source-line-no">1338</span><span id="line-1338">        }</span>
<span class="source-line-no">1339</span><span id="line-1339">      }</span>
<span class="source-line-no">1340</span><span id="line-1340">    }</span>
<span class="source-line-no">1341</span><span id="line-1341">  }</span>
<span class="source-line-no">1342</span><span id="line-1342"></span>
<span class="source-line-no">1343</span><span id="line-1343">  // ==========================================================================</span>
<span class="source-line-no">1344</span><span id="line-1344">  // Procedure IDs helpers</span>
<span class="source-line-no">1345</span><span id="line-1345">  // ==========================================================================</span>
<span class="source-line-no">1346</span><span id="line-1346">  private long nextProcId() {</span>
<span class="source-line-no">1347</span><span id="line-1347">    long procId = lastProcId.incrementAndGet();</span>
<span class="source-line-no">1348</span><span id="line-1348">    if (procId &lt; 0) {</span>
<span class="source-line-no">1349</span><span id="line-1349">      while (!lastProcId.compareAndSet(procId, 0)) {</span>
<span class="source-line-no">1350</span><span id="line-1350">        procId = lastProcId.get();</span>
<span class="source-line-no">1351</span><span id="line-1351">        if (procId &gt;= 0) {</span>
<span class="source-line-no">1352</span><span id="line-1352">          break;</span>
<span class="source-line-no">1353</span><span id="line-1353">        }</span>
<span class="source-line-no">1354</span><span id="line-1354">      }</span>
<span class="source-line-no">1355</span><span id="line-1355">      while (procedures.containsKey(procId)) {</span>
<span class="source-line-no">1356</span><span id="line-1356">        procId = lastProcId.incrementAndGet();</span>
<span class="source-line-no">1357</span><span id="line-1357">      }</span>
<span class="source-line-no">1358</span><span id="line-1358">    }</span>
<span class="source-line-no">1359</span><span id="line-1359">    assert procId &gt;= 0 : "Invalid procId " + procId;</span>
<span class="source-line-no">1360</span><span id="line-1360">    return procId;</span>
<span class="source-line-no">1361</span><span id="line-1361">  }</span>
<span class="source-line-no">1362</span><span id="line-1362"></span>
<span class="source-line-no">1363</span><span id="line-1363">  protected long getLastProcId() {</span>
<span class="source-line-no">1364</span><span id="line-1364">    return lastProcId.get();</span>
<span class="source-line-no">1365</span><span id="line-1365">  }</span>
<span class="source-line-no">1366</span><span id="line-1366"></span>
<span class="source-line-no">1367</span><span id="line-1367">  public Set&lt;Long&gt; getActiveProcIds() {</span>
<span class="source-line-no">1368</span><span id="line-1368">    return procedures.keySet();</span>
<span class="source-line-no">1369</span><span id="line-1369">  }</span>
<span class="source-line-no">1370</span><span id="line-1370"></span>
<span class="source-line-no">1371</span><span id="line-1371">  Long getRootProcedureId(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1372</span><span id="line-1372">    return Procedure.getRootProcedureId(procedures, proc);</span>
<span class="source-line-no">1373</span><span id="line-1373">  }</span>
<span class="source-line-no">1374</span><span id="line-1374"></span>
<span class="source-line-no">1375</span><span id="line-1375">  // ==========================================================================</span>
<span class="source-line-no">1376</span><span id="line-1376">  // Executions</span>
<span class="source-line-no">1377</span><span id="line-1377">  // ==========================================================================</span>
<span class="source-line-no">1378</span><span id="line-1378">  private void executeProcedure(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1379</span><span id="line-1379">    if (proc.isFinished()) {</span>
<span class="source-line-no">1380</span><span id="line-1380">      LOG.debug("{} is already finished, skipping execution", proc);</span>
<span class="source-line-no">1381</span><span id="line-1381">      return;</span>
<span class="source-line-no">1382</span><span id="line-1382">    }</span>
<span class="source-line-no">1383</span><span id="line-1383">    final Long rootProcId = getRootProcedureId(proc);</span>
<span class="source-line-no">1384</span><span id="line-1384">    if (rootProcId == null) {</span>
<span class="source-line-no">1385</span><span id="line-1385">      // The 'proc' was ready to run but the root procedure was rolledback</span>
<span class="source-line-no">1386</span><span id="line-1386">      LOG.warn("Rollback because parent is done/rolledback proc=" + proc);</span>
<span class="source-line-no">1387</span><span id="line-1387">      executeRollback(proc);</span>
<span class="source-line-no">1388</span><span id="line-1388">      return;</span>
<span class="source-line-no">1389</span><span id="line-1389">    }</span>
<span class="source-line-no">1390</span><span id="line-1390"></span>
<span class="source-line-no">1391</span><span id="line-1391">    RootProcedureState&lt;TEnvironment&gt; procStack = rollbackStack.get(rootProcId);</span>
<span class="source-line-no">1392</span><span id="line-1392">    if (procStack == null) {</span>
<span class="source-line-no">1393</span><span id="line-1393">      LOG.warn("RootProcedureState is null for " + proc.getProcId());</span>
<span class="source-line-no">1394</span><span id="line-1394">      return;</span>
<span class="source-line-no">1395</span><span id="line-1395">    }</span>
<span class="source-line-no">1396</span><span id="line-1396">    do {</span>
<span class="source-line-no">1397</span><span id="line-1397">      // Try to acquire the execution</span>
<span class="source-line-no">1398</span><span id="line-1398">      if (!procStack.acquire(proc)) {</span>
<span class="source-line-no">1399</span><span id="line-1399">        if (procStack.setRollback()) {</span>
<span class="source-line-no">1400</span><span id="line-1400">          // we have the 'rollback-lock' we can start rollingback</span>
<span class="source-line-no">1401</span><span id="line-1401">          switch (executeRollback(rootProcId, procStack)) {</span>
<span class="source-line-no">1402</span><span id="line-1402">            case LOCK_ACQUIRED:</span>
<span class="source-line-no">1403</span><span id="line-1403">              break;</span>
<span class="source-line-no">1404</span><span id="line-1404">            case LOCK_YIELD_WAIT:</span>
<span class="source-line-no">1405</span><span id="line-1405">              procStack.unsetRollback();</span>
<span class="source-line-no">1406</span><span id="line-1406">              scheduler.yield(proc);</span>
<span class="source-line-no">1407</span><span id="line-1407">              break;</span>
<span class="source-line-no">1408</span><span id="line-1408">            case LOCK_EVENT_WAIT:</span>
<span class="source-line-no">1409</span><span id="line-1409">              LOG.info("LOCK_EVENT_WAIT rollback..." + proc);</span>
<span class="source-line-no">1410</span><span id="line-1410">              procStack.unsetRollback();</span>
<span class="source-line-no">1411</span><span id="line-1411">              break;</span>
<span class="source-line-no">1412</span><span id="line-1412">            default:</span>
<span class="source-line-no">1413</span><span id="line-1413">              throw new UnsupportedOperationException();</span>
<span class="source-line-no">1414</span><span id="line-1414">          }</span>
<span class="source-line-no">1415</span><span id="line-1415">        } else {</span>
<span class="source-line-no">1416</span><span id="line-1416">          // if we can't rollback means that some child is still running.</span>
<span class="source-line-no">1417</span><span id="line-1417">          // the rollback will be executed after all the children are done.</span>
<span class="source-line-no">1418</span><span id="line-1418">          // If the procedure was never executed, remove and mark it as rolledback.</span>
<span class="source-line-no">1419</span><span id="line-1419">          if (!proc.wasExecuted()) {</span>
<span class="source-line-no">1420</span><span id="line-1420">            switch (executeRollback(proc)) {</span>
<span class="source-line-no">1421</span><span id="line-1421">              case LOCK_ACQUIRED:</span>
<span class="source-line-no">1422</span><span id="line-1422">                break;</span>
<span class="source-line-no">1423</span><span id="line-1423">              case LOCK_YIELD_WAIT:</span>
<span class="source-line-no">1424</span><span id="line-1424">                scheduler.yield(proc);</span>
<span class="source-line-no">1425</span><span id="line-1425">                break;</span>
<span class="source-line-no">1426</span><span id="line-1426">              case LOCK_EVENT_WAIT:</span>
<span class="source-line-no">1427</span><span id="line-1427">                LOG.info("LOCK_EVENT_WAIT can't rollback child running?..." + proc);</span>
<span class="source-line-no">1428</span><span id="line-1428">                break;</span>
<span class="source-line-no">1429</span><span id="line-1429">              default:</span>
<span class="source-line-no">1430</span><span id="line-1430">                throw new UnsupportedOperationException();</span>
<span class="source-line-no">1431</span><span id="line-1431">            }</span>
<span class="source-line-no">1432</span><span id="line-1432">          }</span>
<span class="source-line-no">1433</span><span id="line-1433">        }</span>
<span class="source-line-no">1434</span><span id="line-1434">        break;</span>
<span class="source-line-no">1435</span><span id="line-1435">      }</span>
<span class="source-line-no">1436</span><span id="line-1436"></span>
<span class="source-line-no">1437</span><span id="line-1437">      // Execute the procedure</span>
<span class="source-line-no">1438</span><span id="line-1438">      assert proc.getState() == ProcedureState.RUNNABLE : proc;</span>
<span class="source-line-no">1439</span><span id="line-1439">      // Note that lock is NOT about concurrency but rather about ensuring</span>
<span class="source-line-no">1440</span><span id="line-1440">      // ownership of a procedure of an entity such as a region or table</span>
<span class="source-line-no">1441</span><span id="line-1441">      LockState lockState = acquireLock(proc);</span>
<span class="source-line-no">1442</span><span id="line-1442">      switch (lockState) {</span>
<span class="source-line-no">1443</span><span id="line-1443">        case LOCK_ACQUIRED:</span>
<span class="source-line-no">1444</span><span id="line-1444">          execProcedure(procStack, proc);</span>
<span class="source-line-no">1445</span><span id="line-1445">          break;</span>
<span class="source-line-no">1446</span><span id="line-1446">        case LOCK_YIELD_WAIT:</span>
<span class="source-line-no">1447</span><span id="line-1447">          LOG.info(lockState + " " + proc);</span>
<span class="source-line-no">1448</span><span id="line-1448">          scheduler.yield(proc);</span>
<span class="source-line-no">1449</span><span id="line-1449">          break;</span>
<span class="source-line-no">1450</span><span id="line-1450">        case LOCK_EVENT_WAIT:</span>
<span class="source-line-no">1451</span><span id="line-1451">          // Someone will wake us up when the lock is available</span>
<span class="source-line-no">1452</span><span id="line-1452">          LOG.debug(lockState + " " + proc);</span>
<span class="source-line-no">1453</span><span id="line-1453">          break;</span>
<span class="source-line-no">1454</span><span id="line-1454">        default:</span>
<span class="source-line-no">1455</span><span id="line-1455">          throw new UnsupportedOperationException();</span>
<span class="source-line-no">1456</span><span id="line-1456">      }</span>
<span class="source-line-no">1457</span><span id="line-1457">      procStack.release(proc);</span>
<span class="source-line-no">1458</span><span id="line-1458"></span>
<span class="source-line-no">1459</span><span id="line-1459">      if (proc.isSuccess()) {</span>
<span class="source-line-no">1460</span><span id="line-1460">        // update metrics on finishing the procedure</span>
<span class="source-line-no">1461</span><span id="line-1461">        proc.updateMetricsOnFinish(getEnvironment(), proc.elapsedTime(), true);</span>
<span class="source-line-no">1462</span><span id="line-1462">        LOG.info("Finished " + proc + " in " + StringUtils.humanTimeDiff(proc.elapsedTime()));</span>
<span class="source-line-no">1463</span><span id="line-1463">        // Finalize the procedure state</span>
<span class="source-line-no">1464</span><span id="line-1464">        if (proc.getProcId() == rootProcId) {</span>
<span class="source-line-no">1465</span><span id="line-1465">          procedureFinished(proc);</span>
<span class="source-line-no">1466</span><span id="line-1466">        } else {</span>
<span class="source-line-no">1467</span><span id="line-1467">          execCompletionCleanup(proc);</span>
<span class="source-line-no">1468</span><span id="line-1468">        }</span>
<span class="source-line-no">1469</span><span id="line-1469">        break;</span>
<span class="source-line-no">1470</span><span id="line-1470">      }</span>
<span class="source-line-no">1471</span><span id="line-1471">    } while (procStack.isFailed());</span>
<span class="source-line-no">1472</span><span id="line-1472">  }</span>
<span class="source-line-no">1473</span><span id="line-1473"></span>
<span class="source-line-no">1474</span><span id="line-1474">  private LockState acquireLock(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1475</span><span id="line-1475">    TEnvironment env = getEnvironment();</span>
<span class="source-line-no">1476</span><span id="line-1476">    // if holdLock is true, then maybe we already have the lock, so just return LOCK_ACQUIRED if</span>
<span class="source-line-no">1477</span><span id="line-1477">    // hasLock is true.</span>
<span class="source-line-no">1478</span><span id="line-1478">    if (proc.hasLock()) {</span>
<span class="source-line-no">1479</span><span id="line-1479">      return LockState.LOCK_ACQUIRED;</span>
<span class="source-line-no">1480</span><span id="line-1480">    }</span>
<span class="source-line-no">1481</span><span id="line-1481">    return proc.doAcquireLock(env, store);</span>
<span class="source-line-no">1482</span><span id="line-1482">  }</span>
<span class="source-line-no">1483</span><span id="line-1483"></span>
<span class="source-line-no">1484</span><span id="line-1484">  private void releaseLock(Procedure&lt;TEnvironment&gt; proc, boolean force) {</span>
<span class="source-line-no">1485</span><span id="line-1485">    TEnvironment env = getEnvironment();</span>
<span class="source-line-no">1486</span><span id="line-1486">    // For how the framework works, we know that we will always have the lock</span>
<span class="source-line-no">1487</span><span id="line-1487">    // when we call releaseLock(), so we can avoid calling proc.hasLock()</span>
<span class="source-line-no">1488</span><span id="line-1488">    if (force || !proc.holdLock(env) || proc.isFinished()) {</span>
<span class="source-line-no">1489</span><span id="line-1489">      proc.doReleaseLock(env, store);</span>
<span class="source-line-no">1490</span><span id="line-1490">    }</span>
<span class="source-line-no">1491</span><span id="line-1491">  }</span>
<span class="source-line-no">1492</span><span id="line-1492"></span>
<span class="source-line-no">1493</span><span id="line-1493">  // Returning null means we have already held the execution lock, so you do not need to get the</span>
<span class="source-line-no">1494</span><span id="line-1494">  // lock entry for releasing</span>
<span class="source-line-no">1495</span><span id="line-1495">  private IdLock.Entry getLockEntryForRollback(long procId) {</span>
<span class="source-line-no">1496</span><span id="line-1496">    // Hold the execution lock if it is not held by us. The IdLock is not reentrant so we need</span>
<span class="source-line-no">1497</span><span id="line-1497">    // this check, as the worker will hold the lock before executing a procedure. This is the only</span>
<span class="source-line-no">1498</span><span id="line-1498">    // place where we may hold two procedure execution locks, and there is a fence in the</span>
<span class="source-line-no">1499</span><span id="line-1499">    // RootProcedureState where we can make sure that only one worker can execute the rollback of</span>
<span class="source-line-no">1500</span><span id="line-1500">    // a RootProcedureState, so there is no dead lock problem. And the lock here is necessary to</span>
<span class="source-line-no">1501</span><span id="line-1501">    // prevent race between us and the force update thread.</span>
<span class="source-line-no">1502</span><span id="line-1502">    if (!procExecutionLock.isHeldByCurrentThread(procId)) {</span>
<span class="source-line-no">1503</span><span id="line-1503">      try {</span>
<span class="source-line-no">1504</span><span id="line-1504">        return procExecutionLock.getLockEntry(procId);</span>
<span class="source-line-no">1505</span><span id="line-1505">      } catch (IOException e) {</span>
<span class="source-line-no">1506</span><span id="line-1506">        // can only happen if interrupted, so not a big deal to propagate it</span>
<span class="source-line-no">1507</span><span id="line-1507">        throw new UncheckedIOException(e);</span>
<span class="source-line-no">1508</span><span id="line-1508">      }</span>
<span class="source-line-no">1509</span><span id="line-1509">    }</span>
<span class="source-line-no">1510</span><span id="line-1510">    return null;</span>
<span class="source-line-no">1511</span><span id="line-1511">  }</span>
<span class="source-line-no">1512</span><span id="line-1512"></span>
<span class="source-line-no">1513</span><span id="line-1513">  private void executeUnexpectedRollback(Procedure&lt;TEnvironment&gt; rootProc,</span>
<span class="source-line-no">1514</span><span id="line-1514">    RootProcedureState&lt;TEnvironment&gt; procStack) {</span>
<span class="source-line-no">1515</span><span id="line-1515">    if (procStack.getSubprocs() != null) {</span>
<span class="source-line-no">1516</span><span id="line-1516">      // comparing proc id in reverse order, so we will delete later procedures first, otherwise we</span>
<span class="source-line-no">1517</span><span id="line-1517">      // may delete parent procedure first and if we fail in the middle of this operation, when</span>
<span class="source-line-no">1518</span><span id="line-1518">      // loading we will find some orphan procedures</span>
<span class="source-line-no">1519</span><span id="line-1519">      PriorityQueue&lt;Procedure&lt;TEnvironment&gt;&gt; pq =</span>
<span class="source-line-no">1520</span><span id="line-1520">        new PriorityQueue&lt;&gt;(procStack.getSubprocs().size(),</span>
<span class="source-line-no">1521</span><span id="line-1521">          Comparator.&lt;Procedure&lt;TEnvironment&gt;&gt; comparingLong(Procedure::getProcId).reversed());</span>
<span class="source-line-no">1522</span><span id="line-1522">      pq.addAll(procStack.getSubprocs());</span>
<span class="source-line-no">1523</span><span id="line-1523">      for (;;) {</span>
<span class="source-line-no">1524</span><span id="line-1524">        Procedure&lt;TEnvironment&gt; subproc = pq.poll();</span>
<span class="source-line-no">1525</span><span id="line-1525">        if (subproc == null) {</span>
<span class="source-line-no">1526</span><span id="line-1526">          break;</span>
<span class="source-line-no">1527</span><span id="line-1527">        }</span>
<span class="source-line-no">1528</span><span id="line-1528">        if (!procedures.containsKey(subproc.getProcId())) {</span>
<span class="source-line-no">1529</span><span id="line-1529">          // this means it has already been rolledback</span>
<span class="source-line-no">1530</span><span id="line-1530">          continue;</span>
<span class="source-line-no">1531</span><span id="line-1531">        }</span>
<span class="source-line-no">1532</span><span id="line-1532">        IdLock.Entry lockEntry = getLockEntryForRollback(subproc.getProcId());</span>
<span class="source-line-no">1533</span><span id="line-1533">        try {</span>
<span class="source-line-no">1534</span><span id="line-1534">          cleanupAfterRollbackOneStep(subproc);</span>
<span class="source-line-no">1535</span><span id="line-1535">          execCompletionCleanup(subproc);</span>
<span class="source-line-no">1536</span><span id="line-1536">        } finally {</span>
<span class="source-line-no">1537</span><span id="line-1537">          if (lockEntry != null) {</span>
<span class="source-line-no">1538</span><span id="line-1538">            procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">1539</span><span id="line-1539">          }</span>
<span class="source-line-no">1540</span><span id="line-1540">        }</span>
<span class="source-line-no">1541</span><span id="line-1541">      }</span>
<span class="source-line-no">1542</span><span id="line-1542">    }</span>
<span class="source-line-no">1543</span><span id="line-1543">    IdLock.Entry lockEntry = getLockEntryForRollback(rootProc.getProcId());</span>
<span class="source-line-no">1544</span><span id="line-1544">    try {</span>
<span class="source-line-no">1545</span><span id="line-1545">      cleanupAfterRollbackOneStep(rootProc);</span>
<span class="source-line-no">1546</span><span id="line-1546">    } finally {</span>
<span class="source-line-no">1547</span><span id="line-1547">      if (lockEntry != null) {</span>
<span class="source-line-no">1548</span><span id="line-1548">        procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">1549</span><span id="line-1549">      }</span>
<span class="source-line-no">1550</span><span id="line-1550">    }</span>
<span class="source-line-no">1551</span><span id="line-1551">  }</span>
<span class="source-line-no">1552</span><span id="line-1552"></span>
<span class="source-line-no">1553</span><span id="line-1553">  private LockState executeNormalRollback(Procedure&lt;TEnvironment&gt; rootProc,</span>
<span class="source-line-no">1554</span><span id="line-1554">    RootProcedureState&lt;TEnvironment&gt; procStack) {</span>
<span class="source-line-no">1555</span><span id="line-1555">    List&lt;Procedure&lt;TEnvironment&gt;&gt; subprocStack = procStack.getSubproceduresStack();</span>
<span class="source-line-no">1556</span><span id="line-1556">    assert subprocStack != null : "Called rollback with no steps executed rootProc=" + rootProc;</span>
<span class="source-line-no">1557</span><span id="line-1557"></span>
<span class="source-line-no">1558</span><span id="line-1558">    int stackTail = subprocStack.size();</span>
<span class="source-line-no">1559</span><span id="line-1559">    while (stackTail-- &gt; 0) {</span>
<span class="source-line-no">1560</span><span id="line-1560">      Procedure&lt;TEnvironment&gt; proc = subprocStack.get(stackTail);</span>
<span class="source-line-no">1561</span><span id="line-1561">      IdLock.Entry lockEntry = getLockEntryForRollback(proc.getProcId());</span>
<span class="source-line-no">1562</span><span id="line-1562">      try {</span>
<span class="source-line-no">1563</span><span id="line-1563">        // For the sub procedures which are successfully finished, we do not rollback them.</span>
<span class="source-line-no">1564</span><span id="line-1564">        // Typically, if we want to rollback a procedure, we first need to rollback it, and then</span>
<span class="source-line-no">1565</span><span id="line-1565">        // recursively rollback its ancestors. The state changes which are done by sub procedures</span>
<span class="source-line-no">1566</span><span id="line-1566">        // should be handled by parent procedures when rolling back. For example, when rolling back</span>
<span class="source-line-no">1567</span><span id="line-1567">        // a MergeTableProcedure, we will schedule new procedures to bring the offline regions</span>
<span class="source-line-no">1568</span><span id="line-1568">        // online, instead of rolling back the original procedures which offlined the regions(in</span>
<span class="source-line-no">1569</span><span id="line-1569">        // fact these procedures can not be rolled back...).</span>
<span class="source-line-no">1570</span><span id="line-1570">        if (proc.isSuccess()) {</span>
<span class="source-line-no">1571</span><span id="line-1571">          // Just do the cleanup work, without actually executing the rollback</span>
<span class="source-line-no">1572</span><span id="line-1572">          subprocStack.remove(stackTail);</span>
<span class="source-line-no">1573</span><span id="line-1573">          cleanupAfterRollbackOneStep(proc);</span>
<span class="source-line-no">1574</span><span id="line-1574">          continue;</span>
<span class="source-line-no">1575</span><span id="line-1575">        }</span>
<span class="source-line-no">1576</span><span id="line-1576">        LockState lockState = acquireLock(proc);</span>
<span class="source-line-no">1577</span><span id="line-1577">        if (lockState != LockState.LOCK_ACQUIRED) {</span>
<span class="source-line-no">1578</span><span id="line-1578">          // can't take a lock on the procedure, add the root-proc back on the</span>
<span class="source-line-no">1579</span><span id="line-1579">          // queue waiting for the lock availability</span>
<span class="source-line-no">1580</span><span id="line-1580">          return lockState;</span>
<span class="source-line-no">1581</span><span id="line-1581">        }</span>
<span class="source-line-no">1582</span><span id="line-1582"></span>
<span class="source-line-no">1583</span><span id="line-1583">        lockState = executeRollback(proc);</span>
<span class="source-line-no">1584</span><span id="line-1584">        releaseLock(proc, false);</span>
<span class="source-line-no">1585</span><span id="line-1585">        boolean abortRollback = lockState != LockState.LOCK_ACQUIRED;</span>
<span class="source-line-no">1586</span><span id="line-1586">        abortRollback |= !isRunning() || !store.isRunning();</span>
<span class="source-line-no">1587</span><span id="line-1587"></span>
<span class="source-line-no">1588</span><span id="line-1588">        // allows to kill the executor before something is stored to the wal.</span>
<span class="source-line-no">1589</span><span id="line-1589">        // useful to test the procedure recovery.</span>
<span class="source-line-no">1590</span><span id="line-1590">        if (abortRollback) {</span>
<span class="source-line-no">1591</span><span id="line-1591">          return lockState;</span>
<span class="source-line-no">1592</span><span id="line-1592">        }</span>
<span class="source-line-no">1593</span><span id="line-1593"></span>
<span class="source-line-no">1594</span><span id="line-1594">        subprocStack.remove(stackTail);</span>
<span class="source-line-no">1595</span><span id="line-1595"></span>
<span class="source-line-no">1596</span><span id="line-1596">        // if the procedure is kind enough to pass the slot to someone else, yield</span>
<span class="source-line-no">1597</span><span id="line-1597">        // if the proc is already finished, do not yield</span>
<span class="source-line-no">1598</span><span id="line-1598">        if (!proc.isFinished() &amp;&amp; proc.isYieldAfterExecutionStep(getEnvironment())) {</span>
<span class="source-line-no">1599</span><span id="line-1599">          return LockState.LOCK_YIELD_WAIT;</span>
<span class="source-line-no">1600</span><span id="line-1600">        }</span>
<span class="source-line-no">1601</span><span id="line-1601"></span>
<span class="source-line-no">1602</span><span id="line-1602">        if (proc != rootProc) {</span>
<span class="source-line-no">1603</span><span id="line-1603">          execCompletionCleanup(proc);</span>
<span class="source-line-no">1604</span><span id="line-1604">        }</span>
<span class="source-line-no">1605</span><span id="line-1605">      } finally {</span>
<span class="source-line-no">1606</span><span id="line-1606">        if (lockEntry != null) {</span>
<span class="source-line-no">1607</span><span id="line-1607">          procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">1608</span><span id="line-1608">        }</span>
<span class="source-line-no">1609</span><span id="line-1609">      }</span>
<span class="source-line-no">1610</span><span id="line-1610">    }</span>
<span class="source-line-no">1611</span><span id="line-1611">    return LockState.LOCK_ACQUIRED;</span>
<span class="source-line-no">1612</span><span id="line-1612">  }</span>
<span class="source-line-no">1613</span><span id="line-1613"></span>
<span class="source-line-no">1614</span><span id="line-1614">  /**</span>
<span class="source-line-no">1615</span><span id="line-1615">   * Execute the rollback of the full procedure stack. Once the procedure is rolledback, the</span>
<span class="source-line-no">1616</span><span id="line-1616">   * root-procedure will be visible as finished to user, and the result will be the fatal exception.</span>
<span class="source-line-no">1617</span><span id="line-1617">   */</span>
<span class="source-line-no">1618</span><span id="line-1618">  private LockState executeRollback(long rootProcId, RootProcedureState&lt;TEnvironment&gt; procStack) {</span>
<span class="source-line-no">1619</span><span id="line-1619">    Procedure&lt;TEnvironment&gt; rootProc = procedures.get(rootProcId);</span>
<span class="source-line-no">1620</span><span id="line-1620">    RemoteProcedureException exception = rootProc.getException();</span>
<span class="source-line-no">1621</span><span id="line-1621">    // TODO: This needs doc. The root proc doesn't have an exception. Maybe we are</span>
<span class="source-line-no">1622</span><span id="line-1622">    // rolling back because the subprocedure does. Clarify.</span>
<span class="source-line-no">1623</span><span id="line-1623">    if (exception == null) {</span>
<span class="source-line-no">1624</span><span id="line-1624">      exception = procStack.getException();</span>
<span class="source-line-no">1625</span><span id="line-1625">      rootProc.setFailure(exception);</span>
<span class="source-line-no">1626</span><span id="line-1626">      store.update(rootProc);</span>
<span class="source-line-no">1627</span><span id="line-1627">    }</span>
<span class="source-line-no">1628</span><span id="line-1628"></span>
<span class="source-line-no">1629</span><span id="line-1629">    if (procStack.isRollbackSupported()) {</span>
<span class="source-line-no">1630</span><span id="line-1630">      LockState lockState = executeNormalRollback(rootProc, procStack);</span>
<span class="source-line-no">1631</span><span id="line-1631">      if (lockState != LockState.LOCK_ACQUIRED) {</span>
<span class="source-line-no">1632</span><span id="line-1632">        return lockState;</span>
<span class="source-line-no">1633</span><span id="line-1633">      }</span>
<span class="source-line-no">1634</span><span id="line-1634">    } else {</span>
<span class="source-line-no">1635</span><span id="line-1635">      // the procedure does not support rollback, so typically we should not reach here, this</span>
<span class="source-line-no">1636</span><span id="line-1636">      // usually means there are code bugs, let's just wait all the subprocedures to finish and then</span>
<span class="source-line-no">1637</span><span id="line-1637">      // mark the root procedure as failure.</span>
<span class="source-line-no">1638</span><span id="line-1638">      LOG.error(HBaseMarkers.FATAL,</span>
<span class="source-line-no">1639</span><span id="line-1639">        "Root Procedure {} does not support rollback but the execution failed"</span>
<span class="source-line-no">1640</span><span id="line-1640">          + " and try to rollback, code bug?",</span>
<span class="source-line-no">1641</span><span id="line-1641">        rootProc, exception);</span>
<span class="source-line-no">1642</span><span id="line-1642">      executeUnexpectedRollback(rootProc, procStack);</span>
<span class="source-line-no">1643</span><span id="line-1643">    }</span>
<span class="source-line-no">1644</span><span id="line-1644"></span>
<span class="source-line-no">1645</span><span id="line-1645">    IdLock.Entry lockEntry = getLockEntryForRollback(rootProc.getProcId());</span>
<span class="source-line-no">1646</span><span id="line-1646">    try {</span>
<span class="source-line-no">1647</span><span id="line-1647">      // Finalize the procedure state</span>
<span class="source-line-no">1648</span><span id="line-1648">      LOG.info("Rolled back {} exec-time={}", rootProc,</span>
<span class="source-line-no">1649</span><span id="line-1649">        StringUtils.humanTimeDiff(rootProc.elapsedTime()));</span>
<span class="source-line-no">1650</span><span id="line-1650">      procedureFinished(rootProc);</span>
<span class="source-line-no">1651</span><span id="line-1651">    } finally {</span>
<span class="source-line-no">1652</span><span id="line-1652">      if (lockEntry != null) {</span>
<span class="source-line-no">1653</span><span id="line-1653">        procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">1654</span><span id="line-1654">      }</span>
<span class="source-line-no">1655</span><span id="line-1655">    }</span>
<span class="source-line-no">1656</span><span id="line-1656"></span>
<span class="source-line-no">1657</span><span id="line-1657">    return LockState.LOCK_ACQUIRED;</span>
<span class="source-line-no">1658</span><span id="line-1658">  }</span>
<span class="source-line-no">1659</span><span id="line-1659"></span>
<span class="source-line-no">1660</span><span id="line-1660">  private void cleanupAfterRollbackOneStep(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1661</span><span id="line-1661">    if (testing != null &amp;&amp; testing.shouldKillBeforeStoreUpdateInRollback()) {</span>
<span class="source-line-no">1662</span><span id="line-1662">      kill("TESTING: Kill BEFORE store update in rollback: " + proc);</span>
<span class="source-line-no">1663</span><span id="line-1663">    }</span>
<span class="source-line-no">1664</span><span id="line-1664">    if (proc.removeStackIndex()) {</span>
<span class="source-line-no">1665</span><span id="line-1665">      if (!proc.isSuccess()) {</span>
<span class="source-line-no">1666</span><span id="line-1666">        proc.setState(ProcedureState.ROLLEDBACK);</span>
<span class="source-line-no">1667</span><span id="line-1667">      }</span>
<span class="source-line-no">1668</span><span id="line-1668"></span>
<span class="source-line-no">1669</span><span id="line-1669">      // update metrics on finishing the procedure (fail)</span>
<span class="source-line-no">1670</span><span id="line-1670">      proc.updateMetricsOnFinish(getEnvironment(), proc.elapsedTime(), false);</span>
<span class="source-line-no">1671</span><span id="line-1671"></span>
<span class="source-line-no">1672</span><span id="line-1672">      if (proc.hasParent()) {</span>
<span class="source-line-no">1673</span><span id="line-1673">        store.delete(proc.getProcId());</span>
<span class="source-line-no">1674</span><span id="line-1674">        procedures.remove(proc.getProcId());</span>
<span class="source-line-no">1675</span><span id="line-1675">      } else {</span>
<span class="source-line-no">1676</span><span id="line-1676">        final long[] childProcIds = rollbackStack.get(proc.getProcId()).getSubprocedureIds();</span>
<span class="source-line-no">1677</span><span id="line-1677">        if (childProcIds != null) {</span>
<span class="source-line-no">1678</span><span id="line-1678">          store.delete(proc, childProcIds);</span>
<span class="source-line-no">1679</span><span id="line-1679">        } else {</span>
<span class="source-line-no">1680</span><span id="line-1680">          store.update(proc);</span>
<span class="source-line-no">1681</span><span id="line-1681">        }</span>
<span class="source-line-no">1682</span><span id="line-1682">      }</span>
<span class="source-line-no">1683</span><span id="line-1683">    } else {</span>
<span class="source-line-no">1684</span><span id="line-1684">      store.update(proc);</span>
<span class="source-line-no">1685</span><span id="line-1685">    }</span>
<span class="source-line-no">1686</span><span id="line-1686">  }</span>
<span class="source-line-no">1687</span><span id="line-1687"></span>
<span class="source-line-no">1688</span><span id="line-1688">  /**</span>
<span class="source-line-no">1689</span><span id="line-1689">   * Execute the rollback of the procedure step. It updates the store with the new state (stack</span>
<span class="source-line-no">1690</span><span id="line-1690">   * index) or will remove completly the procedure in case it is a child.</span>
<span class="source-line-no">1691</span><span id="line-1691">   */</span>
<span class="source-line-no">1692</span><span id="line-1692">  private LockState executeRollback(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1693</span><span id="line-1693">    try {</span>
<span class="source-line-no">1694</span><span id="line-1694">      proc.doRollback(getEnvironment());</span>
<span class="source-line-no">1695</span><span id="line-1695">    } catch (IOException e) {</span>
<span class="source-line-no">1696</span><span id="line-1696">      LOG.debug("Roll back attempt failed for {}", proc, e);</span>
<span class="source-line-no">1697</span><span id="line-1697">      return LockState.LOCK_YIELD_WAIT;</span>
<span class="source-line-no">1698</span><span id="line-1698">    } catch (InterruptedException e) {</span>
<span class="source-line-no">1699</span><span id="line-1699">      handleInterruptedException(proc, e);</span>
<span class="source-line-no">1700</span><span id="line-1700">      return LockState.LOCK_YIELD_WAIT;</span>
<span class="source-line-no">1701</span><span id="line-1701">    } catch (Throwable e) {</span>
<span class="source-line-no">1702</span><span id="line-1702">      // Catch NullPointerExceptions or similar errors...</span>
<span class="source-line-no">1703</span><span id="line-1703">      LOG.error(HBaseMarkers.FATAL, "CODE-BUG: Uncaught runtime exception for " + proc, e);</span>
<span class="source-line-no">1704</span><span id="line-1704">    }</span>
<span class="source-line-no">1705</span><span id="line-1705"></span>
<span class="source-line-no">1706</span><span id="line-1706">    cleanupAfterRollbackOneStep(proc);</span>
<span class="source-line-no">1707</span><span id="line-1707"></span>
<span class="source-line-no">1708</span><span id="line-1708">    return LockState.LOCK_ACQUIRED;</span>
<span class="source-line-no">1709</span><span id="line-1709">  }</span>
<span class="source-line-no">1710</span><span id="line-1710"></span>
<span class="source-line-no">1711</span><span id="line-1711">  private void yieldProcedure(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">1712</span><span id="line-1712">    releaseLock(proc, false);</span>
<span class="source-line-no">1713</span><span id="line-1713">    scheduler.yield(proc);</span>
<span class="source-line-no">1714</span><span id="line-1714">  }</span>
<span class="source-line-no">1715</span><span id="line-1715"></span>
<span class="source-line-no">1716</span><span id="line-1716">  /**</span>
<span class="source-line-no">1717</span><span id="line-1717">   * Executes &lt;code&gt;procedure&lt;/code&gt;</span>
<span class="source-line-no">1718</span><span id="line-1718">   * &lt;ul&gt;</span>
<span class="source-line-no">1719</span><span id="line-1719">   * &lt;li&gt;Calls the doExecute() of the procedure</span>
<span class="source-line-no">1720</span><span id="line-1720">   * &lt;li&gt;If the procedure execution didn't fail (i.e. valid user input)</span>
<span class="source-line-no">1721</span><span id="line-1721">   * &lt;ul&gt;</span>
<span class="source-line-no">1722</span><span id="line-1722">   * &lt;li&gt;...and returned subprocedures</span>
<span class="source-line-no">1723</span><span id="line-1723">   * &lt;ul&gt;</span>
<span class="source-line-no">1724</span><span id="line-1724">   * &lt;li&gt;The subprocedures are initialized.</span>
<span class="source-line-no">1725</span><span id="line-1725">   * &lt;li&gt;The subprocedures are added to the store</span>
<span class="source-line-no">1726</span><span id="line-1726">   * &lt;li&gt;The subprocedures are added to the runnable queue</span>
<span class="source-line-no">1727</span><span id="line-1727">   * &lt;li&gt;The procedure is now in a WAITING state, waiting for the subprocedures to complete</span>
<span class="source-line-no">1728</span><span id="line-1728">   * &lt;/ul&gt;</span>
<span class="source-line-no">1729</span><span id="line-1729">   * &lt;/li&gt;</span>
<span class="source-line-no">1730</span><span id="line-1730">   * &lt;li&gt;...if there are no subprocedure</span>
<span class="source-line-no">1731</span><span id="line-1731">   * &lt;ul&gt;</span>
<span class="source-line-no">1732</span><span id="line-1732">   * &lt;li&gt;the procedure completed successfully</span>
<span class="source-line-no">1733</span><span id="line-1733">   * &lt;li&gt;if there is a parent (WAITING)</span>
<span class="source-line-no">1734</span><span id="line-1734">   * &lt;li&gt;the parent state will be set to RUNNABLE</span>
<span class="source-line-no">1735</span><span id="line-1735">   * &lt;/ul&gt;</span>
<span class="source-line-no">1736</span><span id="line-1736">   * &lt;/li&gt;</span>
<span class="source-line-no">1737</span><span id="line-1737">   * &lt;/ul&gt;</span>
<span class="source-line-no">1738</span><span id="line-1738">   * &lt;/li&gt;</span>
<span class="source-line-no">1739</span><span id="line-1739">   * &lt;li&gt;In case of failure</span>
<span class="source-line-no">1740</span><span id="line-1740">   * &lt;ul&gt;</span>
<span class="source-line-no">1741</span><span id="line-1741">   * &lt;li&gt;The store is updated with the new state&lt;/li&gt;</span>
<span class="source-line-no">1742</span><span id="line-1742">   * &lt;li&gt;The executor (caller of this method) will start the rollback of the procedure&lt;/li&gt;</span>
<span class="source-line-no">1743</span><span id="line-1743">   * &lt;/ul&gt;</span>
<span class="source-line-no">1744</span><span id="line-1744">   * &lt;/li&gt;</span>
<span class="source-line-no">1745</span><span id="line-1745">   * &lt;/ul&gt;</span>
<span class="source-line-no">1746</span><span id="line-1746">   */</span>
<span class="source-line-no">1747</span><span id="line-1747">  private void execProcedure(RootProcedureState&lt;TEnvironment&gt; procStack,</span>
<span class="source-line-no">1748</span><span id="line-1748">    Procedure&lt;TEnvironment&gt; procedure) {</span>
<span class="source-line-no">1749</span><span id="line-1749">    Preconditions.checkArgument(procedure.getState() == ProcedureState.RUNNABLE,</span>
<span class="source-line-no">1750</span><span id="line-1750">      "NOT RUNNABLE! " + procedure.toString());</span>
<span class="source-line-no">1751</span><span id="line-1751"></span>
<span class="source-line-no">1752</span><span id="line-1752">    // Procedures can suspend themselves. They skip out by throwing a ProcedureSuspendedException.</span>
<span class="source-line-no">1753</span><span id="line-1753">    // The exception is caught below and then we hurry to the exit without disturbing state. The</span>
<span class="source-line-no">1754</span><span id="line-1754">    // idea is that the processing of this procedure will be unsuspended later by an external event</span>
<span class="source-line-no">1755</span><span id="line-1755">    // such the report of a region open.</span>
<span class="source-line-no">1756</span><span id="line-1756">    boolean suspended = false;</span>
<span class="source-line-no">1757</span><span id="line-1757"></span>
<span class="source-line-no">1758</span><span id="line-1758">    // Whether to 're-' -execute; run through the loop again.</span>
<span class="source-line-no">1759</span><span id="line-1759">    boolean reExecute = false;</span>
<span class="source-line-no">1760</span><span id="line-1760"></span>
<span class="source-line-no">1761</span><span id="line-1761">    Procedure&lt;TEnvironment&gt;[] subprocs = null;</span>
<span class="source-line-no">1762</span><span id="line-1762">    do {</span>
<span class="source-line-no">1763</span><span id="line-1763">      reExecute = false;</span>
<span class="source-line-no">1764</span><span id="line-1764">      procedure.resetPersistence();</span>
<span class="source-line-no">1765</span><span id="line-1765">      try {</span>
<span class="source-line-no">1766</span><span id="line-1766">        subprocs = procedure.doExecute(getEnvironment());</span>
<span class="source-line-no">1767</span><span id="line-1767">        if (subprocs != null &amp;&amp; subprocs.length == 0) {</span>
<span class="source-line-no">1768</span><span id="line-1768">          subprocs = null;</span>
<span class="source-line-no">1769</span><span id="line-1769">        }</span>
<span class="source-line-no">1770</span><span id="line-1770">      } catch (ProcedureSuspendedException e) {</span>
<span class="source-line-no">1771</span><span id="line-1771">        LOG.trace("Suspend {}", procedure);</span>
<span class="source-line-no">1772</span><span id="line-1772">        suspended = true;</span>
<span class="source-line-no">1773</span><span id="line-1773">      } catch (ProcedureYieldException e) {</span>
<span class="source-line-no">1774</span><span id="line-1774">        LOG.trace("Yield {}", procedure, e);</span>
<span class="source-line-no">1775</span><span id="line-1775">        yieldProcedure(procedure);</span>
<span class="source-line-no">1776</span><span id="line-1776">        return;</span>
<span class="source-line-no">1777</span><span id="line-1777">      } catch (InterruptedException e) {</span>
<span class="source-line-no">1778</span><span id="line-1778">        LOG.trace("Yield interrupt {}", procedure, e);</span>
<span class="source-line-no">1779</span><span id="line-1779">        handleInterruptedException(procedure, e);</span>
<span class="source-line-no">1780</span><span id="line-1780">        yieldProcedure(procedure);</span>
<span class="source-line-no">1781</span><span id="line-1781">        return;</span>
<span class="source-line-no">1782</span><span id="line-1782">      } catch (Throwable e) {</span>
<span class="source-line-no">1783</span><span id="line-1783">        // Catch NullPointerExceptions or similar errors...</span>
<span class="source-line-no">1784</span><span id="line-1784">        String msg = "CODE-BUG: Uncaught runtime exception: " + procedure;</span>
<span class="source-line-no">1785</span><span id="line-1785">        LOG.error(msg, e);</span>
<span class="source-line-no">1786</span><span id="line-1786">        procedure.setFailure(new RemoteProcedureException(msg, e));</span>
<span class="source-line-no">1787</span><span id="line-1787">      }</span>
<span class="source-line-no">1788</span><span id="line-1788"></span>
<span class="source-line-no">1789</span><span id="line-1789">      if (!procedure.isFailed()) {</span>
<span class="source-line-no">1790</span><span id="line-1790">        if (subprocs != null) {</span>
<span class="source-line-no">1791</span><span id="line-1791">          if (subprocs.length == 1 &amp;&amp; subprocs[0] == procedure) {</span>
<span class="source-line-no">1792</span><span id="line-1792">            // Procedure returned itself. Quick-shortcut for a state machine-like procedure;</span>
<span class="source-line-no">1793</span><span id="line-1793">            // i.e. we go around this loop again rather than go back out on the scheduler queue.</span>
<span class="source-line-no">1794</span><span id="line-1794">            subprocs = null;</span>
<span class="source-line-no">1795</span><span id="line-1795">            reExecute = true;</span>
<span class="source-line-no">1796</span><span id="line-1796">            LOG.trace("Short-circuit to next step on pid={}", procedure.getProcId());</span>
<span class="source-line-no">1797</span><span id="line-1797">          } else {</span>
<span class="source-line-no">1798</span><span id="line-1798">            // Yield the current procedure, and make the subprocedure runnable</span>
<span class="source-line-no">1799</span><span id="line-1799">            // subprocs may come back 'null'.</span>
<span class="source-line-no">1800</span><span id="line-1800">            subprocs = initializeChildren(procStack, procedure, subprocs);</span>
<span class="source-line-no">1801</span><span id="line-1801">            LOG.info("Initialized subprocedures=" + (subprocs == null</span>
<span class="source-line-no">1802</span><span id="line-1802">              ? null</span>
<span class="source-line-no">1803</span><span id="line-1803">              : Stream.of(subprocs).map(e -&gt; "{" + e.toString() + "}").collect(Collectors.toList())</span>
<span class="source-line-no">1804</span><span id="line-1804">                .toString()));</span>
<span class="source-line-no">1805</span><span id="line-1805">          }</span>
<span class="source-line-no">1806</span><span id="line-1806">        } else if (procedure.getState() == ProcedureState.WAITING_TIMEOUT) {</span>
<span class="source-line-no">1807</span><span id="line-1807">          LOG.trace("Added to timeoutExecutor {}", procedure);</span>
<span class="source-line-no">1808</span><span id="line-1808">          timeoutExecutor.add(procedure);</span>
<span class="source-line-no">1809</span><span id="line-1809">        } else if (!suspended) {</span>
<span class="source-line-no">1810</span><span id="line-1810">          // No subtask, so we are done</span>
<span class="source-line-no">1811</span><span id="line-1811">          procedure.setState(ProcedureState.SUCCESS);</span>
<span class="source-line-no">1812</span><span id="line-1812">        }</span>
<span class="source-line-no">1813</span><span id="line-1813">      }</span>
<span class="source-line-no">1814</span><span id="line-1814"></span>
<span class="source-line-no">1815</span><span id="line-1815">      // allows to kill the executor before something is stored to the wal.</span>
<span class="source-line-no">1816</span><span id="line-1816">      // useful to test the procedure recovery.</span>
<span class="source-line-no">1817</span><span id="line-1817">      if (</span>
<span class="source-line-no">1818</span><span id="line-1818">        testing != null &amp;&amp; testing.shouldKillBeforeStoreUpdate(suspended, procedure.hasParent())</span>
<span class="source-line-no">1819</span><span id="line-1819">      ) {</span>
<span class="source-line-no">1820</span><span id="line-1820">        kill("TESTING: Kill BEFORE store update: " + procedure);</span>
<span class="source-line-no">1821</span><span id="line-1821">      }</span>
<span class="source-line-no">1822</span><span id="line-1822"></span>
<span class="source-line-no">1823</span><span id="line-1823">      // TODO: The code here doesn't check if store is running before persisting to the store as</span>
<span class="source-line-no">1824</span><span id="line-1824">      // it relies on the method call below to throw RuntimeException to wind up the stack and</span>
<span class="source-line-no">1825</span><span id="line-1825">      // executor thread to stop. The statement following the method call below seems to check if</span>
<span class="source-line-no">1826</span><span id="line-1826">      // store is not running, to prevent scheduling children procedures, re-execution or yield</span>
<span class="source-line-no">1827</span><span id="line-1827">      // of this procedure. This may need more scrutiny and subsequent cleanup in future</span>
<span class="source-line-no">1828</span><span id="line-1828">      //</span>
<span class="source-line-no">1829</span><span id="line-1829">      // Commit the transaction even if a suspend (state may have changed). Note this append</span>
<span class="source-line-no">1830</span><span id="line-1830">      // can take a bunch of time to complete.</span>
<span class="source-line-no">1831</span><span id="line-1831">      if (procedure.needPersistence()) {</span>
<span class="source-line-no">1832</span><span id="line-1832">        // Add the procedure to the stack</span>
<span class="source-line-no">1833</span><span id="line-1833">        // See HBASE-28210 on why we need synchronized here</span>
<span class="source-line-no">1834</span><span id="line-1834">        boolean needUpdateStoreOutsideLock = false;</span>
<span class="source-line-no">1835</span><span id="line-1835">        synchronized (procStack) {</span>
<span class="source-line-no">1836</span><span id="line-1836">          if (procStack.addRollbackStep(procedure)) {</span>
<span class="source-line-no">1837</span><span id="line-1837">            updateStoreOnExec(procStack, procedure, subprocs);</span>
<span class="source-line-no">1838</span><span id="line-1838">          } else {</span>
<span class="source-line-no">1839</span><span id="line-1839">            needUpdateStoreOutsideLock = true;</span>
<span class="source-line-no">1840</span><span id="line-1840">          }</span>
<span class="source-line-no">1841</span><span id="line-1841">        }</span>
<span class="source-line-no">1842</span><span id="line-1842">        // this is an optimization if we do not need to maintain rollback step, as all subprocedures</span>
<span class="source-line-no">1843</span><span id="line-1843">        // of the same root procedure share the same root procedure state, if we can only update</span>
<span class="source-line-no">1844</span><span id="line-1844">        // store under the above lock, the sub procedures of the same root procedure can only be</span>
<span class="source-line-no">1845</span><span id="line-1845">        // persistent sequentially, which will have a bad performance. See HBASE-28212 for more</span>
<span class="source-line-no">1846</span><span id="line-1846">        // details.</span>
<span class="source-line-no">1847</span><span id="line-1847">        if (needUpdateStoreOutsideLock) {</span>
<span class="source-line-no">1848</span><span id="line-1848">          updateStoreOnExec(procStack, procedure, subprocs);</span>
<span class="source-line-no">1849</span><span id="line-1849">        }</span>
<span class="source-line-no">1850</span><span id="line-1850">      }</span>
<span class="source-line-no">1851</span><span id="line-1851"></span>
<span class="source-line-no">1852</span><span id="line-1852">      // if the store is not running we are aborting</span>
<span class="source-line-no">1853</span><span id="line-1853">      if (!store.isRunning()) {</span>
<span class="source-line-no">1854</span><span id="line-1854">        return;</span>
<span class="source-line-no">1855</span><span id="line-1855">      }</span>
<span class="source-line-no">1856</span><span id="line-1856">      // if the procedure is kind enough to pass the slot to someone else, yield</span>
<span class="source-line-no">1857</span><span id="line-1857">      if (</span>
<span class="source-line-no">1858</span><span id="line-1858">        procedure.isRunnable() &amp;&amp; !suspended</span>
<span class="source-line-no">1859</span><span id="line-1859">          &amp;&amp; procedure.isYieldAfterExecutionStep(getEnvironment())</span>
<span class="source-line-no">1860</span><span id="line-1860">      ) {</span>
<span class="source-line-no">1861</span><span id="line-1861">        yieldProcedure(procedure);</span>
<span class="source-line-no">1862</span><span id="line-1862">        return;</span>
<span class="source-line-no">1863</span><span id="line-1863">      }</span>
<span class="source-line-no">1864</span><span id="line-1864"></span>
<span class="source-line-no">1865</span><span id="line-1865">      assert (reExecute &amp;&amp; subprocs == null) || !reExecute;</span>
<span class="source-line-no">1866</span><span id="line-1866">    } while (reExecute);</span>
<span class="source-line-no">1867</span><span id="line-1867"></span>
<span class="source-line-no">1868</span><span id="line-1868">    // Allows to kill the executor after something is stored to the WAL but before the below</span>
<span class="source-line-no">1869</span><span id="line-1869">    // state settings are done -- in particular the one on the end where we make parent</span>
<span class="source-line-no">1870</span><span id="line-1870">    // RUNNABLE again when its children are done; see countDownChildren.</span>
<span class="source-line-no">1871</span><span id="line-1871">    if (testing != null &amp;&amp; testing.shouldKillAfterStoreUpdate(suspended)) {</span>
<span class="source-line-no">1872</span><span id="line-1872">      kill("TESTING: Kill AFTER store update: " + procedure);</span>
<span class="source-line-no">1873</span><span id="line-1873">    }</span>
<span class="source-line-no">1874</span><span id="line-1874"></span>
<span class="source-line-no">1875</span><span id="line-1875">    // Submit the new subprocedures</span>
<span class="source-line-no">1876</span><span id="line-1876">    if (subprocs != null &amp;&amp; !procedure.isFailed()) {</span>
<span class="source-line-no">1877</span><span id="line-1877">      submitChildrenProcedures(subprocs);</span>
<span class="source-line-no">1878</span><span id="line-1878">    }</span>
<span class="source-line-no">1879</span><span id="line-1879"></span>
<span class="source-line-no">1880</span><span id="line-1880">    // we need to log the release lock operation before waking up the parent procedure, as there</span>
<span class="source-line-no">1881</span><span id="line-1881">    // could be race that the parent procedure may call updateStoreOnExec ahead of us and remove all</span>
<span class="source-line-no">1882</span><span id="line-1882">    // the sub procedures from store and cause problems...</span>
<span class="source-line-no">1883</span><span id="line-1883">    releaseLock(procedure, false);</span>
<span class="source-line-no">1884</span><span id="line-1884"></span>
<span class="source-line-no">1885</span><span id="line-1885">    // if the procedure is complete and has a parent, count down the children latch.</span>
<span class="source-line-no">1886</span><span id="line-1886">    // If 'suspended', do nothing to change state -- let other threads handle unsuspend event.</span>
<span class="source-line-no">1887</span><span id="line-1887">    if (!suspended &amp;&amp; procedure.isFinished() &amp;&amp; procedure.hasParent()) {</span>
<span class="source-line-no">1888</span><span id="line-1888">      countDownChildren(procStack, procedure);</span>
<span class="source-line-no">1889</span><span id="line-1889">    }</span>
<span class="source-line-no">1890</span><span id="line-1890">  }</span>
<span class="source-line-no">1891</span><span id="line-1891"></span>
<span class="source-line-no">1892</span><span id="line-1892">  private void kill(String msg) {</span>
<span class="source-line-no">1893</span><span id="line-1893">    LOG.debug(msg);</span>
<span class="source-line-no">1894</span><span id="line-1894">    stop();</span>
<span class="source-line-no">1895</span><span id="line-1895">    throw new RuntimeException(msg);</span>
<span class="source-line-no">1896</span><span id="line-1896">  }</span>
<span class="source-line-no">1897</span><span id="line-1897"></span>
<span class="source-line-no">1898</span><span id="line-1898">  private Procedure&lt;TEnvironment&gt;[] initializeChildren(RootProcedureState&lt;TEnvironment&gt; procStack,</span>
<span class="source-line-no">1899</span><span id="line-1899">    Procedure&lt;TEnvironment&gt; procedure, Procedure&lt;TEnvironment&gt;[] subprocs) {</span>
<span class="source-line-no">1900</span><span id="line-1900">    assert subprocs != null : "expected subprocedures";</span>
<span class="source-line-no">1901</span><span id="line-1901">    final long rootProcId = getRootProcedureId(procedure);</span>
<span class="source-line-no">1902</span><span id="line-1902">    for (int i = 0; i &lt; subprocs.length; ++i) {</span>
<span class="source-line-no">1903</span><span id="line-1903">      Procedure&lt;TEnvironment&gt; subproc = subprocs[i];</span>
<span class="source-line-no">1904</span><span id="line-1904">      if (subproc == null) {</span>
<span class="source-line-no">1905</span><span id="line-1905">        String msg = "subproc[" + i + "] is null, aborting the procedure";</span>
<span class="source-line-no">1906</span><span id="line-1906">        procedure</span>
<span class="source-line-no">1907</span><span id="line-1907">          .setFailure(new RemoteProcedureException(msg, new IllegalArgumentIOException(msg)));</span>
<span class="source-line-no">1908</span><span id="line-1908">        return null;</span>
<span class="source-line-no">1909</span><span id="line-1909">      }</span>
<span class="source-line-no">1910</span><span id="line-1910"></span>
<span class="source-line-no">1911</span><span id="line-1911">      assert subproc.getState() == ProcedureState.INITIALIZING : subproc;</span>
<span class="source-line-no">1912</span><span id="line-1912">      subproc.setParentProcId(procedure.getProcId());</span>
<span class="source-line-no">1913</span><span id="line-1913">      subproc.setRootProcId(rootProcId);</span>
<span class="source-line-no">1914</span><span id="line-1914">      subproc.setProcId(nextProcId());</span>
<span class="source-line-no">1915</span><span id="line-1915">      procStack.addSubProcedure(subproc);</span>
<span class="source-line-no">1916</span><span id="line-1916">    }</span>
<span class="source-line-no">1917</span><span id="line-1917"></span>
<span class="source-line-no">1918</span><span id="line-1918">    if (!procedure.isFailed()) {</span>
<span class="source-line-no">1919</span><span id="line-1919">      procedure.setChildrenLatch(subprocs.length);</span>
<span class="source-line-no">1920</span><span id="line-1920">      switch (procedure.getState()) {</span>
<span class="source-line-no">1921</span><span id="line-1921">        case RUNNABLE:</span>
<span class="source-line-no">1922</span><span id="line-1922">          procedure.setState(ProcedureState.WAITING);</span>
<span class="source-line-no">1923</span><span id="line-1923">          break;</span>
<span class="source-line-no">1924</span><span id="line-1924">        case WAITING_TIMEOUT:</span>
<span class="source-line-no">1925</span><span id="line-1925">          timeoutExecutor.add(procedure);</span>
<span class="source-line-no">1926</span><span id="line-1926">          break;</span>
<span class="source-line-no">1927</span><span id="line-1927">        default:</span>
<span class="source-line-no">1928</span><span id="line-1928">          break;</span>
<span class="source-line-no">1929</span><span id="line-1929">      }</span>
<span class="source-line-no">1930</span><span id="line-1930">    }</span>
<span class="source-line-no">1931</span><span id="line-1931">    return subprocs;</span>
<span class="source-line-no">1932</span><span id="line-1932">  }</span>
<span class="source-line-no">1933</span><span id="line-1933"></span>
<span class="source-line-no">1934</span><span id="line-1934">  private void submitChildrenProcedures(Procedure&lt;TEnvironment&gt;[] subprocs) {</span>
<span class="source-line-no">1935</span><span id="line-1935">    for (int i = 0; i &lt; subprocs.length; ++i) {</span>
<span class="source-line-no">1936</span><span id="line-1936">      Procedure&lt;TEnvironment&gt; subproc = subprocs[i];</span>
<span class="source-line-no">1937</span><span id="line-1937">      subproc.updateMetricsOnSubmit(getEnvironment());</span>
<span class="source-line-no">1938</span><span id="line-1938">      assert !procedures.containsKey(subproc.getProcId());</span>
<span class="source-line-no">1939</span><span id="line-1939">      procedures.put(subproc.getProcId(), subproc);</span>
<span class="source-line-no">1940</span><span id="line-1940">      scheduler.addFront(subproc);</span>
<span class="source-line-no">1941</span><span id="line-1941">    }</span>
<span class="source-line-no">1942</span><span id="line-1942">  }</span>
<span class="source-line-no">1943</span><span id="line-1943"></span>
<span class="source-line-no">1944</span><span id="line-1944">  private void countDownChildren(RootProcedureState&lt;TEnvironment&gt; procStack,</span>
<span class="source-line-no">1945</span><span id="line-1945">    Procedure&lt;TEnvironment&gt; procedure) {</span>
<span class="source-line-no">1946</span><span id="line-1946">    Procedure&lt;TEnvironment&gt; parent = procedures.get(procedure.getParentProcId());</span>
<span class="source-line-no">1947</span><span id="line-1947">    if (parent == null) {</span>
<span class="source-line-no">1948</span><span id="line-1948">      assert procStack.isRollingback();</span>
<span class="source-line-no">1949</span><span id="line-1949">      return;</span>
<span class="source-line-no">1950</span><span id="line-1950">    }</span>
<span class="source-line-no">1951</span><span id="line-1951"></span>
<span class="source-line-no">1952</span><span id="line-1952">    // If this procedure is the last child awake the parent procedure</span>
<span class="source-line-no">1953</span><span id="line-1953">    if (parent.tryRunnable()) {</span>
<span class="source-line-no">1954</span><span id="line-1954">      // If we succeeded in making the parent runnable -- i.e. all of its</span>
<span class="source-line-no">1955</span><span id="line-1955">      // children have completed, move parent to front of the queue.</span>
<span class="source-line-no">1956</span><span id="line-1956">      store.update(parent);</span>
<span class="source-line-no">1957</span><span id="line-1957">      scheduler.addFront(parent);</span>
<span class="source-line-no">1958</span><span id="line-1958">      LOG.info("Finished subprocedure pid={}, resume processing ppid={}", procedure.getProcId(),</span>
<span class="source-line-no">1959</span><span id="line-1959">        parent.getProcId());</span>
<span class="source-line-no">1960</span><span id="line-1960">      return;</span>
<span class="source-line-no">1961</span><span id="line-1961">    }</span>
<span class="source-line-no">1962</span><span id="line-1962">  }</span>
<span class="source-line-no">1963</span><span id="line-1963"></span>
<span class="source-line-no">1964</span><span id="line-1964">  private void updateStoreOnExec(RootProcedureState&lt;TEnvironment&gt; procStack,</span>
<span class="source-line-no">1965</span><span id="line-1965">    Procedure&lt;TEnvironment&gt; procedure, Procedure&lt;TEnvironment&gt;[] subprocs) {</span>
<span class="source-line-no">1966</span><span id="line-1966">    if (subprocs != null &amp;&amp; !procedure.isFailed()) {</span>
<span class="source-line-no">1967</span><span id="line-1967">      if (LOG.isTraceEnabled()) {</span>
<span class="source-line-no">1968</span><span id="line-1968">        LOG.trace("Stored " + procedure + ", children " + Arrays.toString(subprocs));</span>
<span class="source-line-no">1969</span><span id="line-1969">      }</span>
<span class="source-line-no">1970</span><span id="line-1970">      store.insert(procedure, subprocs);</span>
<span class="source-line-no">1971</span><span id="line-1971">    } else {</span>
<span class="source-line-no">1972</span><span id="line-1972">      LOG.trace("Store update {}", procedure);</span>
<span class="source-line-no">1973</span><span id="line-1973">      if (procedure.isFinished() &amp;&amp; !procedure.hasParent()) {</span>
<span class="source-line-no">1974</span><span id="line-1974">        // remove child procedures</span>
<span class="source-line-no">1975</span><span id="line-1975">        final long[] childProcIds = procStack.getSubprocedureIds();</span>
<span class="source-line-no">1976</span><span id="line-1976">        if (childProcIds != null) {</span>
<span class="source-line-no">1977</span><span id="line-1977">          store.delete(procedure, childProcIds);</span>
<span class="source-line-no">1978</span><span id="line-1978">          for (int i = 0; i &lt; childProcIds.length; ++i) {</span>
<span class="source-line-no">1979</span><span id="line-1979">            procedures.remove(childProcIds[i]);</span>
<span class="source-line-no">1980</span><span id="line-1980">          }</span>
<span class="source-line-no">1981</span><span id="line-1981">        } else {</span>
<span class="source-line-no">1982</span><span id="line-1982">          store.update(procedure);</span>
<span class="source-line-no">1983</span><span id="line-1983">        }</span>
<span class="source-line-no">1984</span><span id="line-1984">      } else {</span>
<span class="source-line-no">1985</span><span id="line-1985">        store.update(procedure);</span>
<span class="source-line-no">1986</span><span id="line-1986">      }</span>
<span class="source-line-no">1987</span><span id="line-1987">    }</span>
<span class="source-line-no">1988</span><span id="line-1988">  }</span>
<span class="source-line-no">1989</span><span id="line-1989"></span>
<span class="source-line-no">1990</span><span id="line-1990">  private void handleInterruptedException(Procedure&lt;TEnvironment&gt; proc, InterruptedException e) {</span>
<span class="source-line-no">1991</span><span id="line-1991">    LOG.trace("Interrupt during {}. suspend and retry it later.", proc, e);</span>
<span class="source-line-no">1992</span><span id="line-1992">    // NOTE: We don't call Thread.currentThread().interrupt()</span>
<span class="source-line-no">1993</span><span id="line-1993">    // because otherwise all the subsequent calls e.g. Thread.sleep() will throw</span>
<span class="source-line-no">1994</span><span id="line-1994">    // the InterruptedException. If the master is going down, we will be notified</span>
<span class="source-line-no">1995</span><span id="line-1995">    // and the executor/store will be stopped.</span>
<span class="source-line-no">1996</span><span id="line-1996">    // (The interrupted procedure will be retried on the next run)</span>
<span class="source-line-no">1997</span><span id="line-1997">  }</span>
<span class="source-line-no">1998</span><span id="line-1998"></span>
<span class="source-line-no">1999</span><span id="line-1999">  private void execCompletionCleanup(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">2000</span><span id="line-2000">    final TEnvironment env = getEnvironment();</span>
<span class="source-line-no">2001</span><span id="line-2001">    if (proc.hasLock()) {</span>
<span class="source-line-no">2002</span><span id="line-2002">      LOG.warn("Usually this should not happen, we will release the lock before if the procedure"</span>
<span class="source-line-no">2003</span><span id="line-2003">        + " is finished, even if the holdLock is true, arrive here means we have some holes where"</span>
<span class="source-line-no">2004</span><span id="line-2004">        + " we do not release the lock. And the releaseLock below may fail since the procedure may"</span>
<span class="source-line-no">2005</span><span id="line-2005">        + " have already been deleted from the procedure store.");</span>
<span class="source-line-no">2006</span><span id="line-2006">      releaseLock(proc, true);</span>
<span class="source-line-no">2007</span><span id="line-2007">    }</span>
<span class="source-line-no">2008</span><span id="line-2008">    try {</span>
<span class="source-line-no">2009</span><span id="line-2009">      proc.completionCleanup(env);</span>
<span class="source-line-no">2010</span><span id="line-2010">    } catch (Throwable e) {</span>
<span class="source-line-no">2011</span><span id="line-2011">      // Catch NullPointerExceptions or similar errors...</span>
<span class="source-line-no">2012</span><span id="line-2012">      LOG.error("CODE-BUG: uncatched runtime exception for procedure: " + proc, e);</span>
<span class="source-line-no">2013</span><span id="line-2013">    }</span>
<span class="source-line-no">2014</span><span id="line-2014">  }</span>
<span class="source-line-no">2015</span><span id="line-2015"></span>
<span class="source-line-no">2016</span><span id="line-2016">  private void procedureFinished(Procedure&lt;TEnvironment&gt; proc) {</span>
<span class="source-line-no">2017</span><span id="line-2017">    // call the procedure completion cleanup handler</span>
<span class="source-line-no">2018</span><span id="line-2018">    execCompletionCleanup(proc);</span>
<span class="source-line-no">2019</span><span id="line-2019"></span>
<span class="source-line-no">2020</span><span id="line-2020">    CompletedProcedureRetainer&lt;TEnvironment&gt; retainer = new CompletedProcedureRetainer&lt;&gt;(proc);</span>
<span class="source-line-no">2021</span><span id="line-2021"></span>
<span class="source-line-no">2022</span><span id="line-2022">    // update the executor internal state maps</span>
<span class="source-line-no">2023</span><span id="line-2023">    if (!proc.shouldWaitClientAck(getEnvironment())) {</span>
<span class="source-line-no">2024</span><span id="line-2024">      retainer.setClientAckTime(0);</span>
<span class="source-line-no">2025</span><span id="line-2025">    }</span>
<span class="source-line-no">2026</span><span id="line-2026"></span>
<span class="source-line-no">2027</span><span id="line-2027">    completed.put(proc.getProcId(), retainer);</span>
<span class="source-line-no">2028</span><span id="line-2028">    rollbackStack.remove(proc.getProcId());</span>
<span class="source-line-no">2029</span><span id="line-2029">    procedures.remove(proc.getProcId());</span>
<span class="source-line-no">2030</span><span id="line-2030"></span>
<span class="source-line-no">2031</span><span id="line-2031">    // call the runnableSet completion cleanup handler</span>
<span class="source-line-no">2032</span><span id="line-2032">    try {</span>
<span class="source-line-no">2033</span><span id="line-2033">      scheduler.completionCleanup(proc);</span>
<span class="source-line-no">2034</span><span id="line-2034">    } catch (Throwable e) {</span>
<span class="source-line-no">2035</span><span id="line-2035">      // Catch NullPointerExceptions or similar errors...</span>
<span class="source-line-no">2036</span><span id="line-2036">      LOG.error("CODE-BUG: uncatched runtime exception for completion cleanup: {}", proc, e);</span>
<span class="source-line-no">2037</span><span id="line-2037">    }</span>
<span class="source-line-no">2038</span><span id="line-2038"></span>
<span class="source-line-no">2039</span><span id="line-2039">    // Notify the listeners</span>
<span class="source-line-no">2040</span><span id="line-2040">    sendProcedureFinishedNotification(proc.getProcId());</span>
<span class="source-line-no">2041</span><span id="line-2041">  }</span>
<span class="source-line-no">2042</span><span id="line-2042"></span>
<span class="source-line-no">2043</span><span id="line-2043">  RootProcedureState&lt;TEnvironment&gt; getProcStack(long rootProcId) {</span>
<span class="source-line-no">2044</span><span id="line-2044">    return rollbackStack.get(rootProcId);</span>
<span class="source-line-no">2045</span><span id="line-2045">  }</span>
<span class="source-line-no">2046</span><span id="line-2046"></span>
<span class="source-line-no">2047</span><span id="line-2047">  ProcedureScheduler getProcedureScheduler() {</span>
<span class="source-line-no">2048</span><span id="line-2048">    return scheduler;</span>
<span class="source-line-no">2049</span><span id="line-2049">  }</span>
<span class="source-line-no">2050</span><span id="line-2050"></span>
<span class="source-line-no">2051</span><span id="line-2051">  int getCompletedSize() {</span>
<span class="source-line-no">2052</span><span id="line-2052">    return completed.size();</span>
<span class="source-line-no">2053</span><span id="line-2053">  }</span>
<span class="source-line-no">2054</span><span id="line-2054"></span>
<span class="source-line-no">2055</span><span id="line-2055">  public IdLock getProcExecutionLock() {</span>
<span class="source-line-no">2056</span><span id="line-2056">    return procExecutionLock;</span>
<span class="source-line-no">2057</span><span id="line-2057">  }</span>
<span class="source-line-no">2058</span><span id="line-2058"></span>
<span class="source-line-no">2059</span><span id="line-2059">  // ==========================================================================</span>
<span class="source-line-no">2060</span><span id="line-2060">  // Worker Thread</span>
<span class="source-line-no">2061</span><span id="line-2061">  // ==========================================================================</span>
<span class="source-line-no">2062</span><span id="line-2062">  private class WorkerThread extends StoppableThread {</span>
<span class="source-line-no">2063</span><span id="line-2063">    private final AtomicLong executionStartTime = new AtomicLong(Long.MAX_VALUE);</span>
<span class="source-line-no">2064</span><span id="line-2064">    private volatile Procedure&lt;TEnvironment&gt; activeProcedure;</span>
<span class="source-line-no">2065</span><span id="line-2065"></span>
<span class="source-line-no">2066</span><span id="line-2066">    public WorkerThread(ThreadGroup group) {</span>
<span class="source-line-no">2067</span><span id="line-2067">      this(group, "PEWorker-");</span>
<span class="source-line-no">2068</span><span id="line-2068">    }</span>
<span class="source-line-no">2069</span><span id="line-2069"></span>
<span class="source-line-no">2070</span><span id="line-2070">    protected WorkerThread(ThreadGroup group, String prefix) {</span>
<span class="source-line-no">2071</span><span id="line-2071">      super(group, prefix + workerId.incrementAndGet());</span>
<span class="source-line-no">2072</span><span id="line-2072">      setDaemon(true);</span>
<span class="source-line-no">2073</span><span id="line-2073">    }</span>
<span class="source-line-no">2074</span><span id="line-2074"></span>
<span class="source-line-no">2075</span><span id="line-2075">    @Override</span>
<span class="source-line-no">2076</span><span id="line-2076">    public void sendStopSignal() {</span>
<span class="source-line-no">2077</span><span id="line-2077">      scheduler.signalAll();</span>
<span class="source-line-no">2078</span><span id="line-2078">    }</span>
<span class="source-line-no">2079</span><span id="line-2079"></span>
<span class="source-line-no">2080</span><span id="line-2080">    /**</span>
<span class="source-line-no">2081</span><span id="line-2081">     * Encapsulates execution of the current {@link #activeProcedure} for easy tracing.</span>
<span class="source-line-no">2082</span><span id="line-2082">     */</span>
<span class="source-line-no">2083</span><span id="line-2083">    private long runProcedure() throws IOException {</span>
<span class="source-line-no">2084</span><span id="line-2084">      final Procedure&lt;TEnvironment&gt; proc = this.activeProcedure;</span>
<span class="source-line-no">2085</span><span id="line-2085">      int activeCount = activeExecutorCount.incrementAndGet();</span>
<span class="source-line-no">2086</span><span id="line-2086">      int runningCount = store.setRunningProcedureCount(activeCount);</span>
<span class="source-line-no">2087</span><span id="line-2087">      LOG.trace("Execute pid={} runningCount={}, activeCount={}", proc.getProcId(), runningCount,</span>
<span class="source-line-no">2088</span><span id="line-2088">        activeCount);</span>
<span class="source-line-no">2089</span><span id="line-2089">      executionStartTime.set(EnvironmentEdgeManager.currentTime());</span>
<span class="source-line-no">2090</span><span id="line-2090">      IdLock.Entry lockEntry = procExecutionLock.getLockEntry(proc.getProcId());</span>
<span class="source-line-no">2091</span><span id="line-2091">      try {</span>
<span class="source-line-no">2092</span><span id="line-2092">        executeProcedure(proc);</span>
<span class="source-line-no">2093</span><span id="line-2093">      } catch (AssertionError e) {</span>
<span class="source-line-no">2094</span><span id="line-2094">        LOG.info("ASSERT pid=" + proc.getProcId(), e);</span>
<span class="source-line-no">2095</span><span id="line-2095">        throw e;</span>
<span class="source-line-no">2096</span><span id="line-2096">      } finally {</span>
<span class="source-line-no">2097</span><span id="line-2097">        procExecutionLock.releaseLockEntry(lockEntry);</span>
<span class="source-line-no">2098</span><span id="line-2098">        activeCount = activeExecutorCount.decrementAndGet();</span>
<span class="source-line-no">2099</span><span id="line-2099">        runningCount = store.setRunningProcedureCount(activeCount);</span>
<span class="source-line-no">2100</span><span id="line-2100">        LOG.trace("Halt pid={} runningCount={}, activeCount={}", proc.getProcId(), runningCount,</span>
<span class="source-line-no">2101</span><span id="line-2101">          activeCount);</span>
<span class="source-line-no">2102</span><span id="line-2102">        this.activeProcedure = null;</span>
<span class="source-line-no">2103</span><span id="line-2103">        executionStartTime.set(Long.MAX_VALUE);</span>
<span class="source-line-no">2104</span><span id="line-2104">      }</span>
<span class="source-line-no">2105</span><span id="line-2105">      return EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2106</span><span id="line-2106">    }</span>
<span class="source-line-no">2107</span><span id="line-2107"></span>
<span class="source-line-no">2108</span><span id="line-2108">    @Override</span>
<span class="source-line-no">2109</span><span id="line-2109">    public void run() {</span>
<span class="source-line-no">2110</span><span id="line-2110">      long lastUpdate = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2111</span><span id="line-2111">      try {</span>
<span class="source-line-no">2112</span><span id="line-2112">        while (isRunning() &amp;&amp; keepAlive(lastUpdate)) {</span>
<span class="source-line-no">2113</span><span id="line-2113">          @SuppressWarnings("unchecked")</span>
<span class="source-line-no">2114</span><span id="line-2114">          Procedure&lt;TEnvironment&gt; proc = scheduler.poll(keepAliveTime, TimeUnit.MILLISECONDS);</span>
<span class="source-line-no">2115</span><span id="line-2115">          if (proc == null) {</span>
<span class="source-line-no">2116</span><span id="line-2116">            continue;</span>
<span class="source-line-no">2117</span><span id="line-2117">          }</span>
<span class="source-line-no">2118</span><span id="line-2118">          this.activeProcedure = proc;</span>
<span class="source-line-no">2119</span><span id="line-2119">          lastUpdate = TraceUtil.trace(this::runProcedure, new ProcedureSpanBuilder(proc));</span>
<span class="source-line-no">2120</span><span id="line-2120">        }</span>
<span class="source-line-no">2121</span><span id="line-2121">      } catch (Throwable t) {</span>
<span class="source-line-no">2122</span><span id="line-2122">        LOG.warn("Worker terminating UNNATURALLY {}", this.activeProcedure, t);</span>
<span class="source-line-no">2123</span><span id="line-2123">      } finally {</span>
<span class="source-line-no">2124</span><span id="line-2124">        LOG.trace("Worker terminated.");</span>
<span class="source-line-no">2125</span><span id="line-2125">      }</span>
<span class="source-line-no">2126</span><span id="line-2126">      workerThreads.remove(this);</span>
<span class="source-line-no">2127</span><span id="line-2127">    }</span>
<span class="source-line-no">2128</span><span id="line-2128"></span>
<span class="source-line-no">2129</span><span id="line-2129">    @Override</span>
<span class="source-line-no">2130</span><span id="line-2130">    public String toString() {</span>
<span class="source-line-no">2131</span><span id="line-2131">      Procedure&lt;?&gt; p = this.activeProcedure;</span>
<span class="source-line-no">2132</span><span id="line-2132">      return getName() + "(pid=" + (p == null ? Procedure.NO_PROC_ID : p.getProcId() + ")");</span>
<span class="source-line-no">2133</span><span id="line-2133">    }</span>
<span class="source-line-no">2134</span><span id="line-2134"></span>
<span class="source-line-no">2135</span><span id="line-2135">    /** Returns the time since the current procedure is running */</span>
<span class="source-line-no">2136</span><span id="line-2136">    public long getCurrentRunTime() {</span>
<span class="source-line-no">2137</span><span id="line-2137">      return EnvironmentEdgeManager.currentTime() - executionStartTime.get();</span>
<span class="source-line-no">2138</span><span id="line-2138">    }</span>
<span class="source-line-no">2139</span><span id="line-2139"></span>
<span class="source-line-no">2140</span><span id="line-2140">    // core worker never timeout</span>
<span class="source-line-no">2141</span><span id="line-2141">    protected boolean keepAlive(long lastUpdate) {</span>
<span class="source-line-no">2142</span><span id="line-2142">      return true;</span>
<span class="source-line-no">2143</span><span id="line-2143">    }</span>
<span class="source-line-no">2144</span><span id="line-2144">  }</span>
<span class="source-line-no">2145</span><span id="line-2145"></span>
<span class="source-line-no">2146</span><span id="line-2146">  // A worker thread which can be added when core workers are stuck. Will timeout after</span>
<span class="source-line-no">2147</span><span id="line-2147">  // keepAliveTime if there is no procedure to run.</span>
<span class="source-line-no">2148</span><span id="line-2148">  private final class KeepAliveWorkerThread extends WorkerThread {</span>
<span class="source-line-no">2149</span><span id="line-2149">    public KeepAliveWorkerThread(ThreadGroup group) {</span>
<span class="source-line-no">2150</span><span id="line-2150">      super(group, "KeepAlivePEWorker-");</span>
<span class="source-line-no">2151</span><span id="line-2151">    }</span>
<span class="source-line-no">2152</span><span id="line-2152"></span>
<span class="source-line-no">2153</span><span id="line-2153">    @Override</span>
<span class="source-line-no">2154</span><span id="line-2154">    protected boolean keepAlive(long lastUpdate) {</span>
<span class="source-line-no">2155</span><span id="line-2155">      return EnvironmentEdgeManager.currentTime() - lastUpdate &lt; keepAliveTime;</span>
<span class="source-line-no">2156</span><span id="line-2156">    }</span>
<span class="source-line-no">2157</span><span id="line-2157">  }</span>
<span class="source-line-no">2158</span><span id="line-2158"></span>
<span class="source-line-no">2159</span><span id="line-2159">  // ----------------------------------------------------------------------------</span>
<span class="source-line-no">2160</span><span id="line-2160">  // TODO-MAYBE: Should we provide a InlineChore to notify the store with the</span>
<span class="source-line-no">2161</span><span id="line-2161">  // full set of procedures pending and completed to write a compacted</span>
<span class="source-line-no">2162</span><span id="line-2162">  // version of the log (in case is a log)?</span>
<span class="source-line-no">2163</span><span id="line-2163">  // In theory no, procedures are have a short life, so at some point the store</span>
<span class="source-line-no">2164</span><span id="line-2164">  // will have the tracker saying everything is in the last log.</span>
<span class="source-line-no">2165</span><span id="line-2165">  // ----------------------------------------------------------------------------</span>
<span class="source-line-no">2166</span><span id="line-2166"></span>
<span class="source-line-no">2167</span><span id="line-2167">  private final class WorkerMonitor extends InlineChore {</span>
<span class="source-line-no">2168</span><span id="line-2168">    public static final String WORKER_MONITOR_INTERVAL_CONF_KEY =</span>
<span class="source-line-no">2169</span><span id="line-2169">      "hbase.procedure.worker.monitor.interval.msec";</span>
<span class="source-line-no">2170</span><span id="line-2170">    private static final int DEFAULT_WORKER_MONITOR_INTERVAL = 5000; // 5sec</span>
<span class="source-line-no">2171</span><span id="line-2171"></span>
<span class="source-line-no">2172</span><span id="line-2172">    public static final String WORKER_STUCK_THRESHOLD_CONF_KEY =</span>
<span class="source-line-no">2173</span><span id="line-2173">      "hbase.procedure.worker.stuck.threshold.msec";</span>
<span class="source-line-no">2174</span><span id="line-2174">    private static final int DEFAULT_WORKER_STUCK_THRESHOLD = 10000; // 10sec</span>
<span class="source-line-no">2175</span><span id="line-2175"></span>
<span class="source-line-no">2176</span><span id="line-2176">    public static final String WORKER_ADD_STUCK_PERCENTAGE_CONF_KEY =</span>
<span class="source-line-no">2177</span><span id="line-2177">      "hbase.procedure.worker.add.stuck.percentage";</span>
<span class="source-line-no">2178</span><span id="line-2178">    private static final float DEFAULT_WORKER_ADD_STUCK_PERCENTAGE = 0.5f; // 50% stuck</span>
<span class="source-line-no">2179</span><span id="line-2179"></span>
<span class="source-line-no">2180</span><span id="line-2180">    private float addWorkerStuckPercentage = DEFAULT_WORKER_ADD_STUCK_PERCENTAGE;</span>
<span class="source-line-no">2181</span><span id="line-2181">    private int timeoutInterval = DEFAULT_WORKER_MONITOR_INTERVAL;</span>
<span class="source-line-no">2182</span><span id="line-2182">    private int stuckThreshold = DEFAULT_WORKER_STUCK_THRESHOLD;</span>
<span class="source-line-no">2183</span><span id="line-2183"></span>
<span class="source-line-no">2184</span><span id="line-2184">    public WorkerMonitor() {</span>
<span class="source-line-no">2185</span><span id="line-2185">      refreshConfig();</span>
<span class="source-line-no">2186</span><span id="line-2186">    }</span>
<span class="source-line-no">2187</span><span id="line-2187"></span>
<span class="source-line-no">2188</span><span id="line-2188">    @Override</span>
<span class="source-line-no">2189</span><span id="line-2189">    public void run() {</span>
<span class="source-line-no">2190</span><span id="line-2190">      final int stuckCount = checkForStuckWorkers();</span>
<span class="source-line-no">2191</span><span id="line-2191">      checkThreadCount(stuckCount);</span>
<span class="source-line-no">2192</span><span id="line-2192"></span>
<span class="source-line-no">2193</span><span id="line-2193">      // refresh interval (poor man dynamic conf update)</span>
<span class="source-line-no">2194</span><span id="line-2194">      refreshConfig();</span>
<span class="source-line-no">2195</span><span id="line-2195">    }</span>
<span class="source-line-no">2196</span><span id="line-2196"></span>
<span class="source-line-no">2197</span><span id="line-2197">    private int checkForStuckWorkers() {</span>
<span class="source-line-no">2198</span><span id="line-2198">      // check if any of the worker is stuck</span>
<span class="source-line-no">2199</span><span id="line-2199">      int stuckCount = 0;</span>
<span class="source-line-no">2200</span><span id="line-2200">      for (WorkerThread worker : workerThreads) {</span>
<span class="source-line-no">2201</span><span id="line-2201">        if (worker.getCurrentRunTime() &lt; stuckThreshold) {</span>
<span class="source-line-no">2202</span><span id="line-2202">          continue;</span>
<span class="source-line-no">2203</span><span id="line-2203">        }</span>
<span class="source-line-no">2204</span><span id="line-2204"></span>
<span class="source-line-no">2205</span><span id="line-2205">        // WARN the worker is stuck</span>
<span class="source-line-no">2206</span><span id="line-2206">        stuckCount++;</span>
<span class="source-line-no">2207</span><span id="line-2207">        LOG.warn("Worker stuck {}, run time {}", worker,</span>
<span class="source-line-no">2208</span><span id="line-2208">          StringUtils.humanTimeDiff(worker.getCurrentRunTime()));</span>
<span class="source-line-no">2209</span><span id="line-2209">      }</span>
<span class="source-line-no">2210</span><span id="line-2210">      return stuckCount;</span>
<span class="source-line-no">2211</span><span id="line-2211">    }</span>
<span class="source-line-no">2212</span><span id="line-2212"></span>
<span class="source-line-no">2213</span><span id="line-2213">    private void checkThreadCount(final int stuckCount) {</span>
<span class="source-line-no">2214</span><span id="line-2214">      // nothing to do if there are no runnable tasks</span>
<span class="source-line-no">2215</span><span id="line-2215">      if (stuckCount &lt; 1 || !scheduler.hasRunnables()) {</span>
<span class="source-line-no">2216</span><span id="line-2216">        return;</span>
<span class="source-line-no">2217</span><span id="line-2217">      }</span>
<span class="source-line-no">2218</span><span id="line-2218"></span>
<span class="source-line-no">2219</span><span id="line-2219">      // add a new thread if the worker stuck percentage exceed the threshold limit</span>
<span class="source-line-no">2220</span><span id="line-2220">      // and every handler is active.</span>
<span class="source-line-no">2221</span><span id="line-2221">      final float stuckPerc = ((float) stuckCount) / workerThreads.size();</span>
<span class="source-line-no">2222</span><span id="line-2222">      // let's add new worker thread more aggressively, as they will timeout finally if there is no</span>
<span class="source-line-no">2223</span><span id="line-2223">      // work to do.</span>
<span class="source-line-no">2224</span><span id="line-2224">      if (stuckPerc &gt;= addWorkerStuckPercentage &amp;&amp; workerThreads.size() &lt; maxPoolSize) {</span>
<span class="source-line-no">2225</span><span id="line-2225">        final KeepAliveWorkerThread worker = new KeepAliveWorkerThread(threadGroup);</span>
<span class="source-line-no">2226</span><span id="line-2226">        workerThreads.add(worker);</span>
<span class="source-line-no">2227</span><span id="line-2227">        worker.start();</span>
<span class="source-line-no">2228</span><span id="line-2228">        LOG.debug("Added new worker thread {}", worker);</span>
<span class="source-line-no">2229</span><span id="line-2229">      }</span>
<span class="source-line-no">2230</span><span id="line-2230">    }</span>
<span class="source-line-no">2231</span><span id="line-2231"></span>
<span class="source-line-no">2232</span><span id="line-2232">    private void refreshConfig() {</span>
<span class="source-line-no">2233</span><span id="line-2233">      addWorkerStuckPercentage =</span>
<span class="source-line-no">2234</span><span id="line-2234">        conf.getFloat(WORKER_ADD_STUCK_PERCENTAGE_CONF_KEY, DEFAULT_WORKER_ADD_STUCK_PERCENTAGE);</span>
<span class="source-line-no">2235</span><span id="line-2235">      timeoutInterval =</span>
<span class="source-line-no">2236</span><span id="line-2236">        conf.getInt(WORKER_MONITOR_INTERVAL_CONF_KEY, DEFAULT_WORKER_MONITOR_INTERVAL);</span>
<span class="source-line-no">2237</span><span id="line-2237">      stuckThreshold = conf.getInt(WORKER_STUCK_THRESHOLD_CONF_KEY, DEFAULT_WORKER_STUCK_THRESHOLD);</span>
<span class="source-line-no">2238</span><span id="line-2238">    }</span>
<span class="source-line-no">2239</span><span id="line-2239"></span>
<span class="source-line-no">2240</span><span id="line-2240">    @Override</span>
<span class="source-line-no">2241</span><span id="line-2241">    public int getTimeoutInterval() {</span>
<span class="source-line-no">2242</span><span id="line-2242">      return timeoutInterval;</span>
<span class="source-line-no">2243</span><span id="line-2243">    }</span>
<span class="source-line-no">2244</span><span id="line-2244">  }</span>
<span class="source-line-no">2245</span><span id="line-2245">}</span>




























































</pre>
</div>
</main>
</body>
</html>

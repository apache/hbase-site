<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: org.apache.hadoop.hbase.regionserver, class: HRegionServer, class: CompactionChecker">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="source-line-no">003</span><span id="line-3"> * or more contributor license agreements.  See the NOTICE file</span>
<span class="source-line-no">004</span><span id="line-4"> * distributed with this work for additional information</span>
<span class="source-line-no">005</span><span id="line-5"> * regarding copyright ownership.  The ASF licenses this file</span>
<span class="source-line-no">006</span><span id="line-6"> * to you under the Apache License, Version 2.0 (the</span>
<span class="source-line-no">007</span><span id="line-7"> * "License"); you may not use this file except in compliance</span>
<span class="source-line-no">008</span><span id="line-8"> * with the License.  You may obtain a copy of the License at</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">011</span><span id="line-11"> *</span>
<span class="source-line-no">012</span><span id="line-12"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">013</span><span id="line-13"> * distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">014</span><span id="line-14"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">015</span><span id="line-15"> * See the License for the specific language governing permissions and</span>
<span class="source-line-no">016</span><span id="line-16"> * limitations under the License.</span>
<span class="source-line-no">017</span><span id="line-17"> */</span>
<span class="source-line-no">018</span><span id="line-18">package org.apache.hadoop.hbase.regionserver;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import static org.apache.hadoop.hbase.HConstants.DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK;</span>
<span class="source-line-no">021</span><span id="line-21">import static org.apache.hadoop.hbase.HConstants.DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER;</span>
<span class="source-line-no">022</span><span id="line-22">import static org.apache.hadoop.hbase.HConstants.DEFAULT_SLOW_LOG_SYS_TABLE_CHORE_DURATION;</span>
<span class="source-line-no">023</span><span id="line-23">import static org.apache.hadoop.hbase.HConstants.HBASE_SPLIT_WAL_COORDINATED_BY_ZK;</span>
<span class="source-line-no">024</span><span id="line-24">import static org.apache.hadoop.hbase.HConstants.HBASE_SPLIT_WAL_MAX_SPLITTER;</span>
<span class="source-line-no">025</span><span id="line-25">import static org.apache.hadoop.hbase.master.waleventtracker.WALEventTrackerTableCreator.WAL_EVENT_TRACKER_ENABLED_DEFAULT;</span>
<span class="source-line-no">026</span><span id="line-26">import static org.apache.hadoop.hbase.master.waleventtracker.WALEventTrackerTableCreator.WAL_EVENT_TRACKER_ENABLED_KEY;</span>
<span class="source-line-no">027</span><span id="line-27">import static org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore.NAMED_QUEUE_CHORE_DURATION_DEFAULT;</span>
<span class="source-line-no">028</span><span id="line-28">import static org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore.NAMED_QUEUE_CHORE_DURATION_KEY;</span>
<span class="source-line-no">029</span><span id="line-29">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_CHORE_DURATION_DEFAULT;</span>
<span class="source-line-no">030</span><span id="line-30">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_CHORE_DURATION_KEY;</span>
<span class="source-line-no">031</span><span id="line-31">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_ENABLED_DEFAULT;</span>
<span class="source-line-no">032</span><span id="line-32">import static org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore.REPLICATION_MARKER_ENABLED_KEY;</span>
<span class="source-line-no">033</span><span id="line-33">import static org.apache.hadoop.hbase.util.DNS.UNSAFE_RS_HOSTNAME_KEY;</span>
<span class="source-line-no">034</span><span id="line-34"></span>
<span class="source-line-no">035</span><span id="line-35">import io.opentelemetry.api.trace.Span;</span>
<span class="source-line-no">036</span><span id="line-36">import io.opentelemetry.api.trace.StatusCode;</span>
<span class="source-line-no">037</span><span id="line-37">import io.opentelemetry.context.Scope;</span>
<span class="source-line-no">038</span><span id="line-38">import java.io.IOException;</span>
<span class="source-line-no">039</span><span id="line-39">import java.io.PrintWriter;</span>
<span class="source-line-no">040</span><span id="line-40">import java.lang.management.MemoryUsage;</span>
<span class="source-line-no">041</span><span id="line-41">import java.lang.reflect.Constructor;</span>
<span class="source-line-no">042</span><span id="line-42">import java.net.InetSocketAddress;</span>
<span class="source-line-no">043</span><span id="line-43">import java.time.Duration;</span>
<span class="source-line-no">044</span><span id="line-44">import java.util.ArrayList;</span>
<span class="source-line-no">045</span><span id="line-45">import java.util.Collection;</span>
<span class="source-line-no">046</span><span id="line-46">import java.util.Collections;</span>
<span class="source-line-no">047</span><span id="line-47">import java.util.Comparator;</span>
<span class="source-line-no">048</span><span id="line-48">import java.util.HashSet;</span>
<span class="source-line-no">049</span><span id="line-49">import java.util.Iterator;</span>
<span class="source-line-no">050</span><span id="line-50">import java.util.List;</span>
<span class="source-line-no">051</span><span id="line-51">import java.util.Map;</span>
<span class="source-line-no">052</span><span id="line-52">import java.util.Map.Entry;</span>
<span class="source-line-no">053</span><span id="line-53">import java.util.Objects;</span>
<span class="source-line-no">054</span><span id="line-54">import java.util.Optional;</span>
<span class="source-line-no">055</span><span id="line-55">import java.util.Set;</span>
<span class="source-line-no">056</span><span id="line-56">import java.util.SortedMap;</span>
<span class="source-line-no">057</span><span id="line-57">import java.util.Timer;</span>
<span class="source-line-no">058</span><span id="line-58">import java.util.TimerTask;</span>
<span class="source-line-no">059</span><span id="line-59">import java.util.TreeMap;</span>
<span class="source-line-no">060</span><span id="line-60">import java.util.TreeSet;</span>
<span class="source-line-no">061</span><span id="line-61">import java.util.concurrent.ConcurrentHashMap;</span>
<span class="source-line-no">062</span><span id="line-62">import java.util.concurrent.ConcurrentMap;</span>
<span class="source-line-no">063</span><span id="line-63">import java.util.concurrent.ConcurrentSkipListMap;</span>
<span class="source-line-no">064</span><span id="line-64">import java.util.concurrent.ThreadLocalRandom;</span>
<span class="source-line-no">065</span><span id="line-65">import java.util.concurrent.TimeUnit;</span>
<span class="source-line-no">066</span><span id="line-66">import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="source-line-no">067</span><span id="line-67">import java.util.concurrent.locks.ReentrantReadWriteLock;</span>
<span class="source-line-no">068</span><span id="line-68">import java.util.function.Consumer;</span>
<span class="source-line-no">069</span><span id="line-69">import java.util.stream.Collectors;</span>
<span class="source-line-no">070</span><span id="line-70">import javax.management.MalformedObjectNameException;</span>
<span class="source-line-no">071</span><span id="line-71">import javax.servlet.http.HttpServlet;</span>
<span class="source-line-no">072</span><span id="line-72">import org.apache.commons.lang3.StringUtils;</span>
<span class="source-line-no">073</span><span id="line-73">import org.apache.commons.lang3.mutable.MutableFloat;</span>
<span class="source-line-no">074</span><span id="line-74">import org.apache.hadoop.conf.Configuration;</span>
<span class="source-line-no">075</span><span id="line-75">import org.apache.hadoop.fs.FileSystem;</span>
<span class="source-line-no">076</span><span id="line-76">import org.apache.hadoop.fs.Path;</span>
<span class="source-line-no">077</span><span id="line-77">import org.apache.hadoop.hbase.Abortable;</span>
<span class="source-line-no">078</span><span id="line-78">import org.apache.hadoop.hbase.CacheEvictionStats;</span>
<span class="source-line-no">079</span><span id="line-79">import org.apache.hadoop.hbase.CallQueueTooBigException;</span>
<span class="source-line-no">080</span><span id="line-80">import org.apache.hadoop.hbase.ClockOutOfSyncException;</span>
<span class="source-line-no">081</span><span id="line-81">import org.apache.hadoop.hbase.DoNotRetryIOException;</span>
<span class="source-line-no">082</span><span id="line-82">import org.apache.hadoop.hbase.ExecutorStatusChore;</span>
<span class="source-line-no">083</span><span id="line-83">import org.apache.hadoop.hbase.HBaseConfiguration;</span>
<span class="source-line-no">084</span><span id="line-84">import org.apache.hadoop.hbase.HBaseInterfaceAudience;</span>
<span class="source-line-no">085</span><span id="line-85">import org.apache.hadoop.hbase.HBaseServerBase;</span>
<span class="source-line-no">086</span><span id="line-86">import org.apache.hadoop.hbase.HConstants;</span>
<span class="source-line-no">087</span><span id="line-87">import org.apache.hadoop.hbase.HDFSBlocksDistribution;</span>
<span class="source-line-no">088</span><span id="line-88">import org.apache.hadoop.hbase.HRegionLocation;</span>
<span class="source-line-no">089</span><span id="line-89">import org.apache.hadoop.hbase.HealthCheckChore;</span>
<span class="source-line-no">090</span><span id="line-90">import org.apache.hadoop.hbase.MetaTableAccessor;</span>
<span class="source-line-no">091</span><span id="line-91">import org.apache.hadoop.hbase.NotServingRegionException;</span>
<span class="source-line-no">092</span><span id="line-92">import org.apache.hadoop.hbase.PleaseHoldException;</span>
<span class="source-line-no">093</span><span id="line-93">import org.apache.hadoop.hbase.ScheduledChore;</span>
<span class="source-line-no">094</span><span id="line-94">import org.apache.hadoop.hbase.ServerName;</span>
<span class="source-line-no">095</span><span id="line-95">import org.apache.hadoop.hbase.Stoppable;</span>
<span class="source-line-no">096</span><span id="line-96">import org.apache.hadoop.hbase.TableName;</span>
<span class="source-line-no">097</span><span id="line-97">import org.apache.hadoop.hbase.YouAreDeadException;</span>
<span class="source-line-no">098</span><span id="line-98">import org.apache.hadoop.hbase.ZNodeClearer;</span>
<span class="source-line-no">099</span><span id="line-99">import org.apache.hadoop.hbase.client.ConnectionUtils;</span>
<span class="source-line-no">100</span><span id="line-100">import org.apache.hadoop.hbase.client.RegionInfo;</span>
<span class="source-line-no">101</span><span id="line-101">import org.apache.hadoop.hbase.client.RegionInfoBuilder;</span>
<span class="source-line-no">102</span><span id="line-102">import org.apache.hadoop.hbase.client.locking.EntityLock;</span>
<span class="source-line-no">103</span><span id="line-103">import org.apache.hadoop.hbase.client.locking.LockServiceClient;</span>
<span class="source-line-no">104</span><span id="line-104">import org.apache.hadoop.hbase.conf.ConfigurationObserver;</span>
<span class="source-line-no">105</span><span id="line-105">import org.apache.hadoop.hbase.coprocessor.CoprocessorHost;</span>
<span class="source-line-no">106</span><span id="line-106">import org.apache.hadoop.hbase.exceptions.RegionMovedException;</span>
<span class="source-line-no">107</span><span id="line-107">import org.apache.hadoop.hbase.exceptions.RegionOpeningException;</span>
<span class="source-line-no">108</span><span id="line-108">import org.apache.hadoop.hbase.exceptions.UnknownProtocolException;</span>
<span class="source-line-no">109</span><span id="line-109">import org.apache.hadoop.hbase.executor.ExecutorType;</span>
<span class="source-line-no">110</span><span id="line-110">import org.apache.hadoop.hbase.http.InfoServer;</span>
<span class="source-line-no">111</span><span id="line-111">import org.apache.hadoop.hbase.io.hfile.BlockCache;</span>
<span class="source-line-no">112</span><span id="line-112">import org.apache.hadoop.hbase.io.hfile.BlockCacheFactory;</span>
<span class="source-line-no">113</span><span id="line-113">import org.apache.hadoop.hbase.io.hfile.CombinedBlockCache;</span>
<span class="source-line-no">114</span><span id="line-114">import org.apache.hadoop.hbase.io.hfile.HFile;</span>
<span class="source-line-no">115</span><span id="line-115">import org.apache.hadoop.hbase.io.hfile.bucket.BucketCache;</span>
<span class="source-line-no">116</span><span id="line-116">import org.apache.hadoop.hbase.io.util.MemorySizeUtil;</span>
<span class="source-line-no">117</span><span id="line-117">import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;</span>
<span class="source-line-no">118</span><span id="line-118">import org.apache.hadoop.hbase.ipc.DecommissionedHostRejectedException;</span>
<span class="source-line-no">119</span><span id="line-119">import org.apache.hadoop.hbase.ipc.RpcClient;</span>
<span class="source-line-no">120</span><span id="line-120">import org.apache.hadoop.hbase.ipc.RpcServer;</span>
<span class="source-line-no">121</span><span id="line-121">import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;</span>
<span class="source-line-no">122</span><span id="line-122">import org.apache.hadoop.hbase.ipc.ServerRpcController;</span>
<span class="source-line-no">123</span><span id="line-123">import org.apache.hadoop.hbase.log.HBaseMarkers;</span>
<span class="source-line-no">124</span><span id="line-124">import org.apache.hadoop.hbase.mob.MobFileCache;</span>
<span class="source-line-no">125</span><span id="line-125">import org.apache.hadoop.hbase.mob.RSMobFileCleanerChore;</span>
<span class="source-line-no">126</span><span id="line-126">import org.apache.hadoop.hbase.monitoring.TaskMonitor;</span>
<span class="source-line-no">127</span><span id="line-127">import org.apache.hadoop.hbase.namequeues.NamedQueueRecorder;</span>
<span class="source-line-no">128</span><span id="line-128">import org.apache.hadoop.hbase.namequeues.NamedQueueServiceChore;</span>
<span class="source-line-no">129</span><span id="line-129">import org.apache.hadoop.hbase.net.Address;</span>
<span class="source-line-no">130</span><span id="line-130">import org.apache.hadoop.hbase.procedure.RegionServerProcedureManagerHost;</span>
<span class="source-line-no">131</span><span id="line-131">import org.apache.hadoop.hbase.procedure2.RSProcedureCallable;</span>
<span class="source-line-no">132</span><span id="line-132">import org.apache.hadoop.hbase.quotas.FileSystemUtilizationChore;</span>
<span class="source-line-no">133</span><span id="line-133">import org.apache.hadoop.hbase.quotas.QuotaUtil;</span>
<span class="source-line-no">134</span><span id="line-134">import org.apache.hadoop.hbase.quotas.RegionServerRpcQuotaManager;</span>
<span class="source-line-no">135</span><span id="line-135">import org.apache.hadoop.hbase.quotas.RegionServerSpaceQuotaManager;</span>
<span class="source-line-no">136</span><span id="line-136">import org.apache.hadoop.hbase.quotas.RegionSize;</span>
<span class="source-line-no">137</span><span id="line-137">import org.apache.hadoop.hbase.quotas.RegionSizeStore;</span>
<span class="source-line-no">138</span><span id="line-138">import org.apache.hadoop.hbase.regionserver.compactions.CompactionConfiguration;</span>
<span class="source-line-no">139</span><span id="line-139">import org.apache.hadoop.hbase.regionserver.compactions.CompactionLifeCycleTracker;</span>
<span class="source-line-no">140</span><span id="line-140">import org.apache.hadoop.hbase.regionserver.compactions.CompactionProgress;</span>
<span class="source-line-no">141</span><span id="line-141">import org.apache.hadoop.hbase.regionserver.compactions.CompactionRequester;</span>
<span class="source-line-no">142</span><span id="line-142">import org.apache.hadoop.hbase.regionserver.handler.CloseMetaHandler;</span>
<span class="source-line-no">143</span><span id="line-143">import org.apache.hadoop.hbase.regionserver.handler.CloseRegionHandler;</span>
<span class="source-line-no">144</span><span id="line-144">import org.apache.hadoop.hbase.regionserver.handler.RSProcedureHandler;</span>
<span class="source-line-no">145</span><span id="line-145">import org.apache.hadoop.hbase.regionserver.handler.RegionReplicaFlushHandler;</span>
<span class="source-line-no">146</span><span id="line-146">import org.apache.hadoop.hbase.regionserver.http.RSDumpServlet;</span>
<span class="source-line-no">147</span><span id="line-147">import org.apache.hadoop.hbase.regionserver.http.RSStatusServlet;</span>
<span class="source-line-no">148</span><span id="line-148">import org.apache.hadoop.hbase.regionserver.regionreplication.RegionReplicationBufferManager;</span>
<span class="source-line-no">149</span><span id="line-149">import org.apache.hadoop.hbase.regionserver.throttle.FlushThroughputControllerFactory;</span>
<span class="source-line-no">150</span><span id="line-150">import org.apache.hadoop.hbase.regionserver.throttle.ThroughputController;</span>
<span class="source-line-no">151</span><span id="line-151">import org.apache.hadoop.hbase.regionserver.wal.WALActionsListener;</span>
<span class="source-line-no">152</span><span id="line-152">import org.apache.hadoop.hbase.regionserver.wal.WALEventTrackerListener;</span>
<span class="source-line-no">153</span><span id="line-153">import org.apache.hadoop.hbase.replication.regionserver.ReplicationLoad;</span>
<span class="source-line-no">154</span><span id="line-154">import org.apache.hadoop.hbase.replication.regionserver.ReplicationMarkerChore;</span>
<span class="source-line-no">155</span><span id="line-155">import org.apache.hadoop.hbase.replication.regionserver.ReplicationSourceInterface;</span>
<span class="source-line-no">156</span><span id="line-156">import org.apache.hadoop.hbase.replication.regionserver.ReplicationStatus;</span>
<span class="source-line-no">157</span><span id="line-157">import org.apache.hadoop.hbase.security.SecurityConstants;</span>
<span class="source-line-no">158</span><span id="line-158">import org.apache.hadoop.hbase.security.Superusers;</span>
<span class="source-line-no">159</span><span id="line-159">import org.apache.hadoop.hbase.security.User;</span>
<span class="source-line-no">160</span><span id="line-160">import org.apache.hadoop.hbase.security.UserProvider;</span>
<span class="source-line-no">161</span><span id="line-161">import org.apache.hadoop.hbase.trace.TraceUtil;</span>
<span class="source-line-no">162</span><span id="line-162">import org.apache.hadoop.hbase.util.Bytes;</span>
<span class="source-line-no">163</span><span id="line-163">import org.apache.hadoop.hbase.util.CompressionTest;</span>
<span class="source-line-no">164</span><span id="line-164">import org.apache.hadoop.hbase.util.CoprocessorConfigurationUtil;</span>
<span class="source-line-no">165</span><span id="line-165">import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;</span>
<span class="source-line-no">166</span><span id="line-166">import org.apache.hadoop.hbase.util.FSUtils;</span>
<span class="source-line-no">167</span><span id="line-167">import org.apache.hadoop.hbase.util.FutureUtils;</span>
<span class="source-line-no">168</span><span id="line-168">import org.apache.hadoop.hbase.util.JvmPauseMonitor;</span>
<span class="source-line-no">169</span><span id="line-169">import org.apache.hadoop.hbase.util.Pair;</span>
<span class="source-line-no">170</span><span id="line-170">import org.apache.hadoop.hbase.util.RetryCounter;</span>
<span class="source-line-no">171</span><span id="line-171">import org.apache.hadoop.hbase.util.RetryCounterFactory;</span>
<span class="source-line-no">172</span><span id="line-172">import org.apache.hadoop.hbase.util.ServerRegionReplicaUtil;</span>
<span class="source-line-no">173</span><span id="line-173">import org.apache.hadoop.hbase.util.Threads;</span>
<span class="source-line-no">174</span><span id="line-174">import org.apache.hadoop.hbase.util.VersionInfo;</span>
<span class="source-line-no">175</span><span id="line-175">import org.apache.hadoop.hbase.wal.AbstractFSWALProvider;</span>
<span class="source-line-no">176</span><span id="line-176">import org.apache.hadoop.hbase.wal.WAL;</span>
<span class="source-line-no">177</span><span id="line-177">import org.apache.hadoop.hbase.wal.WALFactory;</span>
<span class="source-line-no">178</span><span id="line-178">import org.apache.hadoop.hbase.zookeeper.MasterAddressTracker;</span>
<span class="source-line-no">179</span><span id="line-179">import org.apache.hadoop.hbase.zookeeper.ZKClusterId;</span>
<span class="source-line-no">180</span><span id="line-180">import org.apache.hadoop.hbase.zookeeper.ZKNodeTracker;</span>
<span class="source-line-no">181</span><span id="line-181">import org.apache.hadoop.hbase.zookeeper.ZKUtil;</span>
<span class="source-line-no">182</span><span id="line-182">import org.apache.hadoop.ipc.RemoteException;</span>
<span class="source-line-no">183</span><span id="line-183">import org.apache.hadoop.util.ReflectionUtils;</span>
<span class="source-line-no">184</span><span id="line-184">import org.apache.yetus.audience.InterfaceAudience;</span>
<span class="source-line-no">185</span><span id="line-185">import org.apache.zookeeper.KeeperException;</span>
<span class="source-line-no">186</span><span id="line-186">import org.slf4j.Logger;</span>
<span class="source-line-no">187</span><span id="line-187">import org.slf4j.LoggerFactory;</span>
<span class="source-line-no">188</span><span id="line-188"></span>
<span class="source-line-no">189</span><span id="line-189">import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;</span>
<span class="source-line-no">190</span><span id="line-190">import org.apache.hbase.thirdparty.com.google.common.base.Throwables;</span>
<span class="source-line-no">191</span><span id="line-191">import org.apache.hbase.thirdparty.com.google.common.cache.Cache;</span>
<span class="source-line-no">192</span><span id="line-192">import org.apache.hbase.thirdparty.com.google.common.cache.CacheBuilder;</span>
<span class="source-line-no">193</span><span id="line-193">import org.apache.hbase.thirdparty.com.google.common.collect.Maps;</span>
<span class="source-line-no">194</span><span id="line-194">import org.apache.hbase.thirdparty.com.google.common.net.InetAddresses;</span>
<span class="source-line-no">195</span><span id="line-195">import org.apache.hbase.thirdparty.com.google.protobuf.BlockingRpcChannel;</span>
<span class="source-line-no">196</span><span id="line-196">import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors.MethodDescriptor;</span>
<span class="source-line-no">197</span><span id="line-197">import org.apache.hbase.thirdparty.com.google.protobuf.Descriptors.ServiceDescriptor;</span>
<span class="source-line-no">198</span><span id="line-198">import org.apache.hbase.thirdparty.com.google.protobuf.Message;</span>
<span class="source-line-no">199</span><span id="line-199">import org.apache.hbase.thirdparty.com.google.protobuf.RpcController;</span>
<span class="source-line-no">200</span><span id="line-200">import org.apache.hbase.thirdparty.com.google.protobuf.Service;</span>
<span class="source-line-no">201</span><span id="line-201">import org.apache.hbase.thirdparty.com.google.protobuf.ServiceException;</span>
<span class="source-line-no">202</span><span id="line-202">import org.apache.hbase.thirdparty.com.google.protobuf.TextFormat;</span>
<span class="source-line-no">203</span><span id="line-203">import org.apache.hbase.thirdparty.com.google.protobuf.UnsafeByteOperations;</span>
<span class="source-line-no">204</span><span id="line-204"></span>
<span class="source-line-no">205</span><span id="line-205">import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;</span>
<span class="source-line-no">206</span><span id="line-206">import org.apache.hadoop.hbase.shaded.protobuf.RequestConverter;</span>
<span class="source-line-no">207</span><span id="line-207">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceCall;</span>
<span class="source-line-no">208</span><span id="line-208">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceRequest;</span>
<span class="source-line-no">209</span><span id="line-209">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClientProtos.CoprocessorServiceResponse;</span>
<span class="source-line-no">210</span><span id="line-210">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos;</span>
<span class="source-line-no">211</span><span id="line-211">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.RegionLoad;</span>
<span class="source-line-no">212</span><span id="line-212">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.RegionStoreSequenceIds;</span>
<span class="source-line-no">213</span><span id="line-213">import org.apache.hadoop.hbase.shaded.protobuf.generated.ClusterStatusProtos.UserLoad;</span>
<span class="source-line-no">214</span><span id="line-214">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.Coprocessor;</span>
<span class="source-line-no">215</span><span id="line-215">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.NameStringPair;</span>
<span class="source-line-no">216</span><span id="line-216">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionServerInfo;</span>
<span class="source-line-no">217</span><span id="line-217">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier;</span>
<span class="source-line-no">218</span><span id="line-218">import org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.RegionSpecifier.RegionSpecifierType;</span>
<span class="source-line-no">219</span><span id="line-219">import org.apache.hadoop.hbase.shaded.protobuf.generated.LockServiceProtos.LockService;</span>
<span class="source-line-no">220</span><span id="line-220">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos;</span>
<span class="source-line-no">221</span><span id="line-221">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.GetLastFlushedSequenceIdRequest;</span>
<span class="source-line-no">222</span><span id="line-222">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.GetLastFlushedSequenceIdResponse;</span>
<span class="source-line-no">223</span><span id="line-223">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerReportRequest;</span>
<span class="source-line-no">224</span><span id="line-224">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStartupRequest;</span>
<span class="source-line-no">225</span><span id="line-225">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStartupResponse;</span>
<span class="source-line-no">226</span><span id="line-226">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionServerStatusService;</span>
<span class="source-line-no">227</span><span id="line-227">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionSpaceUse;</span>
<span class="source-line-no">228</span><span id="line-228">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionSpaceUseReportRequest;</span>
<span class="source-line-no">229</span><span id="line-229">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionStateTransition;</span>
<span class="source-line-no">230</span><span id="line-230">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.RegionStateTransition.TransitionCode;</span>
<span class="source-line-no">231</span><span id="line-231">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportProcedureDoneRequest;</span>
<span class="source-line-no">232</span><span id="line-232">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRSFatalErrorRequest;</span>
<span class="source-line-no">233</span><span id="line-233">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRegionStateTransitionRequest;</span>
<span class="source-line-no">234</span><span id="line-234">import org.apache.hadoop.hbase.shaded.protobuf.generated.RegionServerStatusProtos.ReportRegionStateTransitionResponse;</span>
<span class="source-line-no">235</span><span id="line-235"></span>
<span class="source-line-no">236</span><span id="line-236">/**</span>
<span class="source-line-no">237</span><span id="line-237"> * HRegionServer makes a set of HRegions available to clients. It checks in with the HMaster. There</span>
<span class="source-line-no">238</span><span id="line-238"> * are many HRegionServers in a single HBase deployment.</span>
<span class="source-line-no">239</span><span id="line-239"> */</span>
<span class="source-line-no">240</span><span id="line-240">@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.TOOLS)</span>
<span class="source-line-no">241</span><span id="line-241">@SuppressWarnings({ "deprecation" })</span>
<span class="source-line-no">242</span><span id="line-242">public class HRegionServer extends HBaseServerBase&lt;RSRpcServices&gt;</span>
<span class="source-line-no">243</span><span id="line-243">  implements RegionServerServices, LastSequenceId {</span>
<span class="source-line-no">244</span><span id="line-244"></span>
<span class="source-line-no">245</span><span id="line-245">  private static final Logger LOG = LoggerFactory.getLogger(HRegionServer.class);</span>
<span class="source-line-no">246</span><span id="line-246"></span>
<span class="source-line-no">247</span><span id="line-247">  int unitMB = 1024 * 1024;</span>
<span class="source-line-no">248</span><span id="line-248">  int unitKB = 1024;</span>
<span class="source-line-no">249</span><span id="line-249"></span>
<span class="source-line-no">250</span><span id="line-250">  /**</span>
<span class="source-line-no">251</span><span id="line-251">   * For testing only! Set to true to skip notifying region assignment to master .</span>
<span class="source-line-no">252</span><span id="line-252">   */</span>
<span class="source-line-no">253</span><span id="line-253">  @InterfaceAudience.Private</span>
<span class="source-line-no">254</span><span id="line-254">  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "MS_SHOULD_BE_FINAL")</span>
<span class="source-line-no">255</span><span id="line-255">  public static boolean TEST_SKIP_REPORTING_TRANSITION = false;</span>
<span class="source-line-no">256</span><span id="line-256"></span>
<span class="source-line-no">257</span><span id="line-257">  /**</span>
<span class="source-line-no">258</span><span id="line-258">   * A map from RegionName to current action in progress. Boolean value indicates: true - if open</span>
<span class="source-line-no">259</span><span id="line-259">   * region action in progress false - if close region action in progress</span>
<span class="source-line-no">260</span><span id="line-260">   */</span>
<span class="source-line-no">261</span><span id="line-261">  private final ConcurrentMap&lt;byte[], Boolean&gt; regionsInTransitionInRS =</span>
<span class="source-line-no">262</span><span id="line-262">    new ConcurrentSkipListMap&lt;&gt;(Bytes.BYTES_COMPARATOR);</span>
<span class="source-line-no">263</span><span id="line-263"></span>
<span class="source-line-no">264</span><span id="line-264">  /**</span>
<span class="source-line-no">265</span><span id="line-265">   * Used to cache the open/close region procedures which already submitted. See</span>
<span class="source-line-no">266</span><span id="line-266">   * {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">267</span><span id="line-267">   */</span>
<span class="source-line-no">268</span><span id="line-268">  private final ConcurrentMap&lt;Long, Long&gt; submittedRegionProcedures = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">269</span><span id="line-269">  /**</span>
<span class="source-line-no">270</span><span id="line-270">   * Used to cache the open/close region procedures which already executed. See</span>
<span class="source-line-no">271</span><span id="line-271">   * {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">272</span><span id="line-272">   */</span>
<span class="source-line-no">273</span><span id="line-273">  private final Cache&lt;Long, Long&gt; executedRegionProcedures =</span>
<span class="source-line-no">274</span><span id="line-274">    CacheBuilder.newBuilder().expireAfterAccess(600, TimeUnit.SECONDS).build();</span>
<span class="source-line-no">275</span><span id="line-275"></span>
<span class="source-line-no">276</span><span id="line-276">  /**</span>
<span class="source-line-no">277</span><span id="line-277">   * Used to cache the moved-out regions</span>
<span class="source-line-no">278</span><span id="line-278">   */</span>
<span class="source-line-no">279</span><span id="line-279">  private final Cache&lt;String, MovedRegionInfo&gt; movedRegionInfoCache = CacheBuilder.newBuilder()</span>
<span class="source-line-no">280</span><span id="line-280">    .expireAfterWrite(movedRegionCacheExpiredTime(), TimeUnit.MILLISECONDS).build();</span>
<span class="source-line-no">281</span><span id="line-281"></span>
<span class="source-line-no">282</span><span id="line-282">  private MemStoreFlusher cacheFlusher;</span>
<span class="source-line-no">283</span><span id="line-283"></span>
<span class="source-line-no">284</span><span id="line-284">  private HeapMemoryManager hMemManager;</span>
<span class="source-line-no">285</span><span id="line-285"></span>
<span class="source-line-no">286</span><span id="line-286">  // Replication services. If no replication, this handler will be null.</span>
<span class="source-line-no">287</span><span id="line-287">  private ReplicationSourceService replicationSourceHandler;</span>
<span class="source-line-no">288</span><span id="line-288">  private ReplicationSinkService replicationSinkHandler;</span>
<span class="source-line-no">289</span><span id="line-289">  private boolean sameReplicationSourceAndSink;</span>
<span class="source-line-no">290</span><span id="line-290"></span>
<span class="source-line-no">291</span><span id="line-291">  // Compactions</span>
<span class="source-line-no">292</span><span id="line-292">  private CompactSplit compactSplitThread;</span>
<span class="source-line-no">293</span><span id="line-293"></span>
<span class="source-line-no">294</span><span id="line-294">  /**</span>
<span class="source-line-no">295</span><span id="line-295">   * Map of regions currently being served by this region server. Key is the encoded region name.</span>
<span class="source-line-no">296</span><span id="line-296">   * All access should be synchronized.</span>
<span class="source-line-no">297</span><span id="line-297">   */</span>
<span class="source-line-no">298</span><span id="line-298">  private final Map&lt;String, HRegion&gt; onlineRegions = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">299</span><span id="line-299">  /**</span>
<span class="source-line-no">300</span><span id="line-300">   * Lock for gating access to {@link #onlineRegions}. TODO: If this map is gated by a lock, does it</span>
<span class="source-line-no">301</span><span id="line-301">   * need to be a ConcurrentHashMap?</span>
<span class="source-line-no">302</span><span id="line-302">   */</span>
<span class="source-line-no">303</span><span id="line-303">  private final ReentrantReadWriteLock onlineRegionsLock = new ReentrantReadWriteLock();</span>
<span class="source-line-no">304</span><span id="line-304"></span>
<span class="source-line-no">305</span><span id="line-305">  /**</span>
<span class="source-line-no">306</span><span id="line-306">   * Map of encoded region names to the DataNode locations they should be hosted on We store the</span>
<span class="source-line-no">307</span><span id="line-307">   * value as Address since InetSocketAddress is required by the HDFS API (create() that takes</span>
<span class="source-line-no">308</span><span id="line-308">   * favored nodes as hints for placing file blocks). We could have used ServerName here as the</span>
<span class="source-line-no">309</span><span id="line-309">   * value class, but we'd need to convert it to InetSocketAddress at some point before the HDFS API</span>
<span class="source-line-no">310</span><span id="line-310">   * call, and it seems a bit weird to store ServerName since ServerName refers to RegionServers and</span>
<span class="source-line-no">311</span><span id="line-311">   * here we really mean DataNode locations. We don't store it as InetSocketAddress here because the</span>
<span class="source-line-no">312</span><span id="line-312">   * conversion on demand from Address to InetSocketAddress will guarantee the resolution results</span>
<span class="source-line-no">313</span><span id="line-313">   * will be fresh when we need it.</span>
<span class="source-line-no">314</span><span id="line-314">   */</span>
<span class="source-line-no">315</span><span id="line-315">  private final Map&lt;String, Address[]&gt; regionFavoredNodesMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="source-line-no">316</span><span id="line-316"></span>
<span class="source-line-no">317</span><span id="line-317">  private LeaseManager leaseManager;</span>
<span class="source-line-no">318</span><span id="line-318"></span>
<span class="source-line-no">319</span><span id="line-319">  private volatile boolean dataFsOk;</span>
<span class="source-line-no">320</span><span id="line-320"></span>
<span class="source-line-no">321</span><span id="line-321">  static final String ABORT_TIMEOUT = "hbase.regionserver.abort.timeout";</span>
<span class="source-line-no">322</span><span id="line-322">  // Default abort timeout is 1200 seconds for safe</span>
<span class="source-line-no">323</span><span id="line-323">  private static final long DEFAULT_ABORT_TIMEOUT = 1200000;</span>
<span class="source-line-no">324</span><span id="line-324">  // Will run this task when abort timeout</span>
<span class="source-line-no">325</span><span id="line-325">  static final String ABORT_TIMEOUT_TASK = "hbase.regionserver.abort.timeout.task";</span>
<span class="source-line-no">326</span><span id="line-326"></span>
<span class="source-line-no">327</span><span id="line-327">  // A state before we go into stopped state. At this stage we're closing user</span>
<span class="source-line-no">328</span><span id="line-328">  // space regions.</span>
<span class="source-line-no">329</span><span id="line-329">  private boolean stopping = false;</span>
<span class="source-line-no">330</span><span id="line-330">  private volatile boolean killed = false;</span>
<span class="source-line-no">331</span><span id="line-331"></span>
<span class="source-line-no">332</span><span id="line-332">  private final int threadWakeFrequency;</span>
<span class="source-line-no">333</span><span id="line-333"></span>
<span class="source-line-no">334</span><span id="line-334">  private static final String PERIOD_COMPACTION = "hbase.regionserver.compaction.check.period";</span>
<span class="source-line-no">335</span><span id="line-335">  private final int compactionCheckFrequency;</span>
<span class="source-line-no">336</span><span id="line-336">  private static final String PERIOD_FLUSH = "hbase.regionserver.flush.check.period";</span>
<span class="source-line-no">337</span><span id="line-337">  private final int flushCheckFrequency;</span>
<span class="source-line-no">338</span><span id="line-338"></span>
<span class="source-line-no">339</span><span id="line-339">  // Stub to do region server status calls against the master.</span>
<span class="source-line-no">340</span><span id="line-340">  private volatile RegionServerStatusService.BlockingInterface rssStub;</span>
<span class="source-line-no">341</span><span id="line-341">  private volatile LockService.BlockingInterface lockStub;</span>
<span class="source-line-no">342</span><span id="line-342">  // RPC client. Used to make the stub above that does region server status checking.</span>
<span class="source-line-no">343</span><span id="line-343">  private RpcClient rpcClient;</span>
<span class="source-line-no">344</span><span id="line-344"></span>
<span class="source-line-no">345</span><span id="line-345">  private UncaughtExceptionHandler uncaughtExceptionHandler;</span>
<span class="source-line-no">346</span><span id="line-346"></span>
<span class="source-line-no">347</span><span id="line-347">  private JvmPauseMonitor pauseMonitor;</span>
<span class="source-line-no">348</span><span id="line-348"></span>
<span class="source-line-no">349</span><span id="line-349">  private RSSnapshotVerifier rsSnapshotVerifier;</span>
<span class="source-line-no">350</span><span id="line-350"></span>
<span class="source-line-no">351</span><span id="line-351">  /** region server process name */</span>
<span class="source-line-no">352</span><span id="line-352">  public static final String REGIONSERVER = "regionserver";</span>
<span class="source-line-no">353</span><span id="line-353"></span>
<span class="source-line-no">354</span><span id="line-354">  private MetricsRegionServer metricsRegionServer;</span>
<span class="source-line-no">355</span><span id="line-355">  MetricsRegionServerWrapperImpl metricsRegionServerImpl;</span>
<span class="source-line-no">356</span><span id="line-356"></span>
<span class="source-line-no">357</span><span id="line-357">  /**</span>
<span class="source-line-no">358</span><span id="line-358">   * Check for compactions requests.</span>
<span class="source-line-no">359</span><span id="line-359">   */</span>
<span class="source-line-no">360</span><span id="line-360">  private ScheduledChore compactionChecker;</span>
<span class="source-line-no">361</span><span id="line-361"></span>
<span class="source-line-no">362</span><span id="line-362">  /**</span>
<span class="source-line-no">363</span><span id="line-363">   * Check for flushes</span>
<span class="source-line-no">364</span><span id="line-364">   */</span>
<span class="source-line-no">365</span><span id="line-365">  private ScheduledChore periodicFlusher;</span>
<span class="source-line-no">366</span><span id="line-366"></span>
<span class="source-line-no">367</span><span id="line-367">  private volatile WALFactory walFactory;</span>
<span class="source-line-no">368</span><span id="line-368"></span>
<span class="source-line-no">369</span><span id="line-369">  private LogRoller walRoller;</span>
<span class="source-line-no">370</span><span id="line-370"></span>
<span class="source-line-no">371</span><span id="line-371">  // A thread which calls reportProcedureDone</span>
<span class="source-line-no">372</span><span id="line-372">  private RemoteProcedureResultReporter procedureResultReporter;</span>
<span class="source-line-no">373</span><span id="line-373"></span>
<span class="source-line-no">374</span><span id="line-374">  // flag set after we're done setting up server threads</span>
<span class="source-line-no">375</span><span id="line-375">  final AtomicBoolean online = new AtomicBoolean(false);</span>
<span class="source-line-no">376</span><span id="line-376"></span>
<span class="source-line-no">377</span><span id="line-377">  // master address tracker</span>
<span class="source-line-no">378</span><span id="line-378">  private final MasterAddressTracker masterAddressTracker;</span>
<span class="source-line-no">379</span><span id="line-379"></span>
<span class="source-line-no">380</span><span id="line-380">  // Log Splitting Worker</span>
<span class="source-line-no">381</span><span id="line-381">  private SplitLogWorker splitLogWorker;</span>
<span class="source-line-no">382</span><span id="line-382"></span>
<span class="source-line-no">383</span><span id="line-383">  private final int shortOperationTimeout;</span>
<span class="source-line-no">384</span><span id="line-384"></span>
<span class="source-line-no">385</span><span id="line-385">  // Time to pause if master says 'please hold'</span>
<span class="source-line-no">386</span><span id="line-386">  private final long retryPauseTime;</span>
<span class="source-line-no">387</span><span id="line-387"></span>
<span class="source-line-no">388</span><span id="line-388">  private final RegionServerAccounting regionServerAccounting;</span>
<span class="source-line-no">389</span><span id="line-389"></span>
<span class="source-line-no">390</span><span id="line-390">  private NamedQueueServiceChore namedQueueServiceChore = null;</span>
<span class="source-line-no">391</span><span id="line-391"></span>
<span class="source-line-no">392</span><span id="line-392">  // Block cache</span>
<span class="source-line-no">393</span><span id="line-393">  private BlockCache blockCache;</span>
<span class="source-line-no">394</span><span id="line-394">  // The cache for mob files</span>
<span class="source-line-no">395</span><span id="line-395">  private MobFileCache mobFileCache;</span>
<span class="source-line-no">396</span><span id="line-396"></span>
<span class="source-line-no">397</span><span id="line-397">  /** The health check chore. */</span>
<span class="source-line-no">398</span><span id="line-398">  private HealthCheckChore healthCheckChore;</span>
<span class="source-line-no">399</span><span id="line-399"></span>
<span class="source-line-no">400</span><span id="line-400">  /** The Executor status collect chore. */</span>
<span class="source-line-no">401</span><span id="line-401">  private ExecutorStatusChore executorStatusChore;</span>
<span class="source-line-no">402</span><span id="line-402"></span>
<span class="source-line-no">403</span><span id="line-403">  /** The nonce manager chore. */</span>
<span class="source-line-no">404</span><span id="line-404">  private ScheduledChore nonceManagerChore;</span>
<span class="source-line-no">405</span><span id="line-405"></span>
<span class="source-line-no">406</span><span id="line-406">  private Map&lt;String, Service&gt; coprocessorServiceHandlers = Maps.newHashMap();</span>
<span class="source-line-no">407</span><span id="line-407"></span>
<span class="source-line-no">408</span><span id="line-408">  /**</span>
<span class="source-line-no">409</span><span id="line-409">   * @deprecated since 2.4.0 and will be removed in 4.0.0. Use</span>
<span class="source-line-no">410</span><span id="line-410">   *             {@link HRegionServer#UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY} instead.</span>
<span class="source-line-no">411</span><span id="line-411">   * @see &lt;a href="https://issues.apache.org/jira/browse/HBASE-24667"&gt;HBASE-24667&lt;/a&gt;</span>
<span class="source-line-no">412</span><span id="line-412">   */</span>
<span class="source-line-no">413</span><span id="line-413">  @Deprecated</span>
<span class="source-line-no">414</span><span id="line-414">  @InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.CONFIG)</span>
<span class="source-line-no">415</span><span id="line-415">  final static String RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY =</span>
<span class="source-line-no">416</span><span id="line-416">    "hbase.regionserver.hostname.disable.master.reversedns";</span>
<span class="source-line-no">417</span><span id="line-417"></span>
<span class="source-line-no">418</span><span id="line-418">  /**</span>
<span class="source-line-no">419</span><span id="line-419">   * HBASE-18226: This config and hbase.unsafe.regionserver.hostname are mutually exclusive.</span>
<span class="source-line-no">420</span><span id="line-420">   * Exception will be thrown if both are used.</span>
<span class="source-line-no">421</span><span id="line-421">   */</span>
<span class="source-line-no">422</span><span id="line-422">  @InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.CONFIG)</span>
<span class="source-line-no">423</span><span id="line-423">  final static String UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY =</span>
<span class="source-line-no">424</span><span id="line-424">    "hbase.unsafe.regionserver.hostname.disable.master.reversedns";</span>
<span class="source-line-no">425</span><span id="line-425"></span>
<span class="source-line-no">426</span><span id="line-426">  /**</span>
<span class="source-line-no">427</span><span id="line-427">   * Unique identifier for the cluster we are a part of.</span>
<span class="source-line-no">428</span><span id="line-428">   */</span>
<span class="source-line-no">429</span><span id="line-429">  private String clusterId;</span>
<span class="source-line-no">430</span><span id="line-430"></span>
<span class="source-line-no">431</span><span id="line-431">  // chore for refreshing store files for secondary regions</span>
<span class="source-line-no">432</span><span id="line-432">  private StorefileRefresherChore storefileRefresher;</span>
<span class="source-line-no">433</span><span id="line-433"></span>
<span class="source-line-no">434</span><span id="line-434">  private volatile RegionServerCoprocessorHost rsHost;</span>
<span class="source-line-no">435</span><span id="line-435"></span>
<span class="source-line-no">436</span><span id="line-436">  private RegionServerProcedureManagerHost rspmHost;</span>
<span class="source-line-no">437</span><span id="line-437"></span>
<span class="source-line-no">438</span><span id="line-438">  private RegionServerRpcQuotaManager rsQuotaManager;</span>
<span class="source-line-no">439</span><span id="line-439">  private RegionServerSpaceQuotaManager rsSpaceQuotaManager;</span>
<span class="source-line-no">440</span><span id="line-440"></span>
<span class="source-line-no">441</span><span id="line-441">  /**</span>
<span class="source-line-no">442</span><span id="line-442">   * Nonce manager. Nonces are used to make operations like increment and append idempotent in the</span>
<span class="source-line-no">443</span><span id="line-443">   * case where client doesn't receive the response from a successful operation and retries. We</span>
<span class="source-line-no">444</span><span id="line-444">   * track the successful ops for some time via a nonce sent by client and handle duplicate</span>
<span class="source-line-no">445</span><span id="line-445">   * operations (currently, by failing them; in future we might use MVCC to return result). Nonces</span>
<span class="source-line-no">446</span><span id="line-446">   * are also recovered from WAL during, recovery; however, the caveats (from HBASE-3787) are: - WAL</span>
<span class="source-line-no">447</span><span id="line-447">   * recovery is optimized, and under high load we won't read nearly nonce-timeout worth of past</span>
<span class="source-line-no">448</span><span id="line-448">   * records. If we don't read the records, we don't read and recover the nonces. Some WALs within</span>
<span class="source-line-no">449</span><span id="line-449">   * nonce-timeout at recovery may not even be present due to rolling/cleanup. - There's no WAL</span>
<span class="source-line-no">450</span><span id="line-450">   * recovery during normal region move, so nonces will not be transfered. We can have separate</span>
<span class="source-line-no">451</span><span id="line-451">   * additional "Nonce WAL". It will just contain bunch of numbers and won't be flushed on main path</span>
<span class="source-line-no">452</span><span id="line-452">   * - because WAL itself also contains nonces, if we only flush it before memstore flush, for a</span>
<span class="source-line-no">453</span><span id="line-453">   * given nonce we will either see it in the WAL (if it was never flushed to disk, it will be part</span>
<span class="source-line-no">454</span><span id="line-454">   * of recovery), or we'll see it as part of the nonce log (or both occasionally, which doesn't</span>
<span class="source-line-no">455</span><span id="line-455">   * matter). Nonce log file can be deleted after the latest nonce in it expired. It can also be</span>
<span class="source-line-no">456</span><span id="line-456">   * recovered during move.</span>
<span class="source-line-no">457</span><span id="line-457">   */</span>
<span class="source-line-no">458</span><span id="line-458">  final ServerNonceManager nonceManager;</span>
<span class="source-line-no">459</span><span id="line-459"></span>
<span class="source-line-no">460</span><span id="line-460">  private BrokenStoreFileCleaner brokenStoreFileCleaner;</span>
<span class="source-line-no">461</span><span id="line-461"></span>
<span class="source-line-no">462</span><span id="line-462">  private RSMobFileCleanerChore rsMobFileCleanerChore;</span>
<span class="source-line-no">463</span><span id="line-463"></span>
<span class="source-line-no">464</span><span id="line-464">  @InterfaceAudience.Private</span>
<span class="source-line-no">465</span><span id="line-465">  CompactedHFilesDischarger compactedFileDischarger;</span>
<span class="source-line-no">466</span><span id="line-466"></span>
<span class="source-line-no">467</span><span id="line-467">  private volatile ThroughputController flushThroughputController;</span>
<span class="source-line-no">468</span><span id="line-468"></span>
<span class="source-line-no">469</span><span id="line-469">  private SecureBulkLoadManager secureBulkLoadManager;</span>
<span class="source-line-no">470</span><span id="line-470"></span>
<span class="source-line-no">471</span><span id="line-471">  private FileSystemUtilizationChore fsUtilizationChore;</span>
<span class="source-line-no">472</span><span id="line-472"></span>
<span class="source-line-no">473</span><span id="line-473">  private BootstrapNodeManager bootstrapNodeManager;</span>
<span class="source-line-no">474</span><span id="line-474"></span>
<span class="source-line-no">475</span><span id="line-475">  /**</span>
<span class="source-line-no">476</span><span id="line-476">   * True if this RegionServer is coming up in a cluster where there is no Master; means it needs to</span>
<span class="source-line-no">477</span><span id="line-477">   * just come up and make do without a Master to talk to: e.g. in test or HRegionServer is doing</span>
<span class="source-line-no">478</span><span id="line-478">   * other than its usual duties: e.g. as an hollowed-out host whose only purpose is as a</span>
<span class="source-line-no">479</span><span id="line-479">   * Replication-stream sink; see HBASE-18846 for more. TODO: can this replace</span>
<span class="source-line-no">480</span><span id="line-480">   * {@link #TEST_SKIP_REPORTING_TRANSITION} ?</span>
<span class="source-line-no">481</span><span id="line-481">   */</span>
<span class="source-line-no">482</span><span id="line-482">  private final boolean masterless;</span>
<span class="source-line-no">483</span><span id="line-483">  private static final String MASTERLESS_CONFIG_NAME = "hbase.masterless";</span>
<span class="source-line-no">484</span><span id="line-484"></span>
<span class="source-line-no">485</span><span id="line-485">  /** regionserver codec list **/</span>
<span class="source-line-no">486</span><span id="line-486">  private static final String REGIONSERVER_CODEC = "hbase.regionserver.codecs";</span>
<span class="source-line-no">487</span><span id="line-487"></span>
<span class="source-line-no">488</span><span id="line-488">  // A timer to shutdown the process if abort takes too long</span>
<span class="source-line-no">489</span><span id="line-489">  private Timer abortMonitor;</span>
<span class="source-line-no">490</span><span id="line-490"></span>
<span class="source-line-no">491</span><span id="line-491">  private RegionReplicationBufferManager regionReplicationBufferManager;</span>
<span class="source-line-no">492</span><span id="line-492"></span>
<span class="source-line-no">493</span><span id="line-493">  /*</span>
<span class="source-line-no">494</span><span id="line-494">   * Chore that creates replication marker rows.</span>
<span class="source-line-no">495</span><span id="line-495">   */</span>
<span class="source-line-no">496</span><span id="line-496">  private ReplicationMarkerChore replicationMarkerChore;</span>
<span class="source-line-no">497</span><span id="line-497"></span>
<span class="source-line-no">498</span><span id="line-498">  // A timer submit requests to the PrefetchExecutor</span>
<span class="source-line-no">499</span><span id="line-499">  private PrefetchExecutorNotifier prefetchExecutorNotifier;</span>
<span class="source-line-no">500</span><span id="line-500"></span>
<span class="source-line-no">501</span><span id="line-501">  /**</span>
<span class="source-line-no">502</span><span id="line-502">   * Starts a HRegionServer at the default location.</span>
<span class="source-line-no">503</span><span id="line-503">   * &lt;p/&gt;</span>
<span class="source-line-no">504</span><span id="line-504">   * Don't start any services or managers in here in the Constructor. Defer till after we register</span>
<span class="source-line-no">505</span><span id="line-505">   * with the Master as much as possible. See {@link #startServices}.</span>
<span class="source-line-no">506</span><span id="line-506">   */</span>
<span class="source-line-no">507</span><span id="line-507">  public HRegionServer(final Configuration conf) throws IOException {</span>
<span class="source-line-no">508</span><span id="line-508">    super(conf, "RegionServer"); // thread name</span>
<span class="source-line-no">509</span><span id="line-509">    final Span span = TraceUtil.createSpan("HRegionServer.cxtor");</span>
<span class="source-line-no">510</span><span id="line-510">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">511</span><span id="line-511">      this.dataFsOk = true;</span>
<span class="source-line-no">512</span><span id="line-512">      this.masterless = !clusterMode();</span>
<span class="source-line-no">513</span><span id="line-513">      MemorySizeUtil.checkForClusterFreeHeapMemoryLimit(this.conf);</span>
<span class="source-line-no">514</span><span id="line-514">      HFile.checkHFileVersion(this.conf);</span>
<span class="source-line-no">515</span><span id="line-515">      checkCodecs(this.conf);</span>
<span class="source-line-no">516</span><span id="line-516">      FSUtils.setupShortCircuitRead(this.conf);</span>
<span class="source-line-no">517</span><span id="line-517"></span>
<span class="source-line-no">518</span><span id="line-518">      // Disable usage of meta replicas in the regionserver</span>
<span class="source-line-no">519</span><span id="line-519">      this.conf.setBoolean(HConstants.USE_META_REPLICAS, false);</span>
<span class="source-line-no">520</span><span id="line-520">      // Config'ed params</span>
<span class="source-line-no">521</span><span id="line-521">      this.threadWakeFrequency = conf.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000);</span>
<span class="source-line-no">522</span><span id="line-522">      this.compactionCheckFrequency = conf.getInt(PERIOD_COMPACTION, this.threadWakeFrequency);</span>
<span class="source-line-no">523</span><span id="line-523">      this.flushCheckFrequency = conf.getInt(PERIOD_FLUSH, this.threadWakeFrequency);</span>
<span class="source-line-no">524</span><span id="line-524"></span>
<span class="source-line-no">525</span><span id="line-525">      boolean isNoncesEnabled = conf.getBoolean(HConstants.HBASE_RS_NONCES_ENABLED, true);</span>
<span class="source-line-no">526</span><span id="line-526">      this.nonceManager = isNoncesEnabled ? new ServerNonceManager(this.conf) : null;</span>
<span class="source-line-no">527</span><span id="line-527"></span>
<span class="source-line-no">528</span><span id="line-528">      this.shortOperationTimeout = conf.getInt(HConstants.HBASE_RPC_SHORTOPERATION_TIMEOUT_KEY,</span>
<span class="source-line-no">529</span><span id="line-529">        HConstants.DEFAULT_HBASE_RPC_SHORTOPERATION_TIMEOUT);</span>
<span class="source-line-no">530</span><span id="line-530"></span>
<span class="source-line-no">531</span><span id="line-531">      this.retryPauseTime = conf.getLong(HConstants.HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME,</span>
<span class="source-line-no">532</span><span id="line-532">        HConstants.DEFAULT_HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME);</span>
<span class="source-line-no">533</span><span id="line-533"></span>
<span class="source-line-no">534</span><span id="line-534">      regionServerAccounting = new RegionServerAccounting(conf);</span>
<span class="source-line-no">535</span><span id="line-535"></span>
<span class="source-line-no">536</span><span id="line-536">      blockCache = BlockCacheFactory.createBlockCache(conf);</span>
<span class="source-line-no">537</span><span id="line-537">      mobFileCache = new MobFileCache(conf);</span>
<span class="source-line-no">538</span><span id="line-538"></span>
<span class="source-line-no">539</span><span id="line-539">      rsSnapshotVerifier = new RSSnapshotVerifier(conf);</span>
<span class="source-line-no">540</span><span id="line-540"></span>
<span class="source-line-no">541</span><span id="line-541">      uncaughtExceptionHandler =</span>
<span class="source-line-no">542</span><span id="line-542">        (t, e) -&gt; abort("Uncaught exception in executorService thread " + t.getName(), e);</span>
<span class="source-line-no">543</span><span id="line-543"></span>
<span class="source-line-no">544</span><span id="line-544">      // If no master in cluster, skip trying to track one or look for a cluster status.</span>
<span class="source-line-no">545</span><span id="line-545">      if (!this.masterless) {</span>
<span class="source-line-no">546</span><span id="line-546">        masterAddressTracker = new MasterAddressTracker(getZooKeeper(), this);</span>
<span class="source-line-no">547</span><span id="line-547">        masterAddressTracker.start();</span>
<span class="source-line-no">548</span><span id="line-548">      } else {</span>
<span class="source-line-no">549</span><span id="line-549">        masterAddressTracker = null;</span>
<span class="source-line-no">550</span><span id="line-550">      }</span>
<span class="source-line-no">551</span><span id="line-551">      this.rpcServices.start(zooKeeper);</span>
<span class="source-line-no">552</span><span id="line-552">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">553</span><span id="line-553">    } catch (Throwable t) {</span>
<span class="source-line-no">554</span><span id="line-554">      // Make sure we log the exception. HRegionServer is often started via reflection and the</span>
<span class="source-line-no">555</span><span id="line-555">      // cause of failed startup is lost.</span>
<span class="source-line-no">556</span><span id="line-556">      TraceUtil.setError(span, t);</span>
<span class="source-line-no">557</span><span id="line-557">      LOG.error("Failed construction RegionServer", t);</span>
<span class="source-line-no">558</span><span id="line-558">      throw t;</span>
<span class="source-line-no">559</span><span id="line-559">    } finally {</span>
<span class="source-line-no">560</span><span id="line-560">      span.end();</span>
<span class="source-line-no">561</span><span id="line-561">    }</span>
<span class="source-line-no">562</span><span id="line-562">  }</span>
<span class="source-line-no">563</span><span id="line-563"></span>
<span class="source-line-no">564</span><span id="line-564">  // HMaster should override this method to load the specific config for master</span>
<span class="source-line-no">565</span><span id="line-565">  @Override</span>
<span class="source-line-no">566</span><span id="line-566">  protected String getUseThisHostnameInstead(Configuration conf) throws IOException {</span>
<span class="source-line-no">567</span><span id="line-567">    String hostname = conf.get(UNSAFE_RS_HOSTNAME_KEY);</span>
<span class="source-line-no">568</span><span id="line-568">    if (conf.getBoolean(UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY, false)) {</span>
<span class="source-line-no">569</span><span id="line-569">      if (!StringUtils.isBlank(hostname)) {</span>
<span class="source-line-no">570</span><span id="line-570">        String msg = UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " and "</span>
<span class="source-line-no">571</span><span id="line-571">          + UNSAFE_RS_HOSTNAME_KEY + " are mutually exclusive. Do not set "</span>
<span class="source-line-no">572</span><span id="line-572">          + UNSAFE_RS_HOSTNAME_DISABLE_MASTER_REVERSEDNS_KEY + " to true while "</span>
<span class="source-line-no">573</span><span id="line-573">          + UNSAFE_RS_HOSTNAME_KEY + " is used";</span>
<span class="source-line-no">574</span><span id="line-574">        throw new IOException(msg);</span>
<span class="source-line-no">575</span><span id="line-575">      } else {</span>
<span class="source-line-no">576</span><span id="line-576">        return rpcServices.getSocketAddress().getHostName();</span>
<span class="source-line-no">577</span><span id="line-577">      }</span>
<span class="source-line-no">578</span><span id="line-578">    } else {</span>
<span class="source-line-no">579</span><span id="line-579">      return hostname;</span>
<span class="source-line-no">580</span><span id="line-580">    }</span>
<span class="source-line-no">581</span><span id="line-581">  }</span>
<span class="source-line-no">582</span><span id="line-582"></span>
<span class="source-line-no">583</span><span id="line-583">  @Override</span>
<span class="source-line-no">584</span><span id="line-584">  protected void login(UserProvider user, String host) throws IOException {</span>
<span class="source-line-no">585</span><span id="line-585">    user.login(SecurityConstants.REGIONSERVER_KRB_KEYTAB_FILE,</span>
<span class="source-line-no">586</span><span id="line-586">      SecurityConstants.REGIONSERVER_KRB_PRINCIPAL, host);</span>
<span class="source-line-no">587</span><span id="line-587">  }</span>
<span class="source-line-no">588</span><span id="line-588"></span>
<span class="source-line-no">589</span><span id="line-589">  @Override</span>
<span class="source-line-no">590</span><span id="line-590">  protected String getProcessName() {</span>
<span class="source-line-no">591</span><span id="line-591">    return REGIONSERVER;</span>
<span class="source-line-no">592</span><span id="line-592">  }</span>
<span class="source-line-no">593</span><span id="line-593"></span>
<span class="source-line-no">594</span><span id="line-594">  @Override</span>
<span class="source-line-no">595</span><span id="line-595">  protected RegionServerCoprocessorHost getCoprocessorHost() {</span>
<span class="source-line-no">596</span><span id="line-596">    return getRegionServerCoprocessorHost();</span>
<span class="source-line-no">597</span><span id="line-597">  }</span>
<span class="source-line-no">598</span><span id="line-598"></span>
<span class="source-line-no">599</span><span id="line-599">  @Override</span>
<span class="source-line-no">600</span><span id="line-600">  protected boolean canCreateBaseZNode() {</span>
<span class="source-line-no">601</span><span id="line-601">    return !clusterMode();</span>
<span class="source-line-no">602</span><span id="line-602">  }</span>
<span class="source-line-no">603</span><span id="line-603"></span>
<span class="source-line-no">604</span><span id="line-604">  @Override</span>
<span class="source-line-no">605</span><span id="line-605">  protected boolean canUpdateTableDescriptor() {</span>
<span class="source-line-no">606</span><span id="line-606">    return false;</span>
<span class="source-line-no">607</span><span id="line-607">  }</span>
<span class="source-line-no">608</span><span id="line-608"></span>
<span class="source-line-no">609</span><span id="line-609">  @Override</span>
<span class="source-line-no">610</span><span id="line-610">  protected boolean cacheTableDescriptor() {</span>
<span class="source-line-no">611</span><span id="line-611">    return false;</span>
<span class="source-line-no">612</span><span id="line-612">  }</span>
<span class="source-line-no">613</span><span id="line-613"></span>
<span class="source-line-no">614</span><span id="line-614">  protected RSRpcServices createRpcServices() throws IOException {</span>
<span class="source-line-no">615</span><span id="line-615">    return new RSRpcServices(this);</span>
<span class="source-line-no">616</span><span id="line-616">  }</span>
<span class="source-line-no">617</span><span id="line-617"></span>
<span class="source-line-no">618</span><span id="line-618">  @Override</span>
<span class="source-line-no">619</span><span id="line-619">  protected void configureInfoServer(InfoServer infoServer) {</span>
<span class="source-line-no">620</span><span id="line-620">    infoServer.addUnprivilegedServlet("rs-status", "/rs-status", RSStatusServlet.class);</span>
<span class="source-line-no">621</span><span id="line-621">    infoServer.setAttribute(REGIONSERVER, this);</span>
<span class="source-line-no">622</span><span id="line-622">  }</span>
<span class="source-line-no">623</span><span id="line-623"></span>
<span class="source-line-no">624</span><span id="line-624">  @Override</span>
<span class="source-line-no">625</span><span id="line-625">  protected Class&lt;? extends HttpServlet&gt; getDumpServlet() {</span>
<span class="source-line-no">626</span><span id="line-626">    return RSDumpServlet.class;</span>
<span class="source-line-no">627</span><span id="line-627">  }</span>
<span class="source-line-no">628</span><span id="line-628"></span>
<span class="source-line-no">629</span><span id="line-629">  /**</span>
<span class="source-line-no">630</span><span id="line-630">   * Used by {@link RSDumpServlet} to generate debugging information.</span>
<span class="source-line-no">631</span><span id="line-631">   */</span>
<span class="source-line-no">632</span><span id="line-632">  public void dumpRowLocks(final PrintWriter out) {</span>
<span class="source-line-no">633</span><span id="line-633">    StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">634</span><span id="line-634">    for (HRegion region : getRegions()) {</span>
<span class="source-line-no">635</span><span id="line-635">      if (region.getLockedRows().size() &gt; 0) {</span>
<span class="source-line-no">636</span><span id="line-636">        for (HRegion.RowLockContext rowLockContext : region.getLockedRows().values()) {</span>
<span class="source-line-no">637</span><span id="line-637">          sb.setLength(0);</span>
<span class="source-line-no">638</span><span id="line-638">          sb.append(region.getTableDescriptor().getTableName()).append(",")</span>
<span class="source-line-no">639</span><span id="line-639">            .append(region.getRegionInfo().getEncodedName()).append(",");</span>
<span class="source-line-no">640</span><span id="line-640">          sb.append(rowLockContext.toString());</span>
<span class="source-line-no">641</span><span id="line-641">          out.println(sb);</span>
<span class="source-line-no">642</span><span id="line-642">        }</span>
<span class="source-line-no">643</span><span id="line-643">      }</span>
<span class="source-line-no">644</span><span id="line-644">    }</span>
<span class="source-line-no">645</span><span id="line-645">  }</span>
<span class="source-line-no">646</span><span id="line-646"></span>
<span class="source-line-no">647</span><span id="line-647">  @Override</span>
<span class="source-line-no">648</span><span id="line-648">  public boolean registerService(Service instance) {</span>
<span class="source-line-no">649</span><span id="line-649">    // No stacking of instances is allowed for a single executorService name</span>
<span class="source-line-no">650</span><span id="line-650">    ServiceDescriptor serviceDesc = instance.getDescriptorForType();</span>
<span class="source-line-no">651</span><span id="line-651">    String serviceName = CoprocessorRpcUtils.getServiceName(serviceDesc);</span>
<span class="source-line-no">652</span><span id="line-652">    if (coprocessorServiceHandlers.containsKey(serviceName)) {</span>
<span class="source-line-no">653</span><span id="line-653">      LOG.error("Coprocessor executorService " + serviceName</span>
<span class="source-line-no">654</span><span id="line-654">        + " already registered, rejecting request from " + instance);</span>
<span class="source-line-no">655</span><span id="line-655">      return false;</span>
<span class="source-line-no">656</span><span id="line-656">    }</span>
<span class="source-line-no">657</span><span id="line-657"></span>
<span class="source-line-no">658</span><span id="line-658">    coprocessorServiceHandlers.put(serviceName, instance);</span>
<span class="source-line-no">659</span><span id="line-659">    if (LOG.isDebugEnabled()) {</span>
<span class="source-line-no">660</span><span id="line-660">      LOG.debug(</span>
<span class="source-line-no">661</span><span id="line-661">        "Registered regionserver coprocessor executorService: executorService=" + serviceName);</span>
<span class="source-line-no">662</span><span id="line-662">    }</span>
<span class="source-line-no">663</span><span id="line-663">    return true;</span>
<span class="source-line-no">664</span><span id="line-664">  }</span>
<span class="source-line-no">665</span><span id="line-665"></span>
<span class="source-line-no">666</span><span id="line-666">  /**</span>
<span class="source-line-no">667</span><span id="line-667">   * Run test on configured codecs to make sure supporting libs are in place.</span>
<span class="source-line-no">668</span><span id="line-668">   */</span>
<span class="source-line-no">669</span><span id="line-669">  private static void checkCodecs(final Configuration c) throws IOException {</span>
<span class="source-line-no">670</span><span id="line-670">    // check to see if the codec list is available:</span>
<span class="source-line-no">671</span><span id="line-671">    String[] codecs = c.getStrings(REGIONSERVER_CODEC, (String[]) null);</span>
<span class="source-line-no">672</span><span id="line-672">    if (codecs == null) {</span>
<span class="source-line-no">673</span><span id="line-673">      return;</span>
<span class="source-line-no">674</span><span id="line-674">    }</span>
<span class="source-line-no">675</span><span id="line-675">    for (String codec : codecs) {</span>
<span class="source-line-no">676</span><span id="line-676">      if (!CompressionTest.testCompression(codec)) {</span>
<span class="source-line-no">677</span><span id="line-677">        throw new IOException(</span>
<span class="source-line-no">678</span><span id="line-678">          "Compression codec " + codec + " not supported, aborting RS construction");</span>
<span class="source-line-no">679</span><span id="line-679">      }</span>
<span class="source-line-no">680</span><span id="line-680">    }</span>
<span class="source-line-no">681</span><span id="line-681">  }</span>
<span class="source-line-no">682</span><span id="line-682"></span>
<span class="source-line-no">683</span><span id="line-683">  public String getClusterId() {</span>
<span class="source-line-no">684</span><span id="line-684">    return this.clusterId;</span>
<span class="source-line-no">685</span><span id="line-685">  }</span>
<span class="source-line-no">686</span><span id="line-686"></span>
<span class="source-line-no">687</span><span id="line-687">  /**</span>
<span class="source-line-no">688</span><span id="line-688">   * All initialization needed before we go register with Master.&lt;br&gt;</span>
<span class="source-line-no">689</span><span id="line-689">   * Do bare minimum. Do bulk of initializations AFTER we've connected to the Master.&lt;br&gt;</span>
<span class="source-line-no">690</span><span id="line-690">   * In here we just put up the RpcServer, setup Connection, and ZooKeeper.</span>
<span class="source-line-no">691</span><span id="line-691">   */</span>
<span class="source-line-no">692</span><span id="line-692">  private void preRegistrationInitialization() {</span>
<span class="source-line-no">693</span><span id="line-693">    final Span span = TraceUtil.createSpan("HRegionServer.preRegistrationInitialization");</span>
<span class="source-line-no">694</span><span id="line-694">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">695</span><span id="line-695">      initializeZooKeeper();</span>
<span class="source-line-no">696</span><span id="line-696">      setupClusterConnection();</span>
<span class="source-line-no">697</span><span id="line-697">      bootstrapNodeManager = new BootstrapNodeManager(asyncClusterConnection, masterAddressTracker);</span>
<span class="source-line-no">698</span><span id="line-698">      regionReplicationBufferManager = new RegionReplicationBufferManager(this);</span>
<span class="source-line-no">699</span><span id="line-699">      // Setup RPC client for master communication</span>
<span class="source-line-no">700</span><span id="line-700">      this.rpcClient = asyncClusterConnection.getRpcClient();</span>
<span class="source-line-no">701</span><span id="line-701">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">702</span><span id="line-702">    } catch (Throwable t) {</span>
<span class="source-line-no">703</span><span id="line-703">      // Call stop if error or process will stick around for ever since server</span>
<span class="source-line-no">704</span><span id="line-704">      // puts up non-daemon threads.</span>
<span class="source-line-no">705</span><span id="line-705">      TraceUtil.setError(span, t);</span>
<span class="source-line-no">706</span><span id="line-706">      this.rpcServices.stop();</span>
<span class="source-line-no">707</span><span id="line-707">      abort("Initialization of RS failed.  Hence aborting RS.", t);</span>
<span class="source-line-no">708</span><span id="line-708">    } finally {</span>
<span class="source-line-no">709</span><span id="line-709">      span.end();</span>
<span class="source-line-no">710</span><span id="line-710">    }</span>
<span class="source-line-no">711</span><span id="line-711">  }</span>
<span class="source-line-no">712</span><span id="line-712"></span>
<span class="source-line-no">713</span><span id="line-713">  /**</span>
<span class="source-line-no">714</span><span id="line-714">   * Bring up connection to zk ensemble and then wait until a master for this cluster and then after</span>
<span class="source-line-no">715</span><span id="line-715">   * that, wait until cluster 'up' flag has been set. This is the order in which master does things.</span>
<span class="source-line-no">716</span><span id="line-716">   * &lt;p&gt;</span>
<span class="source-line-no">717</span><span id="line-717">   * Finally open long-living server short-circuit connection.</span>
<span class="source-line-no">718</span><span id="line-718">   */</span>
<span class="source-line-no">719</span><span id="line-719">  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RV_RETURN_VALUE_IGNORED_BAD_PRACTICE",</span>
<span class="source-line-no">720</span><span id="line-720">      justification = "cluster Id znode read would give us correct response")</span>
<span class="source-line-no">721</span><span id="line-721">  private void initializeZooKeeper() throws IOException, InterruptedException {</span>
<span class="source-line-no">722</span><span id="line-722">    // Nothing to do in here if no Master in the mix.</span>
<span class="source-line-no">723</span><span id="line-723">    if (this.masterless) {</span>
<span class="source-line-no">724</span><span id="line-724">      return;</span>
<span class="source-line-no">725</span><span id="line-725">    }</span>
<span class="source-line-no">726</span><span id="line-726"></span>
<span class="source-line-no">727</span><span id="line-727">    // Create the master address tracker, register with zk, and start it. Then</span>
<span class="source-line-no">728</span><span id="line-728">    // block until a master is available. No point in starting up if no master</span>
<span class="source-line-no">729</span><span id="line-729">    // running.</span>
<span class="source-line-no">730</span><span id="line-730">    blockAndCheckIfStopped(this.masterAddressTracker);</span>
<span class="source-line-no">731</span><span id="line-731"></span>
<span class="source-line-no">732</span><span id="line-732">    // Wait on cluster being up. Master will set this flag up in zookeeper</span>
<span class="source-line-no">733</span><span id="line-733">    // when ready.</span>
<span class="source-line-no">734</span><span id="line-734">    blockAndCheckIfStopped(this.clusterStatusTracker);</span>
<span class="source-line-no">735</span><span id="line-735"></span>
<span class="source-line-no">736</span><span id="line-736">    // If we are HMaster then the cluster id should have already been set.</span>
<span class="source-line-no">737</span><span id="line-737">    if (clusterId == null) {</span>
<span class="source-line-no">738</span><span id="line-738">      // Retrieve clusterId</span>
<span class="source-line-no">739</span><span id="line-739">      // Since cluster status is now up</span>
<span class="source-line-no">740</span><span id="line-740">      // ID should have already been set by HMaster</span>
<span class="source-line-no">741</span><span id="line-741">      try {</span>
<span class="source-line-no">742</span><span id="line-742">        clusterId = ZKClusterId.readClusterIdZNode(this.zooKeeper);</span>
<span class="source-line-no">743</span><span id="line-743">        if (clusterId == null) {</span>
<span class="source-line-no">744</span><span id="line-744">          this.abort("Cluster ID has not been set");</span>
<span class="source-line-no">745</span><span id="line-745">        }</span>
<span class="source-line-no">746</span><span id="line-746">        LOG.info("ClusterId : " + clusterId);</span>
<span class="source-line-no">747</span><span id="line-747">      } catch (KeeperException e) {</span>
<span class="source-line-no">748</span><span id="line-748">        this.abort("Failed to retrieve Cluster ID", e);</span>
<span class="source-line-no">749</span><span id="line-749">      }</span>
<span class="source-line-no">750</span><span id="line-750">    }</span>
<span class="source-line-no">751</span><span id="line-751"></span>
<span class="source-line-no">752</span><span id="line-752">    if (isStopped() || isAborted()) {</span>
<span class="source-line-no">753</span><span id="line-753">      return; // No need for further initialization</span>
<span class="source-line-no">754</span><span id="line-754">    }</span>
<span class="source-line-no">755</span><span id="line-755"></span>
<span class="source-line-no">756</span><span id="line-756">    // watch for snapshots and other procedures</span>
<span class="source-line-no">757</span><span id="line-757">    try {</span>
<span class="source-line-no">758</span><span id="line-758">      rspmHost = new RegionServerProcedureManagerHost();</span>
<span class="source-line-no">759</span><span id="line-759">      rspmHost.loadProcedures(conf);</span>
<span class="source-line-no">760</span><span id="line-760">      rspmHost.initialize(this);</span>
<span class="source-line-no">761</span><span id="line-761">    } catch (KeeperException e) {</span>
<span class="source-line-no">762</span><span id="line-762">      this.abort("Failed to reach coordination cluster when creating procedure handler.", e);</span>
<span class="source-line-no">763</span><span id="line-763">    }</span>
<span class="source-line-no">764</span><span id="line-764">  }</span>
<span class="source-line-no">765</span><span id="line-765"></span>
<span class="source-line-no">766</span><span id="line-766">  /**</span>
<span class="source-line-no">767</span><span id="line-767">   * Utilty method to wait indefinitely on a znode availability while checking if the region server</span>
<span class="source-line-no">768</span><span id="line-768">   * is shut down</span>
<span class="source-line-no">769</span><span id="line-769">   * @param tracker znode tracker to use</span>
<span class="source-line-no">770</span><span id="line-770">   * @throws IOException          any IO exception, plus if the RS is stopped</span>
<span class="source-line-no">771</span><span id="line-771">   * @throws InterruptedException if the waiting thread is interrupted</span>
<span class="source-line-no">772</span><span id="line-772">   */</span>
<span class="source-line-no">773</span><span id="line-773">  private void blockAndCheckIfStopped(ZKNodeTracker tracker)</span>
<span class="source-line-no">774</span><span id="line-774">    throws IOException, InterruptedException {</span>
<span class="source-line-no">775</span><span id="line-775">    while (tracker.blockUntilAvailable(this.msgInterval, false) == null) {</span>
<span class="source-line-no">776</span><span id="line-776">      if (this.stopped) {</span>
<span class="source-line-no">777</span><span id="line-777">        throw new IOException("Received the shutdown message while waiting.");</span>
<span class="source-line-no">778</span><span id="line-778">      }</span>
<span class="source-line-no">779</span><span id="line-779">    }</span>
<span class="source-line-no">780</span><span id="line-780">  }</span>
<span class="source-line-no">781</span><span id="line-781"></span>
<span class="source-line-no">782</span><span id="line-782">  /** Returns True if the cluster is up. */</span>
<span class="source-line-no">783</span><span id="line-783">  @Override</span>
<span class="source-line-no">784</span><span id="line-784">  public boolean isClusterUp() {</span>
<span class="source-line-no">785</span><span id="line-785">    return this.masterless</span>
<span class="source-line-no">786</span><span id="line-786">      || (this.clusterStatusTracker != null &amp;&amp; this.clusterStatusTracker.isClusterUp());</span>
<span class="source-line-no">787</span><span id="line-787">  }</span>
<span class="source-line-no">788</span><span id="line-788"></span>
<span class="source-line-no">789</span><span id="line-789">  private void initializeReplicationMarkerChore() {</span>
<span class="source-line-no">790</span><span id="line-790">    boolean replicationMarkerEnabled =</span>
<span class="source-line-no">791</span><span id="line-791">      conf.getBoolean(REPLICATION_MARKER_ENABLED_KEY, REPLICATION_MARKER_ENABLED_DEFAULT);</span>
<span class="source-line-no">792</span><span id="line-792">    // If replication or replication marker is not enabled then return immediately.</span>
<span class="source-line-no">793</span><span id="line-793">    if (replicationMarkerEnabled) {</span>
<span class="source-line-no">794</span><span id="line-794">      int period = conf.getInt(REPLICATION_MARKER_CHORE_DURATION_KEY,</span>
<span class="source-line-no">795</span><span id="line-795">        REPLICATION_MARKER_CHORE_DURATION_DEFAULT);</span>
<span class="source-line-no">796</span><span id="line-796">      replicationMarkerChore = new ReplicationMarkerChore(this, this, period, conf);</span>
<span class="source-line-no">797</span><span id="line-797">    }</span>
<span class="source-line-no">798</span><span id="line-798">  }</span>
<span class="source-line-no">799</span><span id="line-799"></span>
<span class="source-line-no">800</span><span id="line-800">  @Override</span>
<span class="source-line-no">801</span><span id="line-801">  public boolean isStopping() {</span>
<span class="source-line-no">802</span><span id="line-802">    return stopping;</span>
<span class="source-line-no">803</span><span id="line-803">  }</span>
<span class="source-line-no">804</span><span id="line-804"></span>
<span class="source-line-no">805</span><span id="line-805">  /**</span>
<span class="source-line-no">806</span><span id="line-806">   * The HRegionServer sticks in this loop until closed.</span>
<span class="source-line-no">807</span><span id="line-807">   */</span>
<span class="source-line-no">808</span><span id="line-808">  @Override</span>
<span class="source-line-no">809</span><span id="line-809">  public void run() {</span>
<span class="source-line-no">810</span><span id="line-810">    if (isStopped()) {</span>
<span class="source-line-no">811</span><span id="line-811">      LOG.info("Skipping run; stopped");</span>
<span class="source-line-no">812</span><span id="line-812">      return;</span>
<span class="source-line-no">813</span><span id="line-813">    }</span>
<span class="source-line-no">814</span><span id="line-814">    try {</span>
<span class="source-line-no">815</span><span id="line-815">      // Do pre-registration initializations; zookeeper, lease threads, etc.</span>
<span class="source-line-no">816</span><span id="line-816">      preRegistrationInitialization();</span>
<span class="source-line-no">817</span><span id="line-817">    } catch (Throwable e) {</span>
<span class="source-line-no">818</span><span id="line-818">      abort("Fatal exception during initialization", e);</span>
<span class="source-line-no">819</span><span id="line-819">    }</span>
<span class="source-line-no">820</span><span id="line-820"></span>
<span class="source-line-no">821</span><span id="line-821">    try {</span>
<span class="source-line-no">822</span><span id="line-822">      if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">823</span><span id="line-823">        installShutdownHook();</span>
<span class="source-line-no">824</span><span id="line-824">        // Initialize the RegionServerCoprocessorHost now that our ephemeral</span>
<span class="source-line-no">825</span><span id="line-825">        // node was created, in case any coprocessors want to use ZooKeeper</span>
<span class="source-line-no">826</span><span id="line-826">        this.rsHost = new RegionServerCoprocessorHost(this, this.conf);</span>
<span class="source-line-no">827</span><span id="line-827"></span>
<span class="source-line-no">828</span><span id="line-828">        // Try and register with the Master; tell it we are here. Break if server is stopped or</span>
<span class="source-line-no">829</span><span id="line-829">        // the clusterup flag is down or hdfs went wacky. Once registered successfully, go ahead and</span>
<span class="source-line-no">830</span><span id="line-830">        // start up all Services. Use RetryCounter to get backoff in case Master is struggling to</span>
<span class="source-line-no">831</span><span id="line-831">        // come up.</span>
<span class="source-line-no">832</span><span id="line-832">        LOG.debug("About to register with Master.");</span>
<span class="source-line-no">833</span><span id="line-833">        TraceUtil.trace(() -&gt; {</span>
<span class="source-line-no">834</span><span id="line-834">          RetryCounterFactory rcf =</span>
<span class="source-line-no">835</span><span id="line-835">            new RetryCounterFactory(Integer.MAX_VALUE, this.sleeper.getPeriod(), 1000 * 60 * 5);</span>
<span class="source-line-no">836</span><span id="line-836">          RetryCounter rc = rcf.create();</span>
<span class="source-line-no">837</span><span id="line-837">          while (keepLooping()) {</span>
<span class="source-line-no">838</span><span id="line-838">            RegionServerStartupResponse w = reportForDuty();</span>
<span class="source-line-no">839</span><span id="line-839">            if (w == null) {</span>
<span class="source-line-no">840</span><span id="line-840">              long sleepTime = rc.getBackoffTimeAndIncrementAttempts();</span>
<span class="source-line-no">841</span><span id="line-841">              LOG.warn("reportForDuty failed; sleeping {} ms and then retrying.", sleepTime);</span>
<span class="source-line-no">842</span><span id="line-842">              this.sleeper.sleep(sleepTime);</span>
<span class="source-line-no">843</span><span id="line-843">            } else {</span>
<span class="source-line-no">844</span><span id="line-844">              handleReportForDutyResponse(w);</span>
<span class="source-line-no">845</span><span id="line-845">              break;</span>
<span class="source-line-no">846</span><span id="line-846">            }</span>
<span class="source-line-no">847</span><span id="line-847">          }</span>
<span class="source-line-no">848</span><span id="line-848">        }, "HRegionServer.registerWithMaster");</span>
<span class="source-line-no">849</span><span id="line-849">      }</span>
<span class="source-line-no">850</span><span id="line-850"></span>
<span class="source-line-no">851</span><span id="line-851">      if (!isStopped() &amp;&amp; isHealthy()) {</span>
<span class="source-line-no">852</span><span id="line-852">        TraceUtil.trace(() -&gt; {</span>
<span class="source-line-no">853</span><span id="line-853">          // start the snapshot handler and other procedure handlers,</span>
<span class="source-line-no">854</span><span id="line-854">          // since the server is ready to run</span>
<span class="source-line-no">855</span><span id="line-855">          if (this.rspmHost != null) {</span>
<span class="source-line-no">856</span><span id="line-856">            this.rspmHost.start();</span>
<span class="source-line-no">857</span><span id="line-857">          }</span>
<span class="source-line-no">858</span><span id="line-858">          // Start the Quota Manager</span>
<span class="source-line-no">859</span><span id="line-859">          if (this.rsQuotaManager != null) {</span>
<span class="source-line-no">860</span><span id="line-860">            rsQuotaManager.start(getRpcServer().getScheduler());</span>
<span class="source-line-no">861</span><span id="line-861">          }</span>
<span class="source-line-no">862</span><span id="line-862">          if (this.rsSpaceQuotaManager != null) {</span>
<span class="source-line-no">863</span><span id="line-863">            this.rsSpaceQuotaManager.start();</span>
<span class="source-line-no">864</span><span id="line-864">          }</span>
<span class="source-line-no">865</span><span id="line-865">        }, "HRegionServer.startup");</span>
<span class="source-line-no">866</span><span id="line-866">      }</span>
<span class="source-line-no">867</span><span id="line-867"></span>
<span class="source-line-no">868</span><span id="line-868">      // We registered with the Master. Go into run mode.</span>
<span class="source-line-no">869</span><span id="line-869">      long lastMsg = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">870</span><span id="line-870">      long oldRequestCount = -1;</span>
<span class="source-line-no">871</span><span id="line-871">      // The main run loop.</span>
<span class="source-line-no">872</span><span id="line-872">      while (!isStopped() &amp;&amp; isHealthy()) {</span>
<span class="source-line-no">873</span><span id="line-873">        if (!isClusterUp()) {</span>
<span class="source-line-no">874</span><span id="line-874">          if (onlineRegions.isEmpty()) {</span>
<span class="source-line-no">875</span><span id="line-875">            stop("Exiting; cluster shutdown set and not carrying any regions");</span>
<span class="source-line-no">876</span><span id="line-876">          } else if (!this.stopping) {</span>
<span class="source-line-no">877</span><span id="line-877">            this.stopping = true;</span>
<span class="source-line-no">878</span><span id="line-878">            LOG.info("Closing user regions");</span>
<span class="source-line-no">879</span><span id="line-879">            closeUserRegions(isAborted());</span>
<span class="source-line-no">880</span><span id="line-880">          } else {</span>
<span class="source-line-no">881</span><span id="line-881">            boolean allUserRegionsOffline = areAllUserRegionsOffline();</span>
<span class="source-line-no">882</span><span id="line-882">            if (allUserRegionsOffline) {</span>
<span class="source-line-no">883</span><span id="line-883">              // Set stopped if no more write requests tp meta tables</span>
<span class="source-line-no">884</span><span id="line-884">              // since last time we went around the loop. Any open</span>
<span class="source-line-no">885</span><span id="line-885">              // meta regions will be closed on our way out.</span>
<span class="source-line-no">886</span><span id="line-886">              if (oldRequestCount == getWriteRequestCount()) {</span>
<span class="source-line-no">887</span><span id="line-887">                stop("Stopped; only catalog regions remaining online");</span>
<span class="source-line-no">888</span><span id="line-888">                break;</span>
<span class="source-line-no">889</span><span id="line-889">              }</span>
<span class="source-line-no">890</span><span id="line-890">              oldRequestCount = getWriteRequestCount();</span>
<span class="source-line-no">891</span><span id="line-891">            } else {</span>
<span class="source-line-no">892</span><span id="line-892">              // Make sure all regions have been closed -- some regions may</span>
<span class="source-line-no">893</span><span id="line-893">              // have not got it because we were splitting at the time of</span>
<span class="source-line-no">894</span><span id="line-894">              // the call to closeUserRegions.</span>
<span class="source-line-no">895</span><span id="line-895">              closeUserRegions(this.abortRequested.get());</span>
<span class="source-line-no">896</span><span id="line-896">            }</span>
<span class="source-line-no">897</span><span id="line-897">            LOG.debug("Waiting on " + getOnlineRegionsAsPrintableString());</span>
<span class="source-line-no">898</span><span id="line-898">          }</span>
<span class="source-line-no">899</span><span id="line-899">        }</span>
<span class="source-line-no">900</span><span id="line-900">        long now = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">901</span><span id="line-901">        if ((now - lastMsg) &gt;= msgInterval) {</span>
<span class="source-line-no">902</span><span id="line-902">          tryRegionServerReport(lastMsg, now);</span>
<span class="source-line-no">903</span><span id="line-903">          lastMsg = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">904</span><span id="line-904">        }</span>
<span class="source-line-no">905</span><span id="line-905">        if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">906</span><span id="line-906">          this.sleeper.sleep();</span>
<span class="source-line-no">907</span><span id="line-907">        }</span>
<span class="source-line-no">908</span><span id="line-908">      } // for</span>
<span class="source-line-no">909</span><span id="line-909">    } catch (Throwable t) {</span>
<span class="source-line-no">910</span><span id="line-910">      if (!rpcServices.checkOOME(t)) {</span>
<span class="source-line-no">911</span><span id="line-911">        String prefix = t instanceof YouAreDeadException ? "" : "Unhandled: ";</span>
<span class="source-line-no">912</span><span id="line-912">        abort(prefix + t.getMessage(), t);</span>
<span class="source-line-no">913</span><span id="line-913">      }</span>
<span class="source-line-no">914</span><span id="line-914">    }</span>
<span class="source-line-no">915</span><span id="line-915"></span>
<span class="source-line-no">916</span><span id="line-916">    final Span span = TraceUtil.createSpan("HRegionServer exiting main loop");</span>
<span class="source-line-no">917</span><span id="line-917">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">918</span><span id="line-918">      if (this.leaseManager != null) {</span>
<span class="source-line-no">919</span><span id="line-919">        this.leaseManager.closeAfterLeasesExpire();</span>
<span class="source-line-no">920</span><span id="line-920">      }</span>
<span class="source-line-no">921</span><span id="line-921">      if (this.splitLogWorker != null) {</span>
<span class="source-line-no">922</span><span id="line-922">        splitLogWorker.stop();</span>
<span class="source-line-no">923</span><span id="line-923">      }</span>
<span class="source-line-no">924</span><span id="line-924">      stopInfoServer();</span>
<span class="source-line-no">925</span><span id="line-925">      // Send cache a shutdown.</span>
<span class="source-line-no">926</span><span id="line-926">      if (blockCache != null) {</span>
<span class="source-line-no">927</span><span id="line-927">        blockCache.shutdown();</span>
<span class="source-line-no">928</span><span id="line-928">      }</span>
<span class="source-line-no">929</span><span id="line-929">      if (mobFileCache != null) {</span>
<span class="source-line-no">930</span><span id="line-930">        mobFileCache.shutdown();</span>
<span class="source-line-no">931</span><span id="line-931">      }</span>
<span class="source-line-no">932</span><span id="line-932"></span>
<span class="source-line-no">933</span><span id="line-933">      // Send interrupts to wake up threads if sleeping so they notice shutdown.</span>
<span class="source-line-no">934</span><span id="line-934">      // TODO: Should we check they are alive? If OOME could have exited already</span>
<span class="source-line-no">935</span><span id="line-935">      if (this.hMemManager != null) {</span>
<span class="source-line-no">936</span><span id="line-936">        this.hMemManager.stop();</span>
<span class="source-line-no">937</span><span id="line-937">      }</span>
<span class="source-line-no">938</span><span id="line-938">      if (this.cacheFlusher != null) {</span>
<span class="source-line-no">939</span><span id="line-939">        this.cacheFlusher.interruptIfNecessary();</span>
<span class="source-line-no">940</span><span id="line-940">      }</span>
<span class="source-line-no">941</span><span id="line-941">      if (this.compactSplitThread != null) {</span>
<span class="source-line-no">942</span><span id="line-942">        this.compactSplitThread.interruptIfNecessary();</span>
<span class="source-line-no">943</span><span id="line-943">      }</span>
<span class="source-line-no">944</span><span id="line-944"></span>
<span class="source-line-no">945</span><span id="line-945">      // Stop the snapshot and other procedure handlers, forcefully killing all running tasks</span>
<span class="source-line-no">946</span><span id="line-946">      if (rspmHost != null) {</span>
<span class="source-line-no">947</span><span id="line-947">        rspmHost.stop(this.abortRequested.get() || this.killed);</span>
<span class="source-line-no">948</span><span id="line-948">      }</span>
<span class="source-line-no">949</span><span id="line-949"></span>
<span class="source-line-no">950</span><span id="line-950">      if (this.killed) {</span>
<span class="source-line-no">951</span><span id="line-951">        // Just skip out w/o closing regions. Used when testing.</span>
<span class="source-line-no">952</span><span id="line-952">      } else if (abortRequested.get()) {</span>
<span class="source-line-no">953</span><span id="line-953">        if (this.dataFsOk) {</span>
<span class="source-line-no">954</span><span id="line-954">          closeUserRegions(abortRequested.get()); // Don't leave any open file handles</span>
<span class="source-line-no">955</span><span id="line-955">        }</span>
<span class="source-line-no">956</span><span id="line-956">        LOG.info("aborting server " + this.serverName);</span>
<span class="source-line-no">957</span><span id="line-957">      } else {</span>
<span class="source-line-no">958</span><span id="line-958">        closeUserRegions(abortRequested.get());</span>
<span class="source-line-no">959</span><span id="line-959">        LOG.info("stopping server " + this.serverName);</span>
<span class="source-line-no">960</span><span id="line-960">      }</span>
<span class="source-line-no">961</span><span id="line-961">      regionReplicationBufferManager.stop();</span>
<span class="source-line-no">962</span><span id="line-962">      closeClusterConnection();</span>
<span class="source-line-no">963</span><span id="line-963">      // Closing the compactSplit thread before closing meta regions</span>
<span class="source-line-no">964</span><span id="line-964">      if (!this.killed &amp;&amp; containsMetaTableRegions()) {</span>
<span class="source-line-no">965</span><span id="line-965">        if (!abortRequested.get() || this.dataFsOk) {</span>
<span class="source-line-no">966</span><span id="line-966">          if (this.compactSplitThread != null) {</span>
<span class="source-line-no">967</span><span id="line-967">            this.compactSplitThread.join();</span>
<span class="source-line-no">968</span><span id="line-968">            this.compactSplitThread = null;</span>
<span class="source-line-no">969</span><span id="line-969">          }</span>
<span class="source-line-no">970</span><span id="line-970">          closeMetaTableRegions(abortRequested.get());</span>
<span class="source-line-no">971</span><span id="line-971">        }</span>
<span class="source-line-no">972</span><span id="line-972">      }</span>
<span class="source-line-no">973</span><span id="line-973"></span>
<span class="source-line-no">974</span><span id="line-974">      if (!this.killed &amp;&amp; this.dataFsOk) {</span>
<span class="source-line-no">975</span><span id="line-975">        waitOnAllRegionsToClose(abortRequested.get());</span>
<span class="source-line-no">976</span><span id="line-976">        LOG.info("stopping server " + this.serverName + "; all regions closed.");</span>
<span class="source-line-no">977</span><span id="line-977">      }</span>
<span class="source-line-no">978</span><span id="line-978"></span>
<span class="source-line-no">979</span><span id="line-979">      // Stop the quota manager</span>
<span class="source-line-no">980</span><span id="line-980">      if (rsQuotaManager != null) {</span>
<span class="source-line-no">981</span><span id="line-981">        rsQuotaManager.stop();</span>
<span class="source-line-no">982</span><span id="line-982">      }</span>
<span class="source-line-no">983</span><span id="line-983">      if (rsSpaceQuotaManager != null) {</span>
<span class="source-line-no">984</span><span id="line-984">        rsSpaceQuotaManager.stop();</span>
<span class="source-line-no">985</span><span id="line-985">        rsSpaceQuotaManager = null;</span>
<span class="source-line-no">986</span><span id="line-986">      }</span>
<span class="source-line-no">987</span><span id="line-987"></span>
<span class="source-line-no">988</span><span id="line-988">      // flag may be changed when closing regions throws exception.</span>
<span class="source-line-no">989</span><span id="line-989">      if (this.dataFsOk) {</span>
<span class="source-line-no">990</span><span id="line-990">        shutdownWAL(!abortRequested.get());</span>
<span class="source-line-no">991</span><span id="line-991">      }</span>
<span class="source-line-no">992</span><span id="line-992"></span>
<span class="source-line-no">993</span><span id="line-993">      // Make sure the proxy is down.</span>
<span class="source-line-no">994</span><span id="line-994">      if (this.rssStub != null) {</span>
<span class="source-line-no">995</span><span id="line-995">        this.rssStub = null;</span>
<span class="source-line-no">996</span><span id="line-996">      }</span>
<span class="source-line-no">997</span><span id="line-997">      if (this.lockStub != null) {</span>
<span class="source-line-no">998</span><span id="line-998">        this.lockStub = null;</span>
<span class="source-line-no">999</span><span id="line-999">      }</span>
<span class="source-line-no">1000</span><span id="line-1000">      if (this.rpcClient != null) {</span>
<span class="source-line-no">1001</span><span id="line-1001">        this.rpcClient.close();</span>
<span class="source-line-no">1002</span><span id="line-1002">      }</span>
<span class="source-line-no">1003</span><span id="line-1003">      if (this.leaseManager != null) {</span>
<span class="source-line-no">1004</span><span id="line-1004">        this.leaseManager.close();</span>
<span class="source-line-no">1005</span><span id="line-1005">      }</span>
<span class="source-line-no">1006</span><span id="line-1006">      if (this.pauseMonitor != null) {</span>
<span class="source-line-no">1007</span><span id="line-1007">        this.pauseMonitor.stop();</span>
<span class="source-line-no">1008</span><span id="line-1008">      }</span>
<span class="source-line-no">1009</span><span id="line-1009"></span>
<span class="source-line-no">1010</span><span id="line-1010">      if (!killed) {</span>
<span class="source-line-no">1011</span><span id="line-1011">        stopServiceThreads();</span>
<span class="source-line-no">1012</span><span id="line-1012">      }</span>
<span class="source-line-no">1013</span><span id="line-1013"></span>
<span class="source-line-no">1014</span><span id="line-1014">      if (this.rpcServices != null) {</span>
<span class="source-line-no">1015</span><span id="line-1015">        this.rpcServices.stop();</span>
<span class="source-line-no">1016</span><span id="line-1016">      }</span>
<span class="source-line-no">1017</span><span id="line-1017"></span>
<span class="source-line-no">1018</span><span id="line-1018">      try {</span>
<span class="source-line-no">1019</span><span id="line-1019">        deleteMyEphemeralNode();</span>
<span class="source-line-no">1020</span><span id="line-1020">      } catch (KeeperException.NoNodeException nn) {</span>
<span class="source-line-no">1021</span><span id="line-1021">        // pass</span>
<span class="source-line-no">1022</span><span id="line-1022">      } catch (KeeperException e) {</span>
<span class="source-line-no">1023</span><span id="line-1023">        LOG.warn("Failed deleting my ephemeral node", e);</span>
<span class="source-line-no">1024</span><span id="line-1024">      }</span>
<span class="source-line-no">1025</span><span id="line-1025">      // We may have failed to delete the znode at the previous step, but</span>
<span class="source-line-no">1026</span><span id="line-1026">      // we delete the file anyway: a second attempt to delete the znode is likely to fail again.</span>
<span class="source-line-no">1027</span><span id="line-1027">      ZNodeClearer.deleteMyEphemeralNodeOnDisk();</span>
<span class="source-line-no">1028</span><span id="line-1028"></span>
<span class="source-line-no">1029</span><span id="line-1029">      closeZooKeeper();</span>
<span class="source-line-no">1030</span><span id="line-1030">      closeTableDescriptors();</span>
<span class="source-line-no">1031</span><span id="line-1031">      LOG.info("Exiting; stopping=" + this.serverName + "; zookeeper connection closed.");</span>
<span class="source-line-no">1032</span><span id="line-1032">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">1033</span><span id="line-1033">    } finally {</span>
<span class="source-line-no">1034</span><span id="line-1034">      span.end();</span>
<span class="source-line-no">1035</span><span id="line-1035">    }</span>
<span class="source-line-no">1036</span><span id="line-1036">  }</span>
<span class="source-line-no">1037</span><span id="line-1037"></span>
<span class="source-line-no">1038</span><span id="line-1038">  private boolean containsMetaTableRegions() {</span>
<span class="source-line-no">1039</span><span id="line-1039">    return onlineRegions.containsKey(RegionInfoBuilder.FIRST_META_REGIONINFO.getEncodedName());</span>
<span class="source-line-no">1040</span><span id="line-1040">  }</span>
<span class="source-line-no">1041</span><span id="line-1041"></span>
<span class="source-line-no">1042</span><span id="line-1042">  private boolean areAllUserRegionsOffline() {</span>
<span class="source-line-no">1043</span><span id="line-1043">    if (getNumberOfOnlineRegions() &gt; 2) {</span>
<span class="source-line-no">1044</span><span id="line-1044">      return false;</span>
<span class="source-line-no">1045</span><span id="line-1045">    }</span>
<span class="source-line-no">1046</span><span id="line-1046">    boolean allUserRegionsOffline = true;</span>
<span class="source-line-no">1047</span><span id="line-1047">    for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1048</span><span id="line-1048">      if (!e.getValue().getRegionInfo().isMetaRegion()) {</span>
<span class="source-line-no">1049</span><span id="line-1049">        allUserRegionsOffline = false;</span>
<span class="source-line-no">1050</span><span id="line-1050">        break;</span>
<span class="source-line-no">1051</span><span id="line-1051">      }</span>
<span class="source-line-no">1052</span><span id="line-1052">    }</span>
<span class="source-line-no">1053</span><span id="line-1053">    return allUserRegionsOffline;</span>
<span class="source-line-no">1054</span><span id="line-1054">  }</span>
<span class="source-line-no">1055</span><span id="line-1055"></span>
<span class="source-line-no">1056</span><span id="line-1056">  /** Returns Current write count for all online regions. */</span>
<span class="source-line-no">1057</span><span id="line-1057">  private long getWriteRequestCount() {</span>
<span class="source-line-no">1058</span><span id="line-1058">    long writeCount = 0;</span>
<span class="source-line-no">1059</span><span id="line-1059">    for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1060</span><span id="line-1060">      writeCount += e.getValue().getWriteRequestsCount();</span>
<span class="source-line-no">1061</span><span id="line-1061">    }</span>
<span class="source-line-no">1062</span><span id="line-1062">    return writeCount;</span>
<span class="source-line-no">1063</span><span id="line-1063">  }</span>
<span class="source-line-no">1064</span><span id="line-1064"></span>
<span class="source-line-no">1065</span><span id="line-1065">  @InterfaceAudience.Private</span>
<span class="source-line-no">1066</span><span id="line-1066">  protected void tryRegionServerReport(long reportStartTime, long reportEndTime)</span>
<span class="source-line-no">1067</span><span id="line-1067">    throws IOException {</span>
<span class="source-line-no">1068</span><span id="line-1068">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">1069</span><span id="line-1069">    if (rss == null) {</span>
<span class="source-line-no">1070</span><span id="line-1070">      // the current server could be stopping.</span>
<span class="source-line-no">1071</span><span id="line-1071">      return;</span>
<span class="source-line-no">1072</span><span id="line-1072">    }</span>
<span class="source-line-no">1073</span><span id="line-1073">    ClusterStatusProtos.ServerLoad sl = buildServerLoad(reportStartTime, reportEndTime);</span>
<span class="source-line-no">1074</span><span id="line-1074">    final Span span = TraceUtil.createSpan("HRegionServer.tryRegionServerReport");</span>
<span class="source-line-no">1075</span><span id="line-1075">    try (Scope ignored = span.makeCurrent()) {</span>
<span class="source-line-no">1076</span><span id="line-1076">      RegionServerReportRequest.Builder request = RegionServerReportRequest.newBuilder();</span>
<span class="source-line-no">1077</span><span id="line-1077">      request.setServer(ProtobufUtil.toServerName(this.serverName));</span>
<span class="source-line-no">1078</span><span id="line-1078">      request.setLoad(sl);</span>
<span class="source-line-no">1079</span><span id="line-1079">      rss.regionServerReport(null, request.build());</span>
<span class="source-line-no">1080</span><span id="line-1080">      span.setStatus(StatusCode.OK);</span>
<span class="source-line-no">1081</span><span id="line-1081">    } catch (ServiceException se) {</span>
<span class="source-line-no">1082</span><span id="line-1082">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">1083</span><span id="line-1083">      if (ioe instanceof YouAreDeadException) {</span>
<span class="source-line-no">1084</span><span id="line-1084">        // This will be caught and handled as a fatal error in run()</span>
<span class="source-line-no">1085</span><span id="line-1085">        TraceUtil.setError(span, ioe);</span>
<span class="source-line-no">1086</span><span id="line-1086">        throw ioe;</span>
<span class="source-line-no">1087</span><span id="line-1087">      }</span>
<span class="source-line-no">1088</span><span id="line-1088">      if (rssStub == rss) {</span>
<span class="source-line-no">1089</span><span id="line-1089">        rssStub = null;</span>
<span class="source-line-no">1090</span><span id="line-1090">      }</span>
<span class="source-line-no">1091</span><span id="line-1091">      TraceUtil.setError(span, se);</span>
<span class="source-line-no">1092</span><span id="line-1092">      // Couldn't connect to the master, get location from zk and reconnect</span>
<span class="source-line-no">1093</span><span id="line-1093">      // Method blocks until new master is found or we are stopped</span>
<span class="source-line-no">1094</span><span id="line-1094">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">1095</span><span id="line-1095">    } finally {</span>
<span class="source-line-no">1096</span><span id="line-1096">      span.end();</span>
<span class="source-line-no">1097</span><span id="line-1097">    }</span>
<span class="source-line-no">1098</span><span id="line-1098">  }</span>
<span class="source-line-no">1099</span><span id="line-1099"></span>
<span class="source-line-no">1100</span><span id="line-1100">  /**</span>
<span class="source-line-no">1101</span><span id="line-1101">   * Reports the given map of Regions and their size on the filesystem to the active Master.</span>
<span class="source-line-no">1102</span><span id="line-1102">   * @param regionSizeStore The store containing region sizes</span>
<span class="source-line-no">1103</span><span id="line-1103">   * @return false if FileSystemUtilizationChore should pause reporting to master. true otherwise</span>
<span class="source-line-no">1104</span><span id="line-1104">   */</span>
<span class="source-line-no">1105</span><span id="line-1105">  public boolean reportRegionSizesForQuotas(RegionSizeStore regionSizeStore) {</span>
<span class="source-line-no">1106</span><span id="line-1106">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">1107</span><span id="line-1107">    if (rss == null) {</span>
<span class="source-line-no">1108</span><span id="line-1108">      // the current server could be stopping.</span>
<span class="source-line-no">1109</span><span id="line-1109">      LOG.trace("Skipping Region size report to HMaster as stub is null");</span>
<span class="source-line-no">1110</span><span id="line-1110">      return true;</span>
<span class="source-line-no">1111</span><span id="line-1111">    }</span>
<span class="source-line-no">1112</span><span id="line-1112">    try {</span>
<span class="source-line-no">1113</span><span id="line-1113">      buildReportAndSend(rss, regionSizeStore);</span>
<span class="source-line-no">1114</span><span id="line-1114">    } catch (ServiceException se) {</span>
<span class="source-line-no">1115</span><span id="line-1115">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">1116</span><span id="line-1116">      if (ioe instanceof PleaseHoldException) {</span>
<span class="source-line-no">1117</span><span id="line-1117">        LOG.trace("Failed to report region sizes to Master because it is initializing."</span>
<span class="source-line-no">1118</span><span id="line-1118">          + " This will be retried.", ioe);</span>
<span class="source-line-no">1119</span><span id="line-1119">        // The Master is coming up. Will retry the report later. Avoid re-creating the stub.</span>
<span class="source-line-no">1120</span><span id="line-1120">        return true;</span>
<span class="source-line-no">1121</span><span id="line-1121">      }</span>
<span class="source-line-no">1122</span><span id="line-1122">      if (rssStub == rss) {</span>
<span class="source-line-no">1123</span><span id="line-1123">        rssStub = null;</span>
<span class="source-line-no">1124</span><span id="line-1124">      }</span>
<span class="source-line-no">1125</span><span id="line-1125">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">1126</span><span id="line-1126">      if (ioe instanceof DoNotRetryIOException) {</span>
<span class="source-line-no">1127</span><span id="line-1127">        DoNotRetryIOException doNotRetryEx = (DoNotRetryIOException) ioe;</span>
<span class="source-line-no">1128</span><span id="line-1128">        if (doNotRetryEx.getCause() != null) {</span>
<span class="source-line-no">1129</span><span id="line-1129">          Throwable t = doNotRetryEx.getCause();</span>
<span class="source-line-no">1130</span><span id="line-1130">          if (t instanceof UnsupportedOperationException) {</span>
<span class="source-line-no">1131</span><span id="line-1131">            LOG.debug("master doesn't support ReportRegionSpaceUse, pause before retrying");</span>
<span class="source-line-no">1132</span><span id="line-1132">            return false;</span>
<span class="source-line-no">1133</span><span id="line-1133">          }</span>
<span class="source-line-no">1134</span><span id="line-1134">        }</span>
<span class="source-line-no">1135</span><span id="line-1135">      }</span>
<span class="source-line-no">1136</span><span id="line-1136">      LOG.debug("Failed to report region sizes to Master. This will be retried.", ioe);</span>
<span class="source-line-no">1137</span><span id="line-1137">    }</span>
<span class="source-line-no">1138</span><span id="line-1138">    return true;</span>
<span class="source-line-no">1139</span><span id="line-1139">  }</span>
<span class="source-line-no">1140</span><span id="line-1140"></span>
<span class="source-line-no">1141</span><span id="line-1141">  /**</span>
<span class="source-line-no">1142</span><span id="line-1142">   * Builds the region size report and sends it to the master. Upon successful sending of the</span>
<span class="source-line-no">1143</span><span id="line-1143">   * report, the region sizes that were sent are marked as sent.</span>
<span class="source-line-no">1144</span><span id="line-1144">   * @param rss             The stub to send to the Master</span>
<span class="source-line-no">1145</span><span id="line-1145">   * @param regionSizeStore The store containing region sizes</span>
<span class="source-line-no">1146</span><span id="line-1146">   */</span>
<span class="source-line-no">1147</span><span id="line-1147">  private void buildReportAndSend(RegionServerStatusService.BlockingInterface rss,</span>
<span class="source-line-no">1148</span><span id="line-1148">    RegionSizeStore regionSizeStore) throws ServiceException {</span>
<span class="source-line-no">1149</span><span id="line-1149">    RegionSpaceUseReportRequest request =</span>
<span class="source-line-no">1150</span><span id="line-1150">      buildRegionSpaceUseReportRequest(Objects.requireNonNull(regionSizeStore));</span>
<span class="source-line-no">1151</span><span id="line-1151">    rss.reportRegionSpaceUse(null, request);</span>
<span class="source-line-no">1152</span><span id="line-1152">    // Record the number of size reports sent</span>
<span class="source-line-no">1153</span><span id="line-1153">    if (metricsRegionServer != null) {</span>
<span class="source-line-no">1154</span><span id="line-1154">      metricsRegionServer.incrementNumRegionSizeReportsSent(regionSizeStore.size());</span>
<span class="source-line-no">1155</span><span id="line-1155">    }</span>
<span class="source-line-no">1156</span><span id="line-1156">  }</span>
<span class="source-line-no">1157</span><span id="line-1157"></span>
<span class="source-line-no">1158</span><span id="line-1158">  /**</span>
<span class="source-line-no">1159</span><span id="line-1159">   * Builds a {@link RegionSpaceUseReportRequest} protobuf message from the region size map.</span>
<span class="source-line-no">1160</span><span id="line-1160">   * @param regionSizes The size in bytes of regions</span>
<span class="source-line-no">1161</span><span id="line-1161">   * @return The corresponding protocol buffer message.</span>
<span class="source-line-no">1162</span><span id="line-1162">   */</span>
<span class="source-line-no">1163</span><span id="line-1163">  RegionSpaceUseReportRequest buildRegionSpaceUseReportRequest(RegionSizeStore regionSizes) {</span>
<span class="source-line-no">1164</span><span id="line-1164">    RegionSpaceUseReportRequest.Builder request = RegionSpaceUseReportRequest.newBuilder();</span>
<span class="source-line-no">1165</span><span id="line-1165">    for (Entry&lt;RegionInfo, RegionSize&gt; entry : regionSizes) {</span>
<span class="source-line-no">1166</span><span id="line-1166">      request.addSpaceUse(convertRegionSize(entry.getKey(), entry.getValue().getSize()));</span>
<span class="source-line-no">1167</span><span id="line-1167">    }</span>
<span class="source-line-no">1168</span><span id="line-1168">    return request.build();</span>
<span class="source-line-no">1169</span><span id="line-1169">  }</span>
<span class="source-line-no">1170</span><span id="line-1170"></span>
<span class="source-line-no">1171</span><span id="line-1171">  /**</span>
<span class="source-line-no">1172</span><span id="line-1172">   * Converts a pair of {@link RegionInfo} and {@code long} into a {@link RegionSpaceUse} protobuf</span>
<span class="source-line-no">1173</span><span id="line-1173">   * message.</span>
<span class="source-line-no">1174</span><span id="line-1174">   * @param regionInfo  The RegionInfo</span>
<span class="source-line-no">1175</span><span id="line-1175">   * @param sizeInBytes The size in bytes of the Region</span>
<span class="source-line-no">1176</span><span id="line-1176">   * @return The protocol buffer</span>
<span class="source-line-no">1177</span><span id="line-1177">   */</span>
<span class="source-line-no">1178</span><span id="line-1178">  RegionSpaceUse convertRegionSize(RegionInfo regionInfo, Long sizeInBytes) {</span>
<span class="source-line-no">1179</span><span id="line-1179">    return RegionSpaceUse.newBuilder()</span>
<span class="source-line-no">1180</span><span id="line-1180">      .setRegionInfo(ProtobufUtil.toRegionInfo(Objects.requireNonNull(regionInfo)))</span>
<span class="source-line-no">1181</span><span id="line-1181">      .setRegionSize(Objects.requireNonNull(sizeInBytes)).build();</span>
<span class="source-line-no">1182</span><span id="line-1182">  }</span>
<span class="source-line-no">1183</span><span id="line-1183"></span>
<span class="source-line-no">1184</span><span id="line-1184">  private ClusterStatusProtos.ServerLoad buildServerLoad(long reportStartTime, long reportEndTime)</span>
<span class="source-line-no">1185</span><span id="line-1185">    throws IOException {</span>
<span class="source-line-no">1186</span><span id="line-1186">    // We're getting the MetricsRegionServerWrapper here because the wrapper computes requests</span>
<span class="source-line-no">1187</span><span id="line-1187">    // per second, and other metrics As long as metrics are part of ServerLoad it's best to use</span>
<span class="source-line-no">1188</span><span id="line-1188">    // the wrapper to compute those numbers in one place.</span>
<span class="source-line-no">1189</span><span id="line-1189">    // In the long term most of these should be moved off of ServerLoad and the heart beat.</span>
<span class="source-line-no">1190</span><span id="line-1190">    // Instead they should be stored in an HBase table so that external visibility into HBase is</span>
<span class="source-line-no">1191</span><span id="line-1191">    // improved; Additionally the load balancer will be able to take advantage of a more complete</span>
<span class="source-line-no">1192</span><span id="line-1192">    // history.</span>
<span class="source-line-no">1193</span><span id="line-1193">    MetricsRegionServerWrapper regionServerWrapper = metricsRegionServer.getRegionServerWrapper();</span>
<span class="source-line-no">1194</span><span id="line-1194">    Collection&lt;HRegion&gt; regions = getOnlineRegionsLocalContext();</span>
<span class="source-line-no">1195</span><span id="line-1195">    long usedMemory = -1L;</span>
<span class="source-line-no">1196</span><span id="line-1196">    long maxMemory = -1L;</span>
<span class="source-line-no">1197</span><span id="line-1197">    final MemoryUsage usage = MemorySizeUtil.safeGetHeapMemoryUsage();</span>
<span class="source-line-no">1198</span><span id="line-1198">    if (usage != null) {</span>
<span class="source-line-no">1199</span><span id="line-1199">      usedMemory = usage.getUsed();</span>
<span class="source-line-no">1200</span><span id="line-1200">      maxMemory = usage.getMax();</span>
<span class="source-line-no">1201</span><span id="line-1201">    }</span>
<span class="source-line-no">1202</span><span id="line-1202"></span>
<span class="source-line-no">1203</span><span id="line-1203">    ClusterStatusProtos.ServerLoad.Builder serverLoad = ClusterStatusProtos.ServerLoad.newBuilder();</span>
<span class="source-line-no">1204</span><span id="line-1204">    serverLoad.setNumberOfRequests((int) regionServerWrapper.getRequestsPerSecond());</span>
<span class="source-line-no">1205</span><span id="line-1205">    serverLoad.setTotalNumberOfRequests(regionServerWrapper.getTotalRequestCount());</span>
<span class="source-line-no">1206</span><span id="line-1206">    serverLoad.setUsedHeapMB((int) (usedMemory / 1024 / 1024));</span>
<span class="source-line-no">1207</span><span id="line-1207">    serverLoad.setMaxHeapMB((int) (maxMemory / 1024 / 1024));</span>
<span class="source-line-no">1208</span><span id="line-1208">    serverLoad.setReadRequestsCount(this.metricsRegionServerImpl.getReadRequestsCount());</span>
<span class="source-line-no">1209</span><span id="line-1209">    serverLoad.setWriteRequestsCount(this.metricsRegionServerImpl.getWriteRequestsCount());</span>
<span class="source-line-no">1210</span><span id="line-1210">    Set&lt;String&gt; coprocessors = getWAL(null).getCoprocessorHost().getCoprocessors();</span>
<span class="source-line-no">1211</span><span id="line-1211">    Coprocessor.Builder coprocessorBuilder = Coprocessor.newBuilder();</span>
<span class="source-line-no">1212</span><span id="line-1212">    for (String coprocessor : coprocessors) {</span>
<span class="source-line-no">1213</span><span id="line-1213">      serverLoad.addCoprocessors(coprocessorBuilder.setName(coprocessor).build());</span>
<span class="source-line-no">1214</span><span id="line-1214">    }</span>
<span class="source-line-no">1215</span><span id="line-1215">    RegionLoad.Builder regionLoadBldr = RegionLoad.newBuilder();</span>
<span class="source-line-no">1216</span><span id="line-1216">    RegionSpecifier.Builder regionSpecifier = RegionSpecifier.newBuilder();</span>
<span class="source-line-no">1217</span><span id="line-1217">    for (HRegion region : regions) {</span>
<span class="source-line-no">1218</span><span id="line-1218">      if (region.getCoprocessorHost() != null) {</span>
<span class="source-line-no">1219</span><span id="line-1219">        Set&lt;String&gt; regionCoprocessors = region.getCoprocessorHost().getCoprocessors();</span>
<span class="source-line-no">1220</span><span id="line-1220">        for (String regionCoprocessor : regionCoprocessors) {</span>
<span class="source-line-no">1221</span><span id="line-1221">          serverLoad.addCoprocessors(coprocessorBuilder.setName(regionCoprocessor).build());</span>
<span class="source-line-no">1222</span><span id="line-1222">        }</span>
<span class="source-line-no">1223</span><span id="line-1223">      }</span>
<span class="source-line-no">1224</span><span id="line-1224">      serverLoad.addRegionLoads(createRegionLoad(region, regionLoadBldr, regionSpecifier));</span>
<span class="source-line-no">1225</span><span id="line-1225">      for (String coprocessor : getWAL(region.getRegionInfo()).getCoprocessorHost()</span>
<span class="source-line-no">1226</span><span id="line-1226">        .getCoprocessors()) {</span>
<span class="source-line-no">1227</span><span id="line-1227">        serverLoad.addCoprocessors(coprocessorBuilder.setName(coprocessor).build());</span>
<span class="source-line-no">1228</span><span id="line-1228">      }</span>
<span class="source-line-no">1229</span><span id="line-1229">    }</span>
<span class="source-line-no">1230</span><span id="line-1230"></span>
<span class="source-line-no">1231</span><span id="line-1231">    getBlockCache().ifPresent(cache -&gt; {</span>
<span class="source-line-no">1232</span><span id="line-1232">      cache.getRegionCachedInfo().ifPresent(regionCachedInfo -&gt; {</span>
<span class="source-line-no">1233</span><span id="line-1233">        regionCachedInfo.forEach((regionName, prefetchSize) -&gt; {</span>
<span class="source-line-no">1234</span><span id="line-1234">          serverLoad.putRegionCachedInfo(regionName, roundSize(prefetchSize, unitMB));</span>
<span class="source-line-no">1235</span><span id="line-1235">        });</span>
<span class="source-line-no">1236</span><span id="line-1236">      });</span>
<span class="source-line-no">1237</span><span id="line-1237">    });</span>
<span class="source-line-no">1238</span><span id="line-1238"></span>
<span class="source-line-no">1239</span><span id="line-1239">    serverLoad.setReportStartTime(reportStartTime);</span>
<span class="source-line-no">1240</span><span id="line-1240">    serverLoad.setReportEndTime(reportEndTime);</span>
<span class="source-line-no">1241</span><span id="line-1241">    if (this.infoServer != null) {</span>
<span class="source-line-no">1242</span><span id="line-1242">      serverLoad.setInfoServerPort(this.infoServer.getPort());</span>
<span class="source-line-no">1243</span><span id="line-1243">    } else {</span>
<span class="source-line-no">1244</span><span id="line-1244">      serverLoad.setInfoServerPort(-1);</span>
<span class="source-line-no">1245</span><span id="line-1245">    }</span>
<span class="source-line-no">1246</span><span id="line-1246">    MetricsUserAggregateSource userSource =</span>
<span class="source-line-no">1247</span><span id="line-1247">      metricsRegionServer.getMetricsUserAggregate().getSource();</span>
<span class="source-line-no">1248</span><span id="line-1248">    if (userSource != null) {</span>
<span class="source-line-no">1249</span><span id="line-1249">      Map&lt;String, MetricsUserSource&gt; userMetricMap = userSource.getUserSources();</span>
<span class="source-line-no">1250</span><span id="line-1250">      for (Entry&lt;String, MetricsUserSource&gt; entry : userMetricMap.entrySet()) {</span>
<span class="source-line-no">1251</span><span id="line-1251">        serverLoad.addUserLoads(createUserLoad(entry.getKey(), entry.getValue()));</span>
<span class="source-line-no">1252</span><span id="line-1252">      }</span>
<span class="source-line-no">1253</span><span id="line-1253">    }</span>
<span class="source-line-no">1254</span><span id="line-1254"></span>
<span class="source-line-no">1255</span><span id="line-1255">    if (sameReplicationSourceAndSink &amp;&amp; replicationSourceHandler != null) {</span>
<span class="source-line-no">1256</span><span id="line-1256">      // always refresh first to get the latest value</span>
<span class="source-line-no">1257</span><span id="line-1257">      ReplicationLoad rLoad = replicationSourceHandler.refreshAndGetReplicationLoad();</span>
<span class="source-line-no">1258</span><span id="line-1258">      if (rLoad != null) {</span>
<span class="source-line-no">1259</span><span id="line-1259">        serverLoad.setReplLoadSink(rLoad.getReplicationLoadSink());</span>
<span class="source-line-no">1260</span><span id="line-1260">        for (ClusterStatusProtos.ReplicationLoadSource rLS : rLoad</span>
<span class="source-line-no">1261</span><span id="line-1261">          .getReplicationLoadSourceEntries()) {</span>
<span class="source-line-no">1262</span><span id="line-1262">          serverLoad.addReplLoadSource(rLS);</span>
<span class="source-line-no">1263</span><span id="line-1263">        }</span>
<span class="source-line-no">1264</span><span id="line-1264">      }</span>
<span class="source-line-no">1265</span><span id="line-1265">    } else {</span>
<span class="source-line-no">1266</span><span id="line-1266">      if (replicationSourceHandler != null) {</span>
<span class="source-line-no">1267</span><span id="line-1267">        ReplicationLoad rLoad = replicationSourceHandler.refreshAndGetReplicationLoad();</span>
<span class="source-line-no">1268</span><span id="line-1268">        if (rLoad != null) {</span>
<span class="source-line-no">1269</span><span id="line-1269">          for (ClusterStatusProtos.ReplicationLoadSource rLS : rLoad</span>
<span class="source-line-no">1270</span><span id="line-1270">            .getReplicationLoadSourceEntries()) {</span>
<span class="source-line-no">1271</span><span id="line-1271">            serverLoad.addReplLoadSource(rLS);</span>
<span class="source-line-no">1272</span><span id="line-1272">          }</span>
<span class="source-line-no">1273</span><span id="line-1273">        }</span>
<span class="source-line-no">1274</span><span id="line-1274">      }</span>
<span class="source-line-no">1275</span><span id="line-1275">      if (replicationSinkHandler != null) {</span>
<span class="source-line-no">1276</span><span id="line-1276">        ReplicationLoad rLoad = replicationSinkHandler.refreshAndGetReplicationLoad();</span>
<span class="source-line-no">1277</span><span id="line-1277">        if (rLoad != null) {</span>
<span class="source-line-no">1278</span><span id="line-1278">          serverLoad.setReplLoadSink(rLoad.getReplicationLoadSink());</span>
<span class="source-line-no">1279</span><span id="line-1279">        }</span>
<span class="source-line-no">1280</span><span id="line-1280">      }</span>
<span class="source-line-no">1281</span><span id="line-1281">    }</span>
<span class="source-line-no">1282</span><span id="line-1282"></span>
<span class="source-line-no">1283</span><span id="line-1283">    TaskMonitor.get().getTasks().forEach(task -&gt; serverLoad.addTasks(ClusterStatusProtos.ServerTask</span>
<span class="source-line-no">1284</span><span id="line-1284">      .newBuilder().setDescription(task.getDescription())</span>
<span class="source-line-no">1285</span><span id="line-1285">      .setStatus(task.getStatus() != null ? task.getStatus() : "")</span>
<span class="source-line-no">1286</span><span id="line-1286">      .setState(ClusterStatusProtos.ServerTask.State.valueOf(task.getState().name()))</span>
<span class="source-line-no">1287</span><span id="line-1287">      .setStartTime(task.getStartTime()).setCompletionTime(task.getCompletionTimestamp()).build()));</span>
<span class="source-line-no">1288</span><span id="line-1288"></span>
<span class="source-line-no">1289</span><span id="line-1289">    return serverLoad.build();</span>
<span class="source-line-no">1290</span><span id="line-1290">  }</span>
<span class="source-line-no">1291</span><span id="line-1291"></span>
<span class="source-line-no">1292</span><span id="line-1292">  private String getOnlineRegionsAsPrintableString() {</span>
<span class="source-line-no">1293</span><span id="line-1293">    StringBuilder sb = new StringBuilder();</span>
<span class="source-line-no">1294</span><span id="line-1294">    for (Region r : this.onlineRegions.values()) {</span>
<span class="source-line-no">1295</span><span id="line-1295">      if (sb.length() &gt; 0) {</span>
<span class="source-line-no">1296</span><span id="line-1296">        sb.append(", ");</span>
<span class="source-line-no">1297</span><span id="line-1297">      }</span>
<span class="source-line-no">1298</span><span id="line-1298">      sb.append(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">1299</span><span id="line-1299">    }</span>
<span class="source-line-no">1300</span><span id="line-1300">    return sb.toString();</span>
<span class="source-line-no">1301</span><span id="line-1301">  }</span>
<span class="source-line-no">1302</span><span id="line-1302"></span>
<span class="source-line-no">1303</span><span id="line-1303">  /**</span>
<span class="source-line-no">1304</span><span id="line-1304">   * Wait on regions close.</span>
<span class="source-line-no">1305</span><span id="line-1305">   */</span>
<span class="source-line-no">1306</span><span id="line-1306">  private void waitOnAllRegionsToClose(final boolean abort) {</span>
<span class="source-line-no">1307</span><span id="line-1307">    // Wait till all regions are closed before going out.</span>
<span class="source-line-no">1308</span><span id="line-1308">    int lastCount = -1;</span>
<span class="source-line-no">1309</span><span id="line-1309">    long previousLogTime = 0;</span>
<span class="source-line-no">1310</span><span id="line-1310">    Set&lt;String&gt; closedRegions = new HashSet&lt;&gt;();</span>
<span class="source-line-no">1311</span><span id="line-1311">    boolean interrupted = false;</span>
<span class="source-line-no">1312</span><span id="line-1312">    try {</span>
<span class="source-line-no">1313</span><span id="line-1313">      while (!onlineRegions.isEmpty()) {</span>
<span class="source-line-no">1314</span><span id="line-1314">        int count = getNumberOfOnlineRegions();</span>
<span class="source-line-no">1315</span><span id="line-1315">        // Only print a message if the count of regions has changed.</span>
<span class="source-line-no">1316</span><span id="line-1316">        if (count != lastCount) {</span>
<span class="source-line-no">1317</span><span id="line-1317">          // Log every second at most</span>
<span class="source-line-no">1318</span><span id="line-1318">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">1319</span><span id="line-1319">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">1320</span><span id="line-1320">            lastCount = count;</span>
<span class="source-line-no">1321</span><span id="line-1321">            LOG.info("Waiting on " + count + " regions to close");</span>
<span class="source-line-no">1322</span><span id="line-1322">            // Only print out regions still closing if a small number else will</span>
<span class="source-line-no">1323</span><span id="line-1323">            // swamp the log.</span>
<span class="source-line-no">1324</span><span id="line-1324">            if (count &lt; 10 &amp;&amp; LOG.isDebugEnabled()) {</span>
<span class="source-line-no">1325</span><span id="line-1325">              LOG.debug("Online Regions=" + this.onlineRegions);</span>
<span class="source-line-no">1326</span><span id="line-1326">            }</span>
<span class="source-line-no">1327</span><span id="line-1327">          }</span>
<span class="source-line-no">1328</span><span id="line-1328">        }</span>
<span class="source-line-no">1329</span><span id="line-1329">        // Ensure all user regions have been sent a close. Use this to</span>
<span class="source-line-no">1330</span><span id="line-1330">        // protect against the case where an open comes in after we start the</span>
<span class="source-line-no">1331</span><span id="line-1331">        // iterator of onlineRegions to close all user regions.</span>
<span class="source-line-no">1332</span><span id="line-1332">        for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">1333</span><span id="line-1333">          RegionInfo hri = e.getValue().getRegionInfo();</span>
<span class="source-line-no">1334</span><span id="line-1334">          if (</span>
<span class="source-line-no">1335</span><span id="line-1335">            !this.regionsInTransitionInRS.containsKey(hri.getEncodedNameAsBytes())</span>
<span class="source-line-no">1336</span><span id="line-1336">              &amp;&amp; !closedRegions.contains(hri.getEncodedName())</span>
<span class="source-line-no">1337</span><span id="line-1337">          ) {</span>
<span class="source-line-no">1338</span><span id="line-1338">            closedRegions.add(hri.getEncodedName());</span>
<span class="source-line-no">1339</span><span id="line-1339">            // Don't update zk with this close transition; pass false.</span>
<span class="source-line-no">1340</span><span id="line-1340">            closeRegionIgnoreErrors(hri, abort);</span>
<span class="source-line-no">1341</span><span id="line-1341">          }</span>
<span class="source-line-no">1342</span><span id="line-1342">        }</span>
<span class="source-line-no">1343</span><span id="line-1343">        // No regions in RIT, we could stop waiting now.</span>
<span class="source-line-no">1344</span><span id="line-1344">        if (this.regionsInTransitionInRS.isEmpty()) {</span>
<span class="source-line-no">1345</span><span id="line-1345">          if (!onlineRegions.isEmpty()) {</span>
<span class="source-line-no">1346</span><span id="line-1346">            LOG.info("We were exiting though online regions are not empty,"</span>
<span class="source-line-no">1347</span><span id="line-1347">              + " because some regions failed closing");</span>
<span class="source-line-no">1348</span><span id="line-1348">          }</span>
<span class="source-line-no">1349</span><span id="line-1349">          break;</span>
<span class="source-line-no">1350</span><span id="line-1350">        } else {</span>
<span class="source-line-no">1351</span><span id="line-1351">          LOG.debug("Waiting on {}", this.regionsInTransitionInRS.keySet().stream()</span>
<span class="source-line-no">1352</span><span id="line-1352">            .map(e -&gt; Bytes.toString(e)).collect(Collectors.joining(", ")));</span>
<span class="source-line-no">1353</span><span id="line-1353">        }</span>
<span class="source-line-no">1354</span><span id="line-1354">        if (sleepInterrupted(200)) {</span>
<span class="source-line-no">1355</span><span id="line-1355">          interrupted = true;</span>
<span class="source-line-no">1356</span><span id="line-1356">        }</span>
<span class="source-line-no">1357</span><span id="line-1357">      }</span>
<span class="source-line-no">1358</span><span id="line-1358">    } finally {</span>
<span class="source-line-no">1359</span><span id="line-1359">      if (interrupted) {</span>
<span class="source-line-no">1360</span><span id="line-1360">        Thread.currentThread().interrupt();</span>
<span class="source-line-no">1361</span><span id="line-1361">      }</span>
<span class="source-line-no">1362</span><span id="line-1362">    }</span>
<span class="source-line-no">1363</span><span id="line-1363">  }</span>
<span class="source-line-no">1364</span><span id="line-1364"></span>
<span class="source-line-no">1365</span><span id="line-1365">  private static boolean sleepInterrupted(long millis) {</span>
<span class="source-line-no">1366</span><span id="line-1366">    boolean interrupted = false;</span>
<span class="source-line-no">1367</span><span id="line-1367">    try {</span>
<span class="source-line-no">1368</span><span id="line-1368">      Thread.sleep(millis);</span>
<span class="source-line-no">1369</span><span id="line-1369">    } catch (InterruptedException e) {</span>
<span class="source-line-no">1370</span><span id="line-1370">      LOG.warn("Interrupted while sleeping");</span>
<span class="source-line-no">1371</span><span id="line-1371">      interrupted = true;</span>
<span class="source-line-no">1372</span><span id="line-1372">    }</span>
<span class="source-line-no">1373</span><span id="line-1373">    return interrupted;</span>
<span class="source-line-no">1374</span><span id="line-1374">  }</span>
<span class="source-line-no">1375</span><span id="line-1375"></span>
<span class="source-line-no">1376</span><span id="line-1376">  private void shutdownWAL(final boolean close) {</span>
<span class="source-line-no">1377</span><span id="line-1377">    if (this.walFactory != null) {</span>
<span class="source-line-no">1378</span><span id="line-1378">      try {</span>
<span class="source-line-no">1379</span><span id="line-1379">        if (close) {</span>
<span class="source-line-no">1380</span><span id="line-1380">          walFactory.close();</span>
<span class="source-line-no">1381</span><span id="line-1381">        } else {</span>
<span class="source-line-no">1382</span><span id="line-1382">          walFactory.shutdown();</span>
<span class="source-line-no">1383</span><span id="line-1383">        }</span>
<span class="source-line-no">1384</span><span id="line-1384">      } catch (Throwable e) {</span>
<span class="source-line-no">1385</span><span id="line-1385">        e = e instanceof RemoteException ? ((RemoteException) e).unwrapRemoteException() : e;</span>
<span class="source-line-no">1386</span><span id="line-1386">        LOG.error("Shutdown / close of WAL failed: " + e);</span>
<span class="source-line-no">1387</span><span id="line-1387">        LOG.debug("Shutdown / close exception details:", e);</span>
<span class="source-line-no">1388</span><span id="line-1388">      }</span>
<span class="source-line-no">1389</span><span id="line-1389">    }</span>
<span class="source-line-no">1390</span><span id="line-1390">  }</span>
<span class="source-line-no">1391</span><span id="line-1391"></span>
<span class="source-line-no">1392</span><span id="line-1392">  /**</span>
<span class="source-line-no">1393</span><span id="line-1393">   * Run init. Sets up wal and starts up all server threads.</span>
<span class="source-line-no">1394</span><span id="line-1394">   * @param c Extra configuration.</span>
<span class="source-line-no">1395</span><span id="line-1395">   */</span>
<span class="source-line-no">1396</span><span id="line-1396">  protected void handleReportForDutyResponse(final RegionServerStartupResponse c)</span>
<span class="source-line-no">1397</span><span id="line-1397">    throws IOException {</span>
<span class="source-line-no">1398</span><span id="line-1398">    try {</span>
<span class="source-line-no">1399</span><span id="line-1399">      boolean updateRootDir = false;</span>
<span class="source-line-no">1400</span><span id="line-1400">      for (NameStringPair e : c.getMapEntriesList()) {</span>
<span class="source-line-no">1401</span><span id="line-1401">        String key = e.getName();</span>
<span class="source-line-no">1402</span><span id="line-1402">        // The hostname the master sees us as.</span>
<span class="source-line-no">1403</span><span id="line-1403">        if (key.equals(HConstants.KEY_FOR_HOSTNAME_SEEN_BY_MASTER)) {</span>
<span class="source-line-no">1404</span><span id="line-1404">          String hostnameFromMasterPOV = e.getValue();</span>
<span class="source-line-no">1405</span><span id="line-1405">          this.serverName = ServerName.valueOf(hostnameFromMasterPOV,</span>
<span class="source-line-no">1406</span><span id="line-1406">            rpcServices.getSocketAddress().getPort(), this.startcode);</span>
<span class="source-line-no">1407</span><span id="line-1407">          String expectedHostName = rpcServices.getSocketAddress().getHostName();</span>
<span class="source-line-no">1408</span><span id="line-1408">          // if Master use-ip is enabled, RegionServer use-ip will be enabled by default even if it</span>
<span class="source-line-no">1409</span><span id="line-1409">          // is set to disable. so we will use the ip of the RegionServer to compare with the</span>
<span class="source-line-no">1410</span><span id="line-1410">          // hostname passed by the Master, see HBASE-27304 for details.</span>
<span class="source-line-no">1411</span><span id="line-1411">          if (</span>
<span class="source-line-no">1412</span><span id="line-1412">            StringUtils.isBlank(useThisHostnameInstead) &amp;&amp; getActiveMaster().isPresent()</span>
<span class="source-line-no">1413</span><span id="line-1413">              &amp;&amp; InetAddresses.isInetAddress(getActiveMaster().get().getHostname())</span>
<span class="source-line-no">1414</span><span id="line-1414">          ) {</span>
<span class="source-line-no">1415</span><span id="line-1415">            expectedHostName = rpcServices.getSocketAddress().getAddress().getHostAddress();</span>
<span class="source-line-no">1416</span><span id="line-1416">          }</span>
<span class="source-line-no">1417</span><span id="line-1417">          boolean isHostnameConsist = StringUtils.isBlank(useThisHostnameInstead)</span>
<span class="source-line-no">1418</span><span id="line-1418">            ? hostnameFromMasterPOV.equals(expectedHostName)</span>
<span class="source-line-no">1419</span><span id="line-1419">            : hostnameFromMasterPOV.equals(useThisHostnameInstead);</span>
<span class="source-line-no">1420</span><span id="line-1420">          if (!isHostnameConsist) {</span>
<span class="source-line-no">1421</span><span id="line-1421">            String msg = "Master passed us a different hostname to use; was="</span>
<span class="source-line-no">1422</span><span id="line-1422">              + (StringUtils.isBlank(useThisHostnameInstead)</span>
<span class="source-line-no">1423</span><span id="line-1423">                ? rpcServices.getSocketAddress().getHostName()</span>
<span class="source-line-no">1424</span><span id="line-1424">                : this.useThisHostnameInstead)</span>
<span class="source-line-no">1425</span><span id="line-1425">              + ", but now=" + hostnameFromMasterPOV;</span>
<span class="source-line-no">1426</span><span id="line-1426">            LOG.error(msg);</span>
<span class="source-line-no">1427</span><span id="line-1427">            throw new IOException(msg);</span>
<span class="source-line-no">1428</span><span id="line-1428">          }</span>
<span class="source-line-no">1429</span><span id="line-1429">          continue;</span>
<span class="source-line-no">1430</span><span id="line-1430">        }</span>
<span class="source-line-no">1431</span><span id="line-1431"></span>
<span class="source-line-no">1432</span><span id="line-1432">        String value = e.getValue();</span>
<span class="source-line-no">1433</span><span id="line-1433">        if (key.equals(HConstants.HBASE_DIR)) {</span>
<span class="source-line-no">1434</span><span id="line-1434">          if (value != null &amp;&amp; !value.equals(conf.get(HConstants.HBASE_DIR))) {</span>
<span class="source-line-no">1435</span><span id="line-1435">            updateRootDir = true;</span>
<span class="source-line-no">1436</span><span id="line-1436">          }</span>
<span class="source-line-no">1437</span><span id="line-1437">        }</span>
<span class="source-line-no">1438</span><span id="line-1438"></span>
<span class="source-line-no">1439</span><span id="line-1439">        if (LOG.isDebugEnabled()) {</span>
<span class="source-line-no">1440</span><span id="line-1440">          LOG.debug("Config from master: " + key + "=" + value);</span>
<span class="source-line-no">1441</span><span id="line-1441">        }</span>
<span class="source-line-no">1442</span><span id="line-1442">        this.conf.set(key, value);</span>
<span class="source-line-no">1443</span><span id="line-1443">      }</span>
<span class="source-line-no">1444</span><span id="line-1444">      // Set our ephemeral znode up in zookeeper now we have a name.</span>
<span class="source-line-no">1445</span><span id="line-1445">      createMyEphemeralNode();</span>
<span class="source-line-no">1446</span><span id="line-1446"></span>
<span class="source-line-no">1447</span><span id="line-1447">      if (updateRootDir) {</span>
<span class="source-line-no">1448</span><span id="line-1448">        // initialize file system by the config fs.defaultFS and hbase.rootdir from master</span>
<span class="source-line-no">1449</span><span id="line-1449">        initializeFileSystem();</span>
<span class="source-line-no">1450</span><span id="line-1450">      }</span>
<span class="source-line-no">1451</span><span id="line-1451"></span>
<span class="source-line-no">1452</span><span id="line-1452">      // hack! Maps DFSClient =&gt; RegionServer for logs. HDFS made this</span>
<span class="source-line-no">1453</span><span id="line-1453">      // config param for task trackers, but we can piggyback off of it.</span>
<span class="source-line-no">1454</span><span id="line-1454">      if (this.conf.get("mapreduce.task.attempt.id") == null) {</span>
<span class="source-line-no">1455</span><span id="line-1455">        this.conf.set("mapreduce.task.attempt.id", "hb_rs_" + this.serverName.toString());</span>
<span class="source-line-no">1456</span><span id="line-1456">      }</span>
<span class="source-line-no">1457</span><span id="line-1457"></span>
<span class="source-line-no">1458</span><span id="line-1458">      // Save it in a file, this will allow to see if we crash</span>
<span class="source-line-no">1459</span><span id="line-1459">      ZNodeClearer.writeMyEphemeralNodeOnDisk(getMyEphemeralNodePath());</span>
<span class="source-line-no">1460</span><span id="line-1460"></span>
<span class="source-line-no">1461</span><span id="line-1461">      // This call sets up an initialized replication and WAL. Later we start it up.</span>
<span class="source-line-no">1462</span><span id="line-1462">      setupWALAndReplication();</span>
<span class="source-line-no">1463</span><span id="line-1463">      // Init in here rather than in constructor after thread name has been set</span>
<span class="source-line-no">1464</span><span id="line-1464">      final MetricsTable metricsTable =</span>
<span class="source-line-no">1465</span><span id="line-1465">        new MetricsTable(new MetricsTableWrapperAggregateImpl(this));</span>
<span class="source-line-no">1466</span><span id="line-1466">      this.metricsRegionServerImpl = new MetricsRegionServerWrapperImpl(this);</span>
<span class="source-line-no">1467</span><span id="line-1467">      this.metricsRegionServer =</span>
<span class="source-line-no">1468</span><span id="line-1468">        new MetricsRegionServer(metricsRegionServerImpl, conf, metricsTable);</span>
<span class="source-line-no">1469</span><span id="line-1469">      // Now that we have a metrics source, start the pause monitor</span>
<span class="source-line-no">1470</span><span id="line-1470">      this.pauseMonitor = new JvmPauseMonitor(conf, getMetrics().getMetricsSource());</span>
<span class="source-line-no">1471</span><span id="line-1471">      pauseMonitor.start();</span>
<span class="source-line-no">1472</span><span id="line-1472"></span>
<span class="source-line-no">1473</span><span id="line-1473">      // There is a rare case where we do NOT want services to start. Check config.</span>
<span class="source-line-no">1474</span><span id="line-1474">      if (getConfiguration().getBoolean("hbase.regionserver.workers", true)) {</span>
<span class="source-line-no">1475</span><span id="line-1475">        startServices();</span>
<span class="source-line-no">1476</span><span id="line-1476">      }</span>
<span class="source-line-no">1477</span><span id="line-1477">      // In here we start up the replication Service. Above we initialized it. TODO. Reconcile.</span>
<span class="source-line-no">1478</span><span id="line-1478">      // or make sense of it.</span>
<span class="source-line-no">1479</span><span id="line-1479">      startReplicationService();</span>
<span class="source-line-no">1480</span><span id="line-1480"></span>
<span class="source-line-no">1481</span><span id="line-1481">      // Set up ZK</span>
<span class="source-line-no">1482</span><span id="line-1482">      LOG.info("Serving as " + this.serverName + ", RpcServer on " + rpcServices.getSocketAddress()</span>
<span class="source-line-no">1483</span><span id="line-1483">        + ", sessionid=0x"</span>
<span class="source-line-no">1484</span><span id="line-1484">        + Long.toHexString(this.zooKeeper.getRecoverableZooKeeper().getSessionId()));</span>
<span class="source-line-no">1485</span><span id="line-1485"></span>
<span class="source-line-no">1486</span><span id="line-1486">      // Wake up anyone waiting for this server to online</span>
<span class="source-line-no">1487</span><span id="line-1487">      synchronized (online) {</span>
<span class="source-line-no">1488</span><span id="line-1488">        online.set(true);</span>
<span class="source-line-no">1489</span><span id="line-1489">        online.notifyAll();</span>
<span class="source-line-no">1490</span><span id="line-1490">      }</span>
<span class="source-line-no">1491</span><span id="line-1491">    } catch (Throwable e) {</span>
<span class="source-line-no">1492</span><span id="line-1492">      stop("Failed initialization");</span>
<span class="source-line-no">1493</span><span id="line-1493">      throw convertThrowableToIOE(cleanup(e, "Failed init"), "Region server startup failed");</span>
<span class="source-line-no">1494</span><span id="line-1494">    } finally {</span>
<span class="source-line-no">1495</span><span id="line-1495">      sleeper.skipSleepCycle();</span>
<span class="source-line-no">1496</span><span id="line-1496">    }</span>
<span class="source-line-no">1497</span><span id="line-1497">  }</span>
<span class="source-line-no">1498</span><span id="line-1498"></span>
<span class="source-line-no">1499</span><span id="line-1499">  private void startHeapMemoryManager() {</span>
<span class="source-line-no">1500</span><span id="line-1500">    if (this.blockCache != null) {</span>
<span class="source-line-no">1501</span><span id="line-1501">      this.hMemManager =</span>
<span class="source-line-no">1502</span><span id="line-1502">        new HeapMemoryManager(this.blockCache, this.cacheFlusher, this, regionServerAccounting);</span>
<span class="source-line-no">1503</span><span id="line-1503">      this.hMemManager.start(getChoreService());</span>
<span class="source-line-no">1504</span><span id="line-1504">    }</span>
<span class="source-line-no">1505</span><span id="line-1505">  }</span>
<span class="source-line-no">1506</span><span id="line-1506"></span>
<span class="source-line-no">1507</span><span id="line-1507">  private void createMyEphemeralNode() throws KeeperException {</span>
<span class="source-line-no">1508</span><span id="line-1508">    RegionServerInfo.Builder rsInfo = RegionServerInfo.newBuilder();</span>
<span class="source-line-no">1509</span><span id="line-1509">    rsInfo.setInfoPort(infoServer != null ? infoServer.getPort() : -1);</span>
<span class="source-line-no">1510</span><span id="line-1510">    rsInfo.setVersionInfo(ProtobufUtil.getVersionInfo());</span>
<span class="source-line-no">1511</span><span id="line-1511">    byte[] data = ProtobufUtil.prependPBMagic(rsInfo.build().toByteArray());</span>
<span class="source-line-no">1512</span><span id="line-1512">    ZKUtil.createEphemeralNodeAndWatch(this.zooKeeper, getMyEphemeralNodePath(), data);</span>
<span class="source-line-no">1513</span><span id="line-1513">  }</span>
<span class="source-line-no">1514</span><span id="line-1514"></span>
<span class="source-line-no">1515</span><span id="line-1515">  private void deleteMyEphemeralNode() throws KeeperException {</span>
<span class="source-line-no">1516</span><span id="line-1516">    ZKUtil.deleteNode(this.zooKeeper, getMyEphemeralNodePath());</span>
<span class="source-line-no">1517</span><span id="line-1517">  }</span>
<span class="source-line-no">1518</span><span id="line-1518"></span>
<span class="source-line-no">1519</span><span id="line-1519">  @Override</span>
<span class="source-line-no">1520</span><span id="line-1520">  public RegionServerAccounting getRegionServerAccounting() {</span>
<span class="source-line-no">1521</span><span id="line-1521">    return regionServerAccounting;</span>
<span class="source-line-no">1522</span><span id="line-1522">  }</span>
<span class="source-line-no">1523</span><span id="line-1523"></span>
<span class="source-line-no">1524</span><span id="line-1524">  // Round the size with KB or MB.</span>
<span class="source-line-no">1525</span><span id="line-1525">  // A trick here is that if the sizeInBytes is less than sizeUnit, we will round the size to 1</span>
<span class="source-line-no">1526</span><span id="line-1526">  // instead of 0 if it is not 0, to avoid some schedulers think the region has no data. See</span>
<span class="source-line-no">1527</span><span id="line-1527">  // HBASE-26340 for more details on why this is important.</span>
<span class="source-line-no">1528</span><span id="line-1528">  private static int roundSize(long sizeInByte, int sizeUnit) {</span>
<span class="source-line-no">1529</span><span id="line-1529">    if (sizeInByte == 0) {</span>
<span class="source-line-no">1530</span><span id="line-1530">      return 0;</span>
<span class="source-line-no">1531</span><span id="line-1531">    } else if (sizeInByte &lt; sizeUnit) {</span>
<span class="source-line-no">1532</span><span id="line-1532">      return 1;</span>
<span class="source-line-no">1533</span><span id="line-1533">    } else {</span>
<span class="source-line-no">1534</span><span id="line-1534">      return (int) Math.min(sizeInByte / sizeUnit, Integer.MAX_VALUE);</span>
<span class="source-line-no">1535</span><span id="line-1535">    }</span>
<span class="source-line-no">1536</span><span id="line-1536">  }</span>
<span class="source-line-no">1537</span><span id="line-1537"></span>
<span class="source-line-no">1538</span><span id="line-1538">  private void computeIfPersistentBucketCache(Consumer&lt;BucketCache&gt; computation) {</span>
<span class="source-line-no">1539</span><span id="line-1539">    if (blockCache instanceof CombinedBlockCache) {</span>
<span class="source-line-no">1540</span><span id="line-1540">      BlockCache l2 = ((CombinedBlockCache) blockCache).getSecondLevelCache();</span>
<span class="source-line-no">1541</span><span id="line-1541">      if (l2 instanceof BucketCache &amp;&amp; ((BucketCache) l2).isCachePersistent()) {</span>
<span class="source-line-no">1542</span><span id="line-1542">        computation.accept((BucketCache) l2);</span>
<span class="source-line-no">1543</span><span id="line-1543">      }</span>
<span class="source-line-no">1544</span><span id="line-1544">    }</span>
<span class="source-line-no">1545</span><span id="line-1545">  }</span>
<span class="source-line-no">1546</span><span id="line-1546"></span>
<span class="source-line-no">1547</span><span id="line-1547">  /**</span>
<span class="source-line-no">1548</span><span id="line-1548">   * @param r               Region to get RegionLoad for.</span>
<span class="source-line-no">1549</span><span id="line-1549">   * @param regionLoadBldr  the RegionLoad.Builder, can be null</span>
<span class="source-line-no">1550</span><span id="line-1550">   * @param regionSpecifier the RegionSpecifier.Builder, can be null</span>
<span class="source-line-no">1551</span><span id="line-1551">   * @return RegionLoad instance.</span>
<span class="source-line-no">1552</span><span id="line-1552">   */</span>
<span class="source-line-no">1553</span><span id="line-1553">  RegionLoad createRegionLoad(final HRegion r, RegionLoad.Builder regionLoadBldr,</span>
<span class="source-line-no">1554</span><span id="line-1554">    RegionSpecifier.Builder regionSpecifier) throws IOException {</span>
<span class="source-line-no">1555</span><span id="line-1555">    byte[] name = r.getRegionInfo().getRegionName();</span>
<span class="source-line-no">1556</span><span id="line-1556">    String regionEncodedName = r.getRegionInfo().getEncodedName();</span>
<span class="source-line-no">1557</span><span id="line-1557">    int stores = 0;</span>
<span class="source-line-no">1558</span><span id="line-1558">    int storefiles = 0;</span>
<span class="source-line-no">1559</span><span id="line-1559">    int storeRefCount = 0;</span>
<span class="source-line-no">1560</span><span id="line-1560">    int maxCompactedStoreFileRefCount = 0;</span>
<span class="source-line-no">1561</span><span id="line-1561">    long storeUncompressedSize = 0L;</span>
<span class="source-line-no">1562</span><span id="line-1562">    long storefileSize = 0L;</span>
<span class="source-line-no">1563</span><span id="line-1563">    long storefileIndexSize = 0L;</span>
<span class="source-line-no">1564</span><span id="line-1564">    long rootLevelIndexSize = 0L;</span>
<span class="source-line-no">1565</span><span id="line-1565">    long totalStaticIndexSize = 0L;</span>
<span class="source-line-no">1566</span><span id="line-1566">    long totalStaticBloomSize = 0L;</span>
<span class="source-line-no">1567</span><span id="line-1567">    long totalCompactingKVs = 0L;</span>
<span class="source-line-no">1568</span><span id="line-1568">    long currentCompactedKVs = 0L;</span>
<span class="source-line-no">1569</span><span id="line-1569">    long totalRegionSize = 0L;</span>
<span class="source-line-no">1570</span><span id="line-1570">    List&lt;HStore&gt; storeList = r.getStores();</span>
<span class="source-line-no">1571</span><span id="line-1571">    stores += storeList.size();</span>
<span class="source-line-no">1572</span><span id="line-1572">    for (HStore store : storeList) {</span>
<span class="source-line-no">1573</span><span id="line-1573">      storefiles += store.getStorefilesCount();</span>
<span class="source-line-no">1574</span><span id="line-1574">      int currentStoreRefCount = store.getStoreRefCount();</span>
<span class="source-line-no">1575</span><span id="line-1575">      storeRefCount += currentStoreRefCount;</span>
<span class="source-line-no">1576</span><span id="line-1576">      int currentMaxCompactedStoreFileRefCount = store.getMaxCompactedStoreFileRefCount();</span>
<span class="source-line-no">1577</span><span id="line-1577">      maxCompactedStoreFileRefCount =</span>
<span class="source-line-no">1578</span><span id="line-1578">        Math.max(maxCompactedStoreFileRefCount, currentMaxCompactedStoreFileRefCount);</span>
<span class="source-line-no">1579</span><span id="line-1579">      storeUncompressedSize += store.getStoreSizeUncompressed();</span>
<span class="source-line-no">1580</span><span id="line-1580">      storefileSize += store.getStorefilesSize();</span>
<span class="source-line-no">1581</span><span id="line-1581">      totalRegionSize += store.getHFilesSize();</span>
<span class="source-line-no">1582</span><span id="line-1582">      // TODO: storefileIndexSizeKB is same with rootLevelIndexSizeKB?</span>
<span class="source-line-no">1583</span><span id="line-1583">      storefileIndexSize += store.getStorefilesRootLevelIndexSize();</span>
<span class="source-line-no">1584</span><span id="line-1584">      CompactionProgress progress = store.getCompactionProgress();</span>
<span class="source-line-no">1585</span><span id="line-1585">      if (progress != null) {</span>
<span class="source-line-no">1586</span><span id="line-1586">        totalCompactingKVs += progress.getTotalCompactingKVs();</span>
<span class="source-line-no">1587</span><span id="line-1587">        currentCompactedKVs += progress.currentCompactedKVs;</span>
<span class="source-line-no">1588</span><span id="line-1588">      }</span>
<span class="source-line-no">1589</span><span id="line-1589">      rootLevelIndexSize += store.getStorefilesRootLevelIndexSize();</span>
<span class="source-line-no">1590</span><span id="line-1590">      totalStaticIndexSize += store.getTotalStaticIndexSize();</span>
<span class="source-line-no">1591</span><span id="line-1591">      totalStaticBloomSize += store.getTotalStaticBloomSize();</span>
<span class="source-line-no">1592</span><span id="line-1592">    }</span>
<span class="source-line-no">1593</span><span id="line-1593"></span>
<span class="source-line-no">1594</span><span id="line-1594">    int memstoreSizeMB = roundSize(r.getMemStoreDataSize(), unitMB);</span>
<span class="source-line-no">1595</span><span id="line-1595">    int storeUncompressedSizeMB = roundSize(storeUncompressedSize, unitMB);</span>
<span class="source-line-no">1596</span><span id="line-1596">    int storefileSizeMB = roundSize(storefileSize, unitMB);</span>
<span class="source-line-no">1597</span><span id="line-1597">    int storefileIndexSizeKB = roundSize(storefileIndexSize, unitKB);</span>
<span class="source-line-no">1598</span><span id="line-1598">    int rootLevelIndexSizeKB = roundSize(rootLevelIndexSize, unitKB);</span>
<span class="source-line-no">1599</span><span id="line-1599">    int totalStaticIndexSizeKB = roundSize(totalStaticIndexSize, unitKB);</span>
<span class="source-line-no">1600</span><span id="line-1600">    int totalStaticBloomSizeKB = roundSize(totalStaticBloomSize, unitKB);</span>
<span class="source-line-no">1601</span><span id="line-1601">    int regionSizeMB = roundSize(totalRegionSize, unitMB);</span>
<span class="source-line-no">1602</span><span id="line-1602">    final MutableFloat currentRegionCachedRatio = new MutableFloat(0.0f);</span>
<span class="source-line-no">1603</span><span id="line-1603">    getBlockCache().ifPresent(bc -&gt; {</span>
<span class="source-line-no">1604</span><span id="line-1604">      bc.getRegionCachedInfo().ifPresent(regionCachedInfo -&gt; {</span>
<span class="source-line-no">1605</span><span id="line-1605">        if (regionCachedInfo.containsKey(regionEncodedName)) {</span>
<span class="source-line-no">1606</span><span id="line-1606">          currentRegionCachedRatio.setValue(regionSizeMB == 0</span>
<span class="source-line-no">1607</span><span id="line-1607">            ? 0.0f</span>
<span class="source-line-no">1608</span><span id="line-1608">            : (float) roundSize(regionCachedInfo.get(regionEncodedName), unitMB) / regionSizeMB);</span>
<span class="source-line-no">1609</span><span id="line-1609">        }</span>
<span class="source-line-no">1610</span><span id="line-1610">      });</span>
<span class="source-line-no">1611</span><span id="line-1611">    });</span>
<span class="source-line-no">1612</span><span id="line-1612"></span>
<span class="source-line-no">1613</span><span id="line-1613">    HDFSBlocksDistribution hdfsBd = r.getHDFSBlocksDistribution();</span>
<span class="source-line-no">1614</span><span id="line-1614">    float dataLocality = hdfsBd.getBlockLocalityIndex(serverName.getHostname());</span>
<span class="source-line-no">1615</span><span id="line-1615">    float dataLocalityForSsd = hdfsBd.getBlockLocalityIndexForSsd(serverName.getHostname());</span>
<span class="source-line-no">1616</span><span id="line-1616">    long blocksTotalWeight = hdfsBd.getUniqueBlocksTotalWeight();</span>
<span class="source-line-no">1617</span><span id="line-1617">    long blocksLocalWeight = hdfsBd.getBlocksLocalWeight(serverName.getHostname());</span>
<span class="source-line-no">1618</span><span id="line-1618">    long blocksLocalWithSsdWeight = hdfsBd.getBlocksLocalWithSsdWeight(serverName.getHostname());</span>
<span class="source-line-no">1619</span><span id="line-1619">    if (regionLoadBldr == null) {</span>
<span class="source-line-no">1620</span><span id="line-1620">      regionLoadBldr = RegionLoad.newBuilder();</span>
<span class="source-line-no">1621</span><span id="line-1621">    }</span>
<span class="source-line-no">1622</span><span id="line-1622">    if (regionSpecifier == null) {</span>
<span class="source-line-no">1623</span><span id="line-1623">      regionSpecifier = RegionSpecifier.newBuilder();</span>
<span class="source-line-no">1624</span><span id="line-1624">    }</span>
<span class="source-line-no">1625</span><span id="line-1625"></span>
<span class="source-line-no">1626</span><span id="line-1626">    regionSpecifier.setType(RegionSpecifierType.REGION_NAME);</span>
<span class="source-line-no">1627</span><span id="line-1627">    regionSpecifier.setValue(UnsafeByteOperations.unsafeWrap(name));</span>
<span class="source-line-no">1628</span><span id="line-1628">    regionLoadBldr.setRegionSpecifier(regionSpecifier.build()).setStores(stores)</span>
<span class="source-line-no">1629</span><span id="line-1629">      .setStorefiles(storefiles).setStoreRefCount(storeRefCount)</span>
<span class="source-line-no">1630</span><span id="line-1630">      .setMaxCompactedStoreFileRefCount(maxCompactedStoreFileRefCount)</span>
<span class="source-line-no">1631</span><span id="line-1631">      .setStoreUncompressedSizeMB(storeUncompressedSizeMB).setStorefileSizeMB(storefileSizeMB)</span>
<span class="source-line-no">1632</span><span id="line-1632">      .setMemStoreSizeMB(memstoreSizeMB).setStorefileIndexSizeKB(storefileIndexSizeKB)</span>
<span class="source-line-no">1633</span><span id="line-1633">      .setRootIndexSizeKB(rootLevelIndexSizeKB).setTotalStaticIndexSizeKB(totalStaticIndexSizeKB)</span>
<span class="source-line-no">1634</span><span id="line-1634">      .setTotalStaticBloomSizeKB(totalStaticBloomSizeKB)</span>
<span class="source-line-no">1635</span><span id="line-1635">      .setReadRequestsCount(r.getReadRequestsCount()).setCpRequestsCount(r.getCpRequestsCount())</span>
<span class="source-line-no">1636</span><span id="line-1636">      .setFilteredReadRequestsCount(r.getFilteredReadRequestsCount())</span>
<span class="source-line-no">1637</span><span id="line-1637">      .setWriteRequestsCount(r.getWriteRequestsCount()).setTotalCompactingKVs(totalCompactingKVs)</span>
<span class="source-line-no">1638</span><span id="line-1638">      .setCurrentCompactedKVs(currentCompactedKVs).setDataLocality(dataLocality)</span>
<span class="source-line-no">1639</span><span id="line-1639">      .setDataLocalityForSsd(dataLocalityForSsd).setBlocksLocalWeight(blocksLocalWeight)</span>
<span class="source-line-no">1640</span><span id="line-1640">      .setBlocksLocalWithSsdWeight(blocksLocalWithSsdWeight).setBlocksTotalWeight(blocksTotalWeight)</span>
<span class="source-line-no">1641</span><span id="line-1641">      .setCompactionState(ProtobufUtil.createCompactionStateForRegionLoad(r.getCompactionState()))</span>
<span class="source-line-no">1642</span><span id="line-1642">      .setLastMajorCompactionTs(r.getOldestHfileTs(true)).setRegionSizeMB(regionSizeMB)</span>
<span class="source-line-no">1643</span><span id="line-1643">      .setCurrentRegionCachedRatio(currentRegionCachedRatio.floatValue());</span>
<span class="source-line-no">1644</span><span id="line-1644">    r.setCompleteSequenceId(regionLoadBldr);</span>
<span class="source-line-no">1645</span><span id="line-1645">    return regionLoadBldr.build();</span>
<span class="source-line-no">1646</span><span id="line-1646">  }</span>
<span class="source-line-no">1647</span><span id="line-1647"></span>
<span class="source-line-no">1648</span><span id="line-1648">  private UserLoad createUserLoad(String user, MetricsUserSource userSource) {</span>
<span class="source-line-no">1649</span><span id="line-1649">    UserLoad.Builder userLoadBldr = UserLoad.newBuilder();</span>
<span class="source-line-no">1650</span><span id="line-1650">    userLoadBldr.setUserName(user);</span>
<span class="source-line-no">1651</span><span id="line-1651">    userSource.getClientMetrics().values().stream()</span>
<span class="source-line-no">1652</span><span id="line-1652">      .map(clientMetrics -&gt; ClusterStatusProtos.ClientMetrics.newBuilder()</span>
<span class="source-line-no">1653</span><span id="line-1653">        .setHostName(clientMetrics.getHostName())</span>
<span class="source-line-no">1654</span><span id="line-1654">        .setWriteRequestsCount(clientMetrics.getWriteRequestsCount())</span>
<span class="source-line-no">1655</span><span id="line-1655">        .setFilteredRequestsCount(clientMetrics.getFilteredReadRequests())</span>
<span class="source-line-no">1656</span><span id="line-1656">        .setReadRequestsCount(clientMetrics.getReadRequestsCount()).build())</span>
<span class="source-line-no">1657</span><span id="line-1657">      .forEach(userLoadBldr::addClientMetrics);</span>
<span class="source-line-no">1658</span><span id="line-1658">    return userLoadBldr.build();</span>
<span class="source-line-no">1659</span><span id="line-1659">  }</span>
<span class="source-line-no">1660</span><span id="line-1660"></span>
<span class="source-line-no">1661</span><span id="line-1661">  public RegionLoad createRegionLoad(final String encodedRegionName) throws IOException {</span>
<span class="source-line-no">1662</span><span id="line-1662">    HRegion r = onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">1663</span><span id="line-1663">    return r != null ? createRegionLoad(r, null, null) : null;</span>
<span class="source-line-no">1664</span><span id="line-1664">  }</span>
<span class="source-line-no">1665</span><span id="line-1665"></span>
<span class="source-line-no">1666</span><span id="line-1666">  /**</span>
<span class="source-line-no">1667</span><span id="line-1667">   * Inner class that runs on a long period checking if regions need compaction.</span>
<span class="source-line-no">1668</span><span id="line-1668">   */</span>
<span class="source-line-no">1669</span><span id="line-1669">  private static class CompactionChecker extends ScheduledChore {</span>
<span class="source-line-no">1670</span><span id="line-1670">    private final HRegionServer instance;</span>
<span class="source-line-no">1671</span><span id="line-1671">    private final int majorCompactPriority;</span>
<span class="source-line-no">1672</span><span id="line-1672">    private final static int DEFAULT_PRIORITY = Integer.MAX_VALUE;</span>
<span class="source-line-no">1673</span><span id="line-1673">    // Iteration is 1-based rather than 0-based so we don't check for compaction</span>
<span class="source-line-no">1674</span><span id="line-1674">    // immediately upon region server startup</span>
<span class="source-line-no">1675</span><span id="line-1675">    private long iteration = 1;</span>
<span class="source-line-no">1676</span><span id="line-1676"></span>
<span class="source-line-no">1677</span><span id="line-1677">    CompactionChecker(final HRegionServer h, final int sleepTime, final Stoppable stopper) {</span>
<span class="source-line-no">1678</span><span id="line-1678">      super("CompactionChecker", stopper, sleepTime);</span>
<span class="source-line-no">1679</span><span id="line-1679">      this.instance = h;</span>
<span class="source-line-no">1680</span><span id="line-1680">      LOG.info(this.getName() + " runs every " + Duration.ofMillis(sleepTime));</span>
<span class="source-line-no">1681</span><span id="line-1681"></span>
<span class="source-line-no">1682</span><span id="line-1682">      /*</span>
<span class="source-line-no">1683</span><span id="line-1683">       * MajorCompactPriority is configurable. If not set, the compaction will use default priority.</span>
<span class="source-line-no">1684</span><span id="line-1684">       */</span>
<span class="source-line-no">1685</span><span id="line-1685">      this.majorCompactPriority = this.instance.conf</span>
<span class="source-line-no">1686</span><span id="line-1686">        .getInt("hbase.regionserver.compactionChecker.majorCompactPriority", DEFAULT_PRIORITY);</span>
<span class="source-line-no">1687</span><span id="line-1687">    }</span>
<span class="source-line-no">1688</span><span id="line-1688"></span>
<span class="source-line-no">1689</span><span id="line-1689">    @Override</span>
<span class="source-line-no">1690</span><span id="line-1690">    protected void chore() {</span>
<span class="source-line-no">1691</span><span id="line-1691">      for (HRegion hr : this.instance.onlineRegions.values()) {</span>
<span class="source-line-no">1692</span><span id="line-1692">        // If region is read only or compaction is disabled at table level, there's no need to</span>
<span class="source-line-no">1693</span><span id="line-1693">        // iterate through region's stores</span>
<span class="source-line-no">1694</span><span id="line-1694">        if (hr == null || hr.isReadOnly() || !hr.getTableDescriptor().isCompactionEnabled()) {</span>
<span class="source-line-no">1695</span><span id="line-1695">          continue;</span>
<span class="source-line-no">1696</span><span id="line-1696">        }</span>
<span class="source-line-no">1697</span><span id="line-1697"></span>
<span class="source-line-no">1698</span><span id="line-1698">        for (HStore s : hr.stores.values()) {</span>
<span class="source-line-no">1699</span><span id="line-1699">          try {</span>
<span class="source-line-no">1700</span><span id="line-1700">            long multiplier = s.getCompactionCheckMultiplier();</span>
<span class="source-line-no">1701</span><span id="line-1701">            assert multiplier &gt; 0;</span>
<span class="source-line-no">1702</span><span id="line-1702">            if (iteration % multiplier != 0) {</span>
<span class="source-line-no">1703</span><span id="line-1703">              continue;</span>
<span class="source-line-no">1704</span><span id="line-1704">            }</span>
<span class="source-line-no">1705</span><span id="line-1705">            if (s.needsCompaction()) {</span>
<span class="source-line-no">1706</span><span id="line-1706">              // Queue a compaction. Will recognize if major is needed.</span>
<span class="source-line-no">1707</span><span id="line-1707">              this.instance.compactSplitThread.requestSystemCompaction(hr, s,</span>
<span class="source-line-no">1708</span><span id="line-1708">                getName() + " requests compaction");</span>
<span class="source-line-no">1709</span><span id="line-1709">            } else if (s.shouldPerformMajorCompaction()) {</span>
<span class="source-line-no">1710</span><span id="line-1710">              s.triggerMajorCompaction();</span>
<span class="source-line-no">1711</span><span id="line-1711">              if (</span>
<span class="source-line-no">1712</span><span id="line-1712">                majorCompactPriority == DEFAULT_PRIORITY</span>
<span class="source-line-no">1713</span><span id="line-1713">                  || majorCompactPriority &gt; hr.getCompactPriority()</span>
<span class="source-line-no">1714</span><span id="line-1714">              ) {</span>
<span class="source-line-no">1715</span><span id="line-1715">                this.instance.compactSplitThread.requestCompaction(hr, s,</span>
<span class="source-line-no">1716</span><span id="line-1716">                  getName() + " requests major compaction; use default priority", Store.NO_PRIORITY,</span>
<span class="source-line-no">1717</span><span id="line-1717">                  CompactionLifeCycleTracker.DUMMY, null);</span>
<span class="source-line-no">1718</span><span id="line-1718">              } else {</span>
<span class="source-line-no">1719</span><span id="line-1719">                this.instance.compactSplitThread.requestCompaction(hr, s,</span>
<span class="source-line-no">1720</span><span id="line-1720">                  getName() + " requests major compaction; use configured priority",</span>
<span class="source-line-no">1721</span><span id="line-1721">                  this.majorCompactPriority, CompactionLifeCycleTracker.DUMMY, null);</span>
<span class="source-line-no">1722</span><span id="line-1722">              }</span>
<span class="source-line-no">1723</span><span id="line-1723">            }</span>
<span class="source-line-no">1724</span><span id="line-1724">          } catch (IOException e) {</span>
<span class="source-line-no">1725</span><span id="line-1725">            LOG.warn("Failed major compaction check on " + hr, e);</span>
<span class="source-line-no">1726</span><span id="line-1726">          }</span>
<span class="source-line-no">1727</span><span id="line-1727">        }</span>
<span class="source-line-no">1728</span><span id="line-1728">      }</span>
<span class="source-line-no">1729</span><span id="line-1729">      iteration = (iteration == Long.MAX_VALUE) ? 0 : (iteration + 1);</span>
<span class="source-line-no">1730</span><span id="line-1730">    }</span>
<span class="source-line-no">1731</span><span id="line-1731">  }</span>
<span class="source-line-no">1732</span><span id="line-1732"></span>
<span class="source-line-no">1733</span><span id="line-1733">  private static class PeriodicMemStoreFlusher extends ScheduledChore {</span>
<span class="source-line-no">1734</span><span id="line-1734">    private final HRegionServer server;</span>
<span class="source-line-no">1735</span><span id="line-1735">    private final static int RANGE_OF_DELAY = 5 * 60; // 5 min in seconds</span>
<span class="source-line-no">1736</span><span id="line-1736">    private final static int MIN_DELAY_TIME = 0; // millisec</span>
<span class="source-line-no">1737</span><span id="line-1737">    private final long rangeOfDelayMs;</span>
<span class="source-line-no">1738</span><span id="line-1738"></span>
<span class="source-line-no">1739</span><span id="line-1739">    PeriodicMemStoreFlusher(int cacheFlushInterval, final HRegionServer server) {</span>
<span class="source-line-no">1740</span><span id="line-1740">      super("MemstoreFlusherChore", server, cacheFlushInterval);</span>
<span class="source-line-no">1741</span><span id="line-1741">      this.server = server;</span>
<span class="source-line-no">1742</span><span id="line-1742"></span>
<span class="source-line-no">1743</span><span id="line-1743">      final long configuredRangeOfDelay = server.getConfiguration()</span>
<span class="source-line-no">1744</span><span id="line-1744">        .getInt("hbase.regionserver.periodicmemstoreflusher.rangeofdelayseconds", RANGE_OF_DELAY);</span>
<span class="source-line-no">1745</span><span id="line-1745">      this.rangeOfDelayMs = TimeUnit.SECONDS.toMillis(configuredRangeOfDelay);</span>
<span class="source-line-no">1746</span><span id="line-1746">    }</span>
<span class="source-line-no">1747</span><span id="line-1747"></span>
<span class="source-line-no">1748</span><span id="line-1748">    @Override</span>
<span class="source-line-no">1749</span><span id="line-1749">    protected void chore() {</span>
<span class="source-line-no">1750</span><span id="line-1750">      final StringBuilder whyFlush = new StringBuilder();</span>
<span class="source-line-no">1751</span><span id="line-1751">      for (HRegion r : this.server.onlineRegions.values()) {</span>
<span class="source-line-no">1752</span><span id="line-1752">        if (r == null) {</span>
<span class="source-line-no">1753</span><span id="line-1753">          continue;</span>
<span class="source-line-no">1754</span><span id="line-1754">        }</span>
<span class="source-line-no">1755</span><span id="line-1755">        if (r.shouldFlush(whyFlush)) {</span>
<span class="source-line-no">1756</span><span id="line-1756">          FlushRequester requester = server.getFlushRequester();</span>
<span class="source-line-no">1757</span><span id="line-1757">          if (requester != null) {</span>
<span class="source-line-no">1758</span><span id="line-1758">            long delay = ThreadLocalRandom.current().nextLong(rangeOfDelayMs) + MIN_DELAY_TIME;</span>
<span class="source-line-no">1759</span><span id="line-1759">            // Throttle the flushes by putting a delay. If we don't throttle, and there</span>
<span class="source-line-no">1760</span><span id="line-1760">            // is a balanced write-load on the regions in a table, we might end up</span>
<span class="source-line-no">1761</span><span id="line-1761">            // overwhelming the filesystem with too many flushes at once.</span>
<span class="source-line-no">1762</span><span id="line-1762">            if (requester.requestDelayedFlush(r, delay)) {</span>
<span class="source-line-no">1763</span><span id="line-1763">              LOG.info("{} requesting flush of {} because {} after random delay {} ms", getName(),</span>
<span class="source-line-no">1764</span><span id="line-1764">                r.getRegionInfo().getRegionNameAsString(), whyFlush.toString(), delay);</span>
<span class="source-line-no">1765</span><span id="line-1765">            }</span>
<span class="source-line-no">1766</span><span id="line-1766">          }</span>
<span class="source-line-no">1767</span><span id="line-1767">        }</span>
<span class="source-line-no">1768</span><span id="line-1768">      }</span>
<span class="source-line-no">1769</span><span id="line-1769">    }</span>
<span class="source-line-no">1770</span><span id="line-1770">  }</span>
<span class="source-line-no">1771</span><span id="line-1771"></span>
<span class="source-line-no">1772</span><span id="line-1772">  /**</span>
<span class="source-line-no">1773</span><span id="line-1773">   * Report the status of the server. A server is online once all the startup is completed (setting</span>
<span class="source-line-no">1774</span><span id="line-1774">   * up filesystem, starting executorService threads, etc.). This method is designed mostly to be</span>
<span class="source-line-no">1775</span><span id="line-1775">   * useful in tests.</span>
<span class="source-line-no">1776</span><span id="line-1776">   * @return true if online, false if not.</span>
<span class="source-line-no">1777</span><span id="line-1777">   */</span>
<span class="source-line-no">1778</span><span id="line-1778">  public boolean isOnline() {</span>
<span class="source-line-no">1779</span><span id="line-1779">    return online.get();</span>
<span class="source-line-no">1780</span><span id="line-1780">  }</span>
<span class="source-line-no">1781</span><span id="line-1781"></span>
<span class="source-line-no">1782</span><span id="line-1782">  /**</span>
<span class="source-line-no">1783</span><span id="line-1783">   * Setup WAL log and replication if enabled. Replication setup is done in here because it wants to</span>
<span class="source-line-no">1784</span><span id="line-1784">   * be hooked up to WAL.</span>
<span class="source-line-no">1785</span><span id="line-1785">   */</span>
<span class="source-line-no">1786</span><span id="line-1786">  private void setupWALAndReplication() throws IOException {</span>
<span class="source-line-no">1787</span><span id="line-1787">    WALFactory factory = new WALFactory(conf, serverName, this);</span>
<span class="source-line-no">1788</span><span id="line-1788">    // TODO Replication make assumptions here based on the default filesystem impl</span>
<span class="source-line-no">1789</span><span id="line-1789">    Path oldLogDir = new Path(walRootDir, HConstants.HREGION_OLDLOGDIR_NAME);</span>
<span class="source-line-no">1790</span><span id="line-1790">    String logName = AbstractFSWALProvider.getWALDirectoryName(this.serverName.toString());</span>
<span class="source-line-no">1791</span><span id="line-1791"></span>
<span class="source-line-no">1792</span><span id="line-1792">    Path logDir = new Path(walRootDir, logName);</span>
<span class="source-line-no">1793</span><span id="line-1793">    LOG.debug("logDir={}", logDir);</span>
<span class="source-line-no">1794</span><span id="line-1794">    if (this.walFs.exists(logDir)) {</span>
<span class="source-line-no">1795</span><span id="line-1795">      throw new RegionServerRunningException(</span>
<span class="source-line-no">1796</span><span id="line-1796">        "Region server has already created directory at " + this.serverName.toString());</span>
<span class="source-line-no">1797</span><span id="line-1797">    }</span>
<span class="source-line-no">1798</span><span id="line-1798">    // Always create wal directory as now we need this when master restarts to find out the live</span>
<span class="source-line-no">1799</span><span id="line-1799">    // region servers.</span>
<span class="source-line-no">1800</span><span id="line-1800">    if (!this.walFs.mkdirs(logDir)) {</span>
<span class="source-line-no">1801</span><span id="line-1801">      throw new IOException("Can not create wal directory " + logDir);</span>
<span class="source-line-no">1802</span><span id="line-1802">    }</span>
<span class="source-line-no">1803</span><span id="line-1803">    // Instantiate replication if replication enabled. Pass it the log directories.</span>
<span class="source-line-no">1804</span><span id="line-1804">    createNewReplicationInstance(conf, this, this.walFs, logDir, oldLogDir, factory);</span>
<span class="source-line-no">1805</span><span id="line-1805"></span>
<span class="source-line-no">1806</span><span id="line-1806">    WALActionsListener walEventListener = getWALEventTrackerListener(conf);</span>
<span class="source-line-no">1807</span><span id="line-1807">    if (walEventListener != null &amp;&amp; factory.getWALProvider() != null) {</span>
<span class="source-line-no">1808</span><span id="line-1808">      factory.getWALProvider().addWALActionsListener(walEventListener);</span>
<span class="source-line-no">1809</span><span id="line-1809">    }</span>
<span class="source-line-no">1810</span><span id="line-1810">    this.walFactory = factory;</span>
<span class="source-line-no">1811</span><span id="line-1811">  }</span>
<span class="source-line-no">1812</span><span id="line-1812"></span>
<span class="source-line-no">1813</span><span id="line-1813">  private WALActionsListener getWALEventTrackerListener(Configuration conf) {</span>
<span class="source-line-no">1814</span><span id="line-1814">    if (conf.getBoolean(WAL_EVENT_TRACKER_ENABLED_KEY, WAL_EVENT_TRACKER_ENABLED_DEFAULT)) {</span>
<span class="source-line-no">1815</span><span id="line-1815">      WALEventTrackerListener listener =</span>
<span class="source-line-no">1816</span><span id="line-1816">        new WALEventTrackerListener(conf, getNamedQueueRecorder(), getServerName());</span>
<span class="source-line-no">1817</span><span id="line-1817">      return listener;</span>
<span class="source-line-no">1818</span><span id="line-1818">    }</span>
<span class="source-line-no">1819</span><span id="line-1819">    return null;</span>
<span class="source-line-no">1820</span><span id="line-1820">  }</span>
<span class="source-line-no">1821</span><span id="line-1821"></span>
<span class="source-line-no">1822</span><span id="line-1822">  /**</span>
<span class="source-line-no">1823</span><span id="line-1823">   * Start up replication source and sink handlers.</span>
<span class="source-line-no">1824</span><span id="line-1824">   */</span>
<span class="source-line-no">1825</span><span id="line-1825">  private void startReplicationService() throws IOException {</span>
<span class="source-line-no">1826</span><span id="line-1826">    if (sameReplicationSourceAndSink &amp;&amp; this.replicationSourceHandler != null) {</span>
<span class="source-line-no">1827</span><span id="line-1827">      this.replicationSourceHandler.startReplicationService();</span>
<span class="source-line-no">1828</span><span id="line-1828">    } else {</span>
<span class="source-line-no">1829</span><span id="line-1829">      if (this.replicationSourceHandler != null) {</span>
<span class="source-line-no">1830</span><span id="line-1830">        this.replicationSourceHandler.startReplicationService();</span>
<span class="source-line-no">1831</span><span id="line-1831">      }</span>
<span class="source-line-no">1832</span><span id="line-1832">      if (this.replicationSinkHandler != null) {</span>
<span class="source-line-no">1833</span><span id="line-1833">        this.replicationSinkHandler.startReplicationService();</span>
<span class="source-line-no">1834</span><span id="line-1834">      }</span>
<span class="source-line-no">1835</span><span id="line-1835">    }</span>
<span class="source-line-no">1836</span><span id="line-1836">  }</span>
<span class="source-line-no">1837</span><span id="line-1837"></span>
<span class="source-line-no">1838</span><span id="line-1838">  /** Returns Master address tracker instance. */</span>
<span class="source-line-no">1839</span><span id="line-1839">  public MasterAddressTracker getMasterAddressTracker() {</span>
<span class="source-line-no">1840</span><span id="line-1840">    return this.masterAddressTracker;</span>
<span class="source-line-no">1841</span><span id="line-1841">  }</span>
<span class="source-line-no">1842</span><span id="line-1842"></span>
<span class="source-line-no">1843</span><span id="line-1843">  /**</span>
<span class="source-line-no">1844</span><span id="line-1844">   * Start maintenance Threads, Server, Worker and lease checker threads. Start all threads we need</span>
<span class="source-line-no">1845</span><span id="line-1845">   * to run. This is called after we've successfully registered with the Master. Install an</span>
<span class="source-line-no">1846</span><span id="line-1846">   * UncaughtExceptionHandler that calls abort of RegionServer if we get an unhandled exception. We</span>
<span class="source-line-no">1847</span><span id="line-1847">   * cannot set the handler on all threads. Server's internal Listener thread is off limits. For</span>
<span class="source-line-no">1848</span><span id="line-1848">   * Server, if an OOME, it waits a while then retries. Meantime, a flush or a compaction that tries</span>
<span class="source-line-no">1849</span><span id="line-1849">   * to run should trigger same critical condition and the shutdown will run. On its way out, this</span>
<span class="source-line-no">1850</span><span id="line-1850">   * server will shut down Server. Leases are sort of inbetween. It has an internal thread that</span>
<span class="source-line-no">1851</span><span id="line-1851">   * while it inherits from Chore, it keeps its own internal stop mechanism so needs to be stopped</span>
<span class="source-line-no">1852</span><span id="line-1852">   * by this hosting server. Worker logs the exception and exits.</span>
<span class="source-line-no">1853</span><span id="line-1853">   */</span>
<span class="source-line-no">1854</span><span id="line-1854">  private void startServices() throws IOException {</span>
<span class="source-line-no">1855</span><span id="line-1855">    if (!isStopped() &amp;&amp; !isAborted()) {</span>
<span class="source-line-no">1856</span><span id="line-1856">      initializeThreads();</span>
<span class="source-line-no">1857</span><span id="line-1857">    }</span>
<span class="source-line-no">1858</span><span id="line-1858">    this.secureBulkLoadManager = new SecureBulkLoadManager(this.conf, asyncClusterConnection);</span>
<span class="source-line-no">1859</span><span id="line-1859">    this.secureBulkLoadManager.start();</span>
<span class="source-line-no">1860</span><span id="line-1860"></span>
<span class="source-line-no">1861</span><span id="line-1861">    // Health checker thread.</span>
<span class="source-line-no">1862</span><span id="line-1862">    if (isHealthCheckerConfigured()) {</span>
<span class="source-line-no">1863</span><span id="line-1863">      int sleepTime = this.conf.getInt(HConstants.HEALTH_CHORE_WAKE_FREQ,</span>
<span class="source-line-no">1864</span><span id="line-1864">        HConstants.DEFAULT_THREAD_WAKE_FREQUENCY);</span>
<span class="source-line-no">1865</span><span id="line-1865">      healthCheckChore = new HealthCheckChore(sleepTime, this, getConfiguration());</span>
<span class="source-line-no">1866</span><span id="line-1866">    }</span>
<span class="source-line-no">1867</span><span id="line-1867">    // Executor status collect thread.</span>
<span class="source-line-no">1868</span><span id="line-1868">    if (</span>
<span class="source-line-no">1869</span><span id="line-1869">      this.conf.getBoolean(HConstants.EXECUTOR_STATUS_COLLECT_ENABLED,</span>
<span class="source-line-no">1870</span><span id="line-1870">        HConstants.DEFAULT_EXECUTOR_STATUS_COLLECT_ENABLED)</span>
<span class="source-line-no">1871</span><span id="line-1871">    ) {</span>
<span class="source-line-no">1872</span><span id="line-1872">      int sleepTime =</span>
<span class="source-line-no">1873</span><span id="line-1873">        this.conf.getInt(ExecutorStatusChore.WAKE_FREQ, ExecutorStatusChore.DEFAULT_WAKE_FREQ);</span>
<span class="source-line-no">1874</span><span id="line-1874">      executorStatusChore = new ExecutorStatusChore(sleepTime, this, this.getExecutorService(),</span>
<span class="source-line-no">1875</span><span id="line-1875">        this.metricsRegionServer.getMetricsSource());</span>
<span class="source-line-no">1876</span><span id="line-1876">    }</span>
<span class="source-line-no">1877</span><span id="line-1877"></span>
<span class="source-line-no">1878</span><span id="line-1878">    this.walRoller = new LogRoller(this);</span>
<span class="source-line-no">1879</span><span id="line-1879">    this.flushThroughputController = FlushThroughputControllerFactory.create(this, conf);</span>
<span class="source-line-no">1880</span><span id="line-1880">    this.procedureResultReporter = new RemoteProcedureResultReporter(this);</span>
<span class="source-line-no">1881</span><span id="line-1881"></span>
<span class="source-line-no">1882</span><span id="line-1882">    // Create the CompactedFileDischarger chore executorService. This chore helps to</span>
<span class="source-line-no">1883</span><span id="line-1883">    // remove the compacted files that will no longer be used in reads.</span>
<span class="source-line-no">1884</span><span id="line-1884">    // Default is 2 mins. The default value for TTLCleaner is 5 mins so we set this to</span>
<span class="source-line-no">1885</span><span id="line-1885">    // 2 mins so that compacted files can be archived before the TTLCleaner runs</span>
<span class="source-line-no">1886</span><span id="line-1886">    int cleanerInterval = conf.getInt("hbase.hfile.compaction.discharger.interval", 2 * 60 * 1000);</span>
<span class="source-line-no">1887</span><span id="line-1887">    this.compactedFileDischarger = new CompactedHFilesDischarger(cleanerInterval, this, this);</span>
<span class="source-line-no">1888</span><span id="line-1888">    choreService.scheduleChore(compactedFileDischarger);</span>
<span class="source-line-no">1889</span><span id="line-1889"></span>
<span class="source-line-no">1890</span><span id="line-1890">    // Start executor services</span>
<span class="source-line-no">1891</span><span id="line-1891">    final int openRegionThreads = conf.getInt("hbase.regionserver.executor.openregion.threads", 3);</span>
<span class="source-line-no">1892</span><span id="line-1892">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1893</span><span id="line-1893">      .setExecutorType(ExecutorType.RS_OPEN_REGION).setCorePoolSize(openRegionThreads));</span>
<span class="source-line-no">1894</span><span id="line-1894">    final int openMetaThreads = conf.getInt("hbase.regionserver.executor.openmeta.threads", 1);</span>
<span class="source-line-no">1895</span><span id="line-1895">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1896</span><span id="line-1896">      .setExecutorType(ExecutorType.RS_OPEN_META).setCorePoolSize(openMetaThreads));</span>
<span class="source-line-no">1897</span><span id="line-1897">    final int openPriorityRegionThreads =</span>
<span class="source-line-no">1898</span><span id="line-1898">      conf.getInt("hbase.regionserver.executor.openpriorityregion.threads", 3);</span>
<span class="source-line-no">1899</span><span id="line-1899">    executorService.startExecutorService(</span>
<span class="source-line-no">1900</span><span id="line-1900">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_OPEN_PRIORITY_REGION)</span>
<span class="source-line-no">1901</span><span id="line-1901">        .setCorePoolSize(openPriorityRegionThreads));</span>
<span class="source-line-no">1902</span><span id="line-1902">    final int closeRegionThreads =</span>
<span class="source-line-no">1903</span><span id="line-1903">      conf.getInt("hbase.regionserver.executor.closeregion.threads", 3);</span>
<span class="source-line-no">1904</span><span id="line-1904">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1905</span><span id="line-1905">      .setExecutorType(ExecutorType.RS_CLOSE_REGION).setCorePoolSize(closeRegionThreads));</span>
<span class="source-line-no">1906</span><span id="line-1906">    final int closeMetaThreads = conf.getInt("hbase.regionserver.executor.closemeta.threads", 1);</span>
<span class="source-line-no">1907</span><span id="line-1907">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1908</span><span id="line-1908">      .setExecutorType(ExecutorType.RS_CLOSE_META).setCorePoolSize(closeMetaThreads));</span>
<span class="source-line-no">1909</span><span id="line-1909">    if (conf.getBoolean(StoreScanner.STORESCANNER_PARALLEL_SEEK_ENABLE, false)) {</span>
<span class="source-line-no">1910</span><span id="line-1910">      final int storeScannerParallelSeekThreads =</span>
<span class="source-line-no">1911</span><span id="line-1911">        conf.getInt("hbase.storescanner.parallel.seek.threads", 10);</span>
<span class="source-line-no">1912</span><span id="line-1912">      executorService.startExecutorService(</span>
<span class="source-line-no">1913</span><span id="line-1913">        executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_PARALLEL_SEEK)</span>
<span class="source-line-no">1914</span><span id="line-1914">          .setCorePoolSize(storeScannerParallelSeekThreads).setAllowCoreThreadTimeout(true));</span>
<span class="source-line-no">1915</span><span id="line-1915">    }</span>
<span class="source-line-no">1916</span><span id="line-1916">    final int logReplayOpsThreads =</span>
<span class="source-line-no">1917</span><span id="line-1917">      conf.getInt(HBASE_SPLIT_WAL_MAX_SPLITTER, DEFAULT_HBASE_SPLIT_WAL_MAX_SPLITTER);</span>
<span class="source-line-no">1918</span><span id="line-1918">    executorService.startExecutorService(</span>
<span class="source-line-no">1919</span><span id="line-1919">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_LOG_REPLAY_OPS)</span>
<span class="source-line-no">1920</span><span id="line-1920">        .setCorePoolSize(logReplayOpsThreads).setAllowCoreThreadTimeout(true));</span>
<span class="source-line-no">1921</span><span id="line-1921">    // Start the threads for compacted files discharger</span>
<span class="source-line-no">1922</span><span id="line-1922">    final int compactionDischargerThreads =</span>
<span class="source-line-no">1923</span><span id="line-1923">      conf.getInt(CompactionConfiguration.HBASE_HFILE_COMPACTION_DISCHARGER_THREAD_COUNT, 10);</span>
<span class="source-line-no">1924</span><span id="line-1924">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1925</span><span id="line-1925">      .setExecutorType(ExecutorType.RS_COMPACTED_FILES_DISCHARGER)</span>
<span class="source-line-no">1926</span><span id="line-1926">      .setCorePoolSize(compactionDischargerThreads));</span>
<span class="source-line-no">1927</span><span id="line-1927">    if (ServerRegionReplicaUtil.isRegionReplicaWaitForPrimaryFlushEnabled(conf)) {</span>
<span class="source-line-no">1928</span><span id="line-1928">      final int regionReplicaFlushThreads =</span>
<span class="source-line-no">1929</span><span id="line-1929">        conf.getInt("hbase.regionserver.region.replica.flusher.threads",</span>
<span class="source-line-no">1930</span><span id="line-1930">          conf.getInt("hbase.regionserver.executor.openregion.threads", 3));</span>
<span class="source-line-no">1931</span><span id="line-1931">      executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1932</span><span id="line-1932">        .setExecutorType(ExecutorType.RS_REGION_REPLICA_FLUSH_OPS)</span>
<span class="source-line-no">1933</span><span id="line-1933">        .setCorePoolSize(regionReplicaFlushThreads));</span>
<span class="source-line-no">1934</span><span id="line-1934">    }</span>
<span class="source-line-no">1935</span><span id="line-1935">    final int refreshPeerThreads =</span>
<span class="source-line-no">1936</span><span id="line-1936">      conf.getInt("hbase.regionserver.executor.refresh.peer.threads", 2);</span>
<span class="source-line-no">1937</span><span id="line-1937">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1938</span><span id="line-1938">      .setExecutorType(ExecutorType.RS_REFRESH_PEER).setCorePoolSize(refreshPeerThreads));</span>
<span class="source-line-no">1939</span><span id="line-1939">    final int replaySyncReplicationWALThreads =</span>
<span class="source-line-no">1940</span><span id="line-1940">      conf.getInt("hbase.regionserver.executor.replay.sync.replication.wal.threads", 1);</span>
<span class="source-line-no">1941</span><span id="line-1941">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1942</span><span id="line-1942">      .setExecutorType(ExecutorType.RS_REPLAY_SYNC_REPLICATION_WAL)</span>
<span class="source-line-no">1943</span><span id="line-1943">      .setCorePoolSize(replaySyncReplicationWALThreads));</span>
<span class="source-line-no">1944</span><span id="line-1944">    final int switchRpcThrottleThreads =</span>
<span class="source-line-no">1945</span><span id="line-1945">      conf.getInt("hbase.regionserver.executor.switch.rpc.throttle.threads", 1);</span>
<span class="source-line-no">1946</span><span id="line-1946">    executorService.startExecutorService(</span>
<span class="source-line-no">1947</span><span id="line-1947">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_SWITCH_RPC_THROTTLE)</span>
<span class="source-line-no">1948</span><span id="line-1948">        .setCorePoolSize(switchRpcThrottleThreads));</span>
<span class="source-line-no">1949</span><span id="line-1949">    final int claimReplicationQueueThreads =</span>
<span class="source-line-no">1950</span><span id="line-1950">      conf.getInt("hbase.regionserver.executor.claim.replication.queue.threads", 1);</span>
<span class="source-line-no">1951</span><span id="line-1951">    executorService.startExecutorService(</span>
<span class="source-line-no">1952</span><span id="line-1952">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_CLAIM_REPLICATION_QUEUE)</span>
<span class="source-line-no">1953</span><span id="line-1953">        .setCorePoolSize(claimReplicationQueueThreads));</span>
<span class="source-line-no">1954</span><span id="line-1954">    final int rsSnapshotOperationThreads =</span>
<span class="source-line-no">1955</span><span id="line-1955">      conf.getInt("hbase.regionserver.executor.snapshot.operations.threads", 3);</span>
<span class="source-line-no">1956</span><span id="line-1956">    executorService.startExecutorService(</span>
<span class="source-line-no">1957</span><span id="line-1957">      executorService.new ExecutorConfig().setExecutorType(ExecutorType.RS_SNAPSHOT_OPERATIONS)</span>
<span class="source-line-no">1958</span><span id="line-1958">        .setCorePoolSize(rsSnapshotOperationThreads));</span>
<span class="source-line-no">1959</span><span id="line-1959">    final int rsFlushOperationThreads =</span>
<span class="source-line-no">1960</span><span id="line-1960">      conf.getInt("hbase.regionserver.executor.flush.operations.threads", 3);</span>
<span class="source-line-no">1961</span><span id="line-1961">    executorService.startExecutorService(executorService.new ExecutorConfig()</span>
<span class="source-line-no">1962</span><span id="line-1962">      .setExecutorType(ExecutorType.RS_FLUSH_OPERATIONS).setCorePoolSize(rsFlushOperationThreads));</span>
<span class="source-line-no">1963</span><span id="line-1963"></span>
<span class="source-line-no">1964</span><span id="line-1964">    Threads.setDaemonThreadRunning(this.walRoller, getName() + ".logRoller",</span>
<span class="source-line-no">1965</span><span id="line-1965">      uncaughtExceptionHandler);</span>
<span class="source-line-no">1966</span><span id="line-1966">    if (this.cacheFlusher != null) {</span>
<span class="source-line-no">1967</span><span id="line-1967">      this.cacheFlusher.start(uncaughtExceptionHandler);</span>
<span class="source-line-no">1968</span><span id="line-1968">    }</span>
<span class="source-line-no">1969</span><span id="line-1969">    Threads.setDaemonThreadRunning(this.procedureResultReporter,</span>
<span class="source-line-no">1970</span><span id="line-1970">      getName() + ".procedureResultReporter", uncaughtExceptionHandler);</span>
<span class="source-line-no">1971</span><span id="line-1971"></span>
<span class="source-line-no">1972</span><span id="line-1972">    if (this.compactionChecker != null) {</span>
<span class="source-line-no">1973</span><span id="line-1973">      choreService.scheduleChore(compactionChecker);</span>
<span class="source-line-no">1974</span><span id="line-1974">    }</span>
<span class="source-line-no">1975</span><span id="line-1975">    if (this.periodicFlusher != null) {</span>
<span class="source-line-no">1976</span><span id="line-1976">      choreService.scheduleChore(periodicFlusher);</span>
<span class="source-line-no">1977</span><span id="line-1977">    }</span>
<span class="source-line-no">1978</span><span id="line-1978">    if (this.healthCheckChore != null) {</span>
<span class="source-line-no">1979</span><span id="line-1979">      choreService.scheduleChore(healthCheckChore);</span>
<span class="source-line-no">1980</span><span id="line-1980">    }</span>
<span class="source-line-no">1981</span><span id="line-1981">    if (this.executorStatusChore != null) {</span>
<span class="source-line-no">1982</span><span id="line-1982">      choreService.scheduleChore(executorStatusChore);</span>
<span class="source-line-no">1983</span><span id="line-1983">    }</span>
<span class="source-line-no">1984</span><span id="line-1984">    if (this.nonceManagerChore != null) {</span>
<span class="source-line-no">1985</span><span id="line-1985">      choreService.scheduleChore(nonceManagerChore);</span>
<span class="source-line-no">1986</span><span id="line-1986">    }</span>
<span class="source-line-no">1987</span><span id="line-1987">    if (this.storefileRefresher != null) {</span>
<span class="source-line-no">1988</span><span id="line-1988">      choreService.scheduleChore(storefileRefresher);</span>
<span class="source-line-no">1989</span><span id="line-1989">    }</span>
<span class="source-line-no">1990</span><span id="line-1990">    if (this.fsUtilizationChore != null) {</span>
<span class="source-line-no">1991</span><span id="line-1991">      choreService.scheduleChore(fsUtilizationChore);</span>
<span class="source-line-no">1992</span><span id="line-1992">    }</span>
<span class="source-line-no">1993</span><span id="line-1993">    if (this.namedQueueServiceChore != null) {</span>
<span class="source-line-no">1994</span><span id="line-1994">      choreService.scheduleChore(namedQueueServiceChore);</span>
<span class="source-line-no">1995</span><span id="line-1995">    }</span>
<span class="source-line-no">1996</span><span id="line-1996">    if (this.brokenStoreFileCleaner != null) {</span>
<span class="source-line-no">1997</span><span id="line-1997">      choreService.scheduleChore(brokenStoreFileCleaner);</span>
<span class="source-line-no">1998</span><span id="line-1998">    }</span>
<span class="source-line-no">1999</span><span id="line-1999">    if (this.rsMobFileCleanerChore != null) {</span>
<span class="source-line-no">2000</span><span id="line-2000">      choreService.scheduleChore(rsMobFileCleanerChore);</span>
<span class="source-line-no">2001</span><span id="line-2001">    }</span>
<span class="source-line-no">2002</span><span id="line-2002">    if (replicationMarkerChore != null) {</span>
<span class="source-line-no">2003</span><span id="line-2003">      LOG.info("Starting replication marker chore");</span>
<span class="source-line-no">2004</span><span id="line-2004">      choreService.scheduleChore(replicationMarkerChore);</span>
<span class="source-line-no">2005</span><span id="line-2005">    }</span>
<span class="source-line-no">2006</span><span id="line-2006"></span>
<span class="source-line-no">2007</span><span id="line-2007">    // Leases is not a Thread. Internally it runs a daemon thread. If it gets</span>
<span class="source-line-no">2008</span><span id="line-2008">    // an unhandled exception, it will just exit.</span>
<span class="source-line-no">2009</span><span id="line-2009">    Threads.setDaemonThreadRunning(this.leaseManager, getName() + ".leaseChecker",</span>
<span class="source-line-no">2010</span><span id="line-2010">      uncaughtExceptionHandler);</span>
<span class="source-line-no">2011</span><span id="line-2011"></span>
<span class="source-line-no">2012</span><span id="line-2012">    // Create the log splitting worker and start it</span>
<span class="source-line-no">2013</span><span id="line-2013">    // set a smaller retries to fast fail otherwise splitlogworker could be blocked for</span>
<span class="source-line-no">2014</span><span id="line-2014">    // quite a while inside Connection layer. The worker won't be available for other</span>
<span class="source-line-no">2015</span><span id="line-2015">    // tasks even after current task is preempted after a split task times out.</span>
<span class="source-line-no">2016</span><span id="line-2016">    Configuration sinkConf = HBaseConfiguration.create(conf);</span>
<span class="source-line-no">2017</span><span id="line-2017">    sinkConf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,</span>
<span class="source-line-no">2018</span><span id="line-2018">      conf.getInt("hbase.log.replay.retries.number", 8)); // 8 retries take about 23 seconds</span>
<span class="source-line-no">2019</span><span id="line-2019">    sinkConf.setInt(HConstants.HBASE_RPC_TIMEOUT_KEY,</span>
<span class="source-line-no">2020</span><span id="line-2020">      conf.getInt("hbase.log.replay.rpc.timeout", 30000)); // default 30 seconds</span>
<span class="source-line-no">2021</span><span id="line-2021">    sinkConf.setInt(HConstants.HBASE_CLIENT_SERVERSIDE_RETRIES_MULTIPLIER, 1);</span>
<span class="source-line-no">2022</span><span id="line-2022">    if (</span>
<span class="source-line-no">2023</span><span id="line-2023">      this.csm != null</span>
<span class="source-line-no">2024</span><span id="line-2024">        &amp;&amp; conf.getBoolean(HBASE_SPLIT_WAL_COORDINATED_BY_ZK, DEFAULT_HBASE_SPLIT_COORDINATED_BY_ZK)</span>
<span class="source-line-no">2025</span><span id="line-2025">    ) {</span>
<span class="source-line-no">2026</span><span id="line-2026">      // SplitLogWorker needs csm. If none, don't start this.</span>
<span class="source-line-no">2027</span><span id="line-2027">      this.splitLogWorker = new SplitLogWorker(sinkConf, this, this, walFactory);</span>
<span class="source-line-no">2028</span><span id="line-2028">      splitLogWorker.start();</span>
<span class="source-line-no">2029</span><span id="line-2029">      LOG.debug("SplitLogWorker started");</span>
<span class="source-line-no">2030</span><span id="line-2030">    }</span>
<span class="source-line-no">2031</span><span id="line-2031"></span>
<span class="source-line-no">2032</span><span id="line-2032">    // Memstore services.</span>
<span class="source-line-no">2033</span><span id="line-2033">    startHeapMemoryManager();</span>
<span class="source-line-no">2034</span><span id="line-2034">    // Call it after starting HeapMemoryManager.</span>
<span class="source-line-no">2035</span><span id="line-2035">    initializeMemStoreChunkCreator(hMemManager);</span>
<span class="source-line-no">2036</span><span id="line-2036">  }</span>
<span class="source-line-no">2037</span><span id="line-2037"></span>
<span class="source-line-no">2038</span><span id="line-2038">  private void initializeThreads() {</span>
<span class="source-line-no">2039</span><span id="line-2039">    // Cache flushing thread.</span>
<span class="source-line-no">2040</span><span id="line-2040">    this.cacheFlusher = new MemStoreFlusher(conf, this);</span>
<span class="source-line-no">2041</span><span id="line-2041"></span>
<span class="source-line-no">2042</span><span id="line-2042">    // Compaction thread</span>
<span class="source-line-no">2043</span><span id="line-2043">    this.compactSplitThread = new CompactSplit(this);</span>
<span class="source-line-no">2044</span><span id="line-2044"></span>
<span class="source-line-no">2045</span><span id="line-2045">    // Prefetch Notifier</span>
<span class="source-line-no">2046</span><span id="line-2046">    this.prefetchExecutorNotifier = new PrefetchExecutorNotifier(conf);</span>
<span class="source-line-no">2047</span><span id="line-2047"></span>
<span class="source-line-no">2048</span><span id="line-2048">    // Background thread to check for compactions; needed if region has not gotten updates</span>
<span class="source-line-no">2049</span><span id="line-2049">    // in a while. It will take care of not checking too frequently on store-by-store basis.</span>
<span class="source-line-no">2050</span><span id="line-2050">    this.compactionChecker = new CompactionChecker(this, this.compactionCheckFrequency, this);</span>
<span class="source-line-no">2051</span><span id="line-2051">    this.periodicFlusher = new PeriodicMemStoreFlusher(this.flushCheckFrequency, this);</span>
<span class="source-line-no">2052</span><span id="line-2052">    this.leaseManager = new LeaseManager(this.threadWakeFrequency);</span>
<span class="source-line-no">2053</span><span id="line-2053"></span>
<span class="source-line-no">2054</span><span id="line-2054">    final boolean isSlowLogTableEnabled = conf.getBoolean(HConstants.SLOW_LOG_SYS_TABLE_ENABLED_KEY,</span>
<span class="source-line-no">2055</span><span id="line-2055">      HConstants.DEFAULT_SLOW_LOG_SYS_TABLE_ENABLED_KEY);</span>
<span class="source-line-no">2056</span><span id="line-2056">    final boolean walEventTrackerEnabled =</span>
<span class="source-line-no">2057</span><span id="line-2057">      conf.getBoolean(WAL_EVENT_TRACKER_ENABLED_KEY, WAL_EVENT_TRACKER_ENABLED_DEFAULT);</span>
<span class="source-line-no">2058</span><span id="line-2058"></span>
<span class="source-line-no">2059</span><span id="line-2059">    if (isSlowLogTableEnabled || walEventTrackerEnabled) {</span>
<span class="source-line-no">2060</span><span id="line-2060">      // default chore duration: 10 min</span>
<span class="source-line-no">2061</span><span id="line-2061">      // After &lt;version number&gt;, we will remove hbase.slowlog.systable.chore.duration conf property</span>
<span class="source-line-no">2062</span><span id="line-2062">      final int slowLogChoreDuration = conf.getInt(HConstants.SLOW_LOG_SYS_TABLE_CHORE_DURATION_KEY,</span>
<span class="source-line-no">2063</span><span id="line-2063">        DEFAULT_SLOW_LOG_SYS_TABLE_CHORE_DURATION);</span>
<span class="source-line-no">2064</span><span id="line-2064"></span>
<span class="source-line-no">2065</span><span id="line-2065">      final int namedQueueChoreDuration =</span>
<span class="source-line-no">2066</span><span id="line-2066">        conf.getInt(NAMED_QUEUE_CHORE_DURATION_KEY, NAMED_QUEUE_CHORE_DURATION_DEFAULT);</span>
<span class="source-line-no">2067</span><span id="line-2067">      // Considering min of slowLogChoreDuration and namedQueueChoreDuration</span>
<span class="source-line-no">2068</span><span id="line-2068">      int choreDuration = Math.min(slowLogChoreDuration, namedQueueChoreDuration);</span>
<span class="source-line-no">2069</span><span id="line-2069"></span>
<span class="source-line-no">2070</span><span id="line-2070">      namedQueueServiceChore = new NamedQueueServiceChore(this, choreDuration,</span>
<span class="source-line-no">2071</span><span id="line-2071">        this.namedQueueRecorder, this.getConnection());</span>
<span class="source-line-no">2072</span><span id="line-2072">    }</span>
<span class="source-line-no">2073</span><span id="line-2073"></span>
<span class="source-line-no">2074</span><span id="line-2074">    if (this.nonceManager != null) {</span>
<span class="source-line-no">2075</span><span id="line-2075">      // Create the scheduled chore that cleans up nonces.</span>
<span class="source-line-no">2076</span><span id="line-2076">      nonceManagerChore = this.nonceManager.createCleanupScheduledChore(this);</span>
<span class="source-line-no">2077</span><span id="line-2077">    }</span>
<span class="source-line-no">2078</span><span id="line-2078"></span>
<span class="source-line-no">2079</span><span id="line-2079">    // Setup the Quota Manager</span>
<span class="source-line-no">2080</span><span id="line-2080">    rsQuotaManager = new RegionServerRpcQuotaManager(this);</span>
<span class="source-line-no">2081</span><span id="line-2081">    rsSpaceQuotaManager = new RegionServerSpaceQuotaManager(this);</span>
<span class="source-line-no">2082</span><span id="line-2082"></span>
<span class="source-line-no">2083</span><span id="line-2083">    if (QuotaUtil.isQuotaEnabled(conf)) {</span>
<span class="source-line-no">2084</span><span id="line-2084">      this.fsUtilizationChore = new FileSystemUtilizationChore(this);</span>
<span class="source-line-no">2085</span><span id="line-2085">    }</span>
<span class="source-line-no">2086</span><span id="line-2086"></span>
<span class="source-line-no">2087</span><span id="line-2087">    boolean onlyMetaRefresh = false;</span>
<span class="source-line-no">2088</span><span id="line-2088">    int storefileRefreshPeriod =</span>
<span class="source-line-no">2089</span><span id="line-2089">      conf.getInt(StorefileRefresherChore.REGIONSERVER_STOREFILE_REFRESH_PERIOD,</span>
<span class="source-line-no">2090</span><span id="line-2090">        StorefileRefresherChore.DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD);</span>
<span class="source-line-no">2091</span><span id="line-2091">    if (storefileRefreshPeriod == 0) {</span>
<span class="source-line-no">2092</span><span id="line-2092">      storefileRefreshPeriod =</span>
<span class="source-line-no">2093</span><span id="line-2093">        conf.getInt(StorefileRefresherChore.REGIONSERVER_META_STOREFILE_REFRESH_PERIOD,</span>
<span class="source-line-no">2094</span><span id="line-2094">          StorefileRefresherChore.DEFAULT_REGIONSERVER_STOREFILE_REFRESH_PERIOD);</span>
<span class="source-line-no">2095</span><span id="line-2095">      onlyMetaRefresh = true;</span>
<span class="source-line-no">2096</span><span id="line-2096">    }</span>
<span class="source-line-no">2097</span><span id="line-2097">    if (storefileRefreshPeriod &gt; 0) {</span>
<span class="source-line-no">2098</span><span id="line-2098">      this.storefileRefresher =</span>
<span class="source-line-no">2099</span><span id="line-2099">        new StorefileRefresherChore(storefileRefreshPeriod, onlyMetaRefresh, this, this);</span>
<span class="source-line-no">2100</span><span id="line-2100">    }</span>
<span class="source-line-no">2101</span><span id="line-2101"></span>
<span class="source-line-no">2102</span><span id="line-2102">    int brokenStoreFileCleanerPeriod =</span>
<span class="source-line-no">2103</span><span id="line-2103">      conf.getInt(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_PERIOD,</span>
<span class="source-line-no">2104</span><span id="line-2104">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_PERIOD);</span>
<span class="source-line-no">2105</span><span id="line-2105">    int brokenStoreFileCleanerDelay =</span>
<span class="source-line-no">2106</span><span id="line-2106">      conf.getInt(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_DELAY,</span>
<span class="source-line-no">2107</span><span id="line-2107">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_DELAY);</span>
<span class="source-line-no">2108</span><span id="line-2108">    double brokenStoreFileCleanerDelayJitter =</span>
<span class="source-line-no">2109</span><span id="line-2109">      conf.getDouble(BrokenStoreFileCleaner.BROKEN_STOREFILE_CLEANER_DELAY_JITTER,</span>
<span class="source-line-no">2110</span><span id="line-2110">        BrokenStoreFileCleaner.DEFAULT_BROKEN_STOREFILE_CLEANER_DELAY_JITTER);</span>
<span class="source-line-no">2111</span><span id="line-2111">    double jitterRate =</span>
<span class="source-line-no">2112</span><span id="line-2112">      (ThreadLocalRandom.current().nextDouble() - 0.5D) * brokenStoreFileCleanerDelayJitter;</span>
<span class="source-line-no">2113</span><span id="line-2113">    long jitterValue = Math.round(brokenStoreFileCleanerDelay * jitterRate);</span>
<span class="source-line-no">2114</span><span id="line-2114">    this.brokenStoreFileCleaner =</span>
<span class="source-line-no">2115</span><span id="line-2115">      new BrokenStoreFileCleaner((int) (brokenStoreFileCleanerDelay + jitterValue),</span>
<span class="source-line-no">2116</span><span id="line-2116">        brokenStoreFileCleanerPeriod, this, conf, this);</span>
<span class="source-line-no">2117</span><span id="line-2117"></span>
<span class="source-line-no">2118</span><span id="line-2118">    this.rsMobFileCleanerChore = new RSMobFileCleanerChore(this);</span>
<span class="source-line-no">2119</span><span id="line-2119"></span>
<span class="source-line-no">2120</span><span id="line-2120">    registerConfigurationObservers();</span>
<span class="source-line-no">2121</span><span id="line-2121">    initializeReplicationMarkerChore();</span>
<span class="source-line-no">2122</span><span id="line-2122">  }</span>
<span class="source-line-no">2123</span><span id="line-2123"></span>
<span class="source-line-no">2124</span><span id="line-2124">  private void registerConfigurationObservers() {</span>
<span class="source-line-no">2125</span><span id="line-2125">    // Register Replication if possible, as now we support recreating replication peer storage, for</span>
<span class="source-line-no">2126</span><span id="line-2126">    // migrating across different replication peer storages online</span>
<span class="source-line-no">2127</span><span id="line-2127">    if (replicationSourceHandler instanceof ConfigurationObserver) {</span>
<span class="source-line-no">2128</span><span id="line-2128">      configurationManager.registerObserver((ConfigurationObserver) replicationSourceHandler);</span>
<span class="source-line-no">2129</span><span id="line-2129">    }</span>
<span class="source-line-no">2130</span><span id="line-2130">    if (!sameReplicationSourceAndSink &amp;&amp; replicationSinkHandler instanceof ConfigurationObserver) {</span>
<span class="source-line-no">2131</span><span id="line-2131">      configurationManager.registerObserver((ConfigurationObserver) replicationSinkHandler);</span>
<span class="source-line-no">2132</span><span id="line-2132">    }</span>
<span class="source-line-no">2133</span><span id="line-2133">    // Registering the compactSplitThread object with the ConfigurationManager.</span>
<span class="source-line-no">2134</span><span id="line-2134">    configurationManager.registerObserver(this.compactSplitThread);</span>
<span class="source-line-no">2135</span><span id="line-2135">    configurationManager.registerObserver(this.cacheFlusher);</span>
<span class="source-line-no">2136</span><span id="line-2136">    configurationManager.registerObserver(this.rpcServices);</span>
<span class="source-line-no">2137</span><span id="line-2137">    configurationManager.registerObserver(this.prefetchExecutorNotifier);</span>
<span class="source-line-no">2138</span><span id="line-2138">    configurationManager.registerObserver(this);</span>
<span class="source-line-no">2139</span><span id="line-2139">  }</span>
<span class="source-line-no">2140</span><span id="line-2140"></span>
<span class="source-line-no">2141</span><span id="line-2141">  /*</span>
<span class="source-line-no">2142</span><span id="line-2142">   * Verify that server is healthy</span>
<span class="source-line-no">2143</span><span id="line-2143">   */</span>
<span class="source-line-no">2144</span><span id="line-2144">  private boolean isHealthy() {</span>
<span class="source-line-no">2145</span><span id="line-2145">    if (!dataFsOk) {</span>
<span class="source-line-no">2146</span><span id="line-2146">      // File system problem</span>
<span class="source-line-no">2147</span><span id="line-2147">      return false;</span>
<span class="source-line-no">2148</span><span id="line-2148">    }</span>
<span class="source-line-no">2149</span><span id="line-2149">    // Verify that all threads are alive</span>
<span class="source-line-no">2150</span><span id="line-2150">    boolean healthy = (this.leaseManager == null || this.leaseManager.isAlive())</span>
<span class="source-line-no">2151</span><span id="line-2151">      &amp;&amp; (this.cacheFlusher == null || this.cacheFlusher.isAlive())</span>
<span class="source-line-no">2152</span><span id="line-2152">      &amp;&amp; (this.walRoller == null || this.walRoller.isAlive())</span>
<span class="source-line-no">2153</span><span id="line-2153">      &amp;&amp; (this.compactionChecker == null || this.compactionChecker.isScheduled())</span>
<span class="source-line-no">2154</span><span id="line-2154">      &amp;&amp; (this.periodicFlusher == null || this.periodicFlusher.isScheduled());</span>
<span class="source-line-no">2155</span><span id="line-2155">    if (!healthy) {</span>
<span class="source-line-no">2156</span><span id="line-2156">      stop("One or more threads are no longer alive -- stop");</span>
<span class="source-line-no">2157</span><span id="line-2157">    }</span>
<span class="source-line-no">2158</span><span id="line-2158">    return healthy;</span>
<span class="source-line-no">2159</span><span id="line-2159">  }</span>
<span class="source-line-no">2160</span><span id="line-2160"></span>
<span class="source-line-no">2161</span><span id="line-2161">  @Override</span>
<span class="source-line-no">2162</span><span id="line-2162">  public List&lt;WAL&gt; getWALs() {</span>
<span class="source-line-no">2163</span><span id="line-2163">    return walFactory.getWALs();</span>
<span class="source-line-no">2164</span><span id="line-2164">  }</span>
<span class="source-line-no">2165</span><span id="line-2165"></span>
<span class="source-line-no">2166</span><span id="line-2166">  @Override</span>
<span class="source-line-no">2167</span><span id="line-2167">  public WAL getWAL(RegionInfo regionInfo) throws IOException {</span>
<span class="source-line-no">2168</span><span id="line-2168">    WAL wal = walFactory.getWAL(regionInfo);</span>
<span class="source-line-no">2169</span><span id="line-2169">    if (this.walRoller != null) {</span>
<span class="source-line-no">2170</span><span id="line-2170">      this.walRoller.addWAL(wal);</span>
<span class="source-line-no">2171</span><span id="line-2171">    }</span>
<span class="source-line-no">2172</span><span id="line-2172">    return wal;</span>
<span class="source-line-no">2173</span><span id="line-2173">  }</span>
<span class="source-line-no">2174</span><span id="line-2174"></span>
<span class="source-line-no">2175</span><span id="line-2175">  public LogRoller getWalRoller() {</span>
<span class="source-line-no">2176</span><span id="line-2176">    return walRoller;</span>
<span class="source-line-no">2177</span><span id="line-2177">  }</span>
<span class="source-line-no">2178</span><span id="line-2178"></span>
<span class="source-line-no">2179</span><span id="line-2179">  public WALFactory getWalFactory() {</span>
<span class="source-line-no">2180</span><span id="line-2180">    return walFactory;</span>
<span class="source-line-no">2181</span><span id="line-2181">  }</span>
<span class="source-line-no">2182</span><span id="line-2182"></span>
<span class="source-line-no">2183</span><span id="line-2183">  @Override</span>
<span class="source-line-no">2184</span><span id="line-2184">  public void stop(final String msg) {</span>
<span class="source-line-no">2185</span><span id="line-2185">    stop(msg, false, RpcServer.getRequestUser().orElse(null));</span>
<span class="source-line-no">2186</span><span id="line-2186">  }</span>
<span class="source-line-no">2187</span><span id="line-2187"></span>
<span class="source-line-no">2188</span><span id="line-2188">  /**</span>
<span class="source-line-no">2189</span><span id="line-2189">   * Stops the regionserver.</span>
<span class="source-line-no">2190</span><span id="line-2190">   * @param msg   Status message</span>
<span class="source-line-no">2191</span><span id="line-2191">   * @param force True if this is a regionserver abort</span>
<span class="source-line-no">2192</span><span id="line-2192">   * @param user  The user executing the stop request, or null if no user is associated</span>
<span class="source-line-no">2193</span><span id="line-2193">   */</span>
<span class="source-line-no">2194</span><span id="line-2194">  public void stop(final String msg, final boolean force, final User user) {</span>
<span class="source-line-no">2195</span><span id="line-2195">    if (!this.stopped) {</span>
<span class="source-line-no">2196</span><span id="line-2196">      LOG.info("***** STOPPING region server '" + this + "' *****");</span>
<span class="source-line-no">2197</span><span id="line-2197">      if (this.rsHost != null) {</span>
<span class="source-line-no">2198</span><span id="line-2198">        // when forced via abort don't allow CPs to override</span>
<span class="source-line-no">2199</span><span id="line-2199">        try {</span>
<span class="source-line-no">2200</span><span id="line-2200">          this.rsHost.preStop(msg, user);</span>
<span class="source-line-no">2201</span><span id="line-2201">        } catch (IOException ioe) {</span>
<span class="source-line-no">2202</span><span id="line-2202">          if (!force) {</span>
<span class="source-line-no">2203</span><span id="line-2203">            LOG.warn("The region server did not stop", ioe);</span>
<span class="source-line-no">2204</span><span id="line-2204">            return;</span>
<span class="source-line-no">2205</span><span id="line-2205">          }</span>
<span class="source-line-no">2206</span><span id="line-2206">          LOG.warn("Skipping coprocessor exception on preStop() due to forced shutdown", ioe);</span>
<span class="source-line-no">2207</span><span id="line-2207">        }</span>
<span class="source-line-no">2208</span><span id="line-2208">      }</span>
<span class="source-line-no">2209</span><span id="line-2209">      this.stopped = true;</span>
<span class="source-line-no">2210</span><span id="line-2210">      LOG.info("STOPPED: " + msg);</span>
<span class="source-line-no">2211</span><span id="line-2211">      // Wakes run() if it is sleeping</span>
<span class="source-line-no">2212</span><span id="line-2212">      sleeper.skipSleepCycle();</span>
<span class="source-line-no">2213</span><span id="line-2213">    }</span>
<span class="source-line-no">2214</span><span id="line-2214">  }</span>
<span class="source-line-no">2215</span><span id="line-2215"></span>
<span class="source-line-no">2216</span><span id="line-2216">  public void waitForServerOnline() {</span>
<span class="source-line-no">2217</span><span id="line-2217">    while (!isStopped() &amp;&amp; !isOnline()) {</span>
<span class="source-line-no">2218</span><span id="line-2218">      synchronized (online) {</span>
<span class="source-line-no">2219</span><span id="line-2219">        try {</span>
<span class="source-line-no">2220</span><span id="line-2220">          online.wait(msgInterval);</span>
<span class="source-line-no">2221</span><span id="line-2221">        } catch (InterruptedException ie) {</span>
<span class="source-line-no">2222</span><span id="line-2222">          Thread.currentThread().interrupt();</span>
<span class="source-line-no">2223</span><span id="line-2223">          break;</span>
<span class="source-line-no">2224</span><span id="line-2224">        }</span>
<span class="source-line-no">2225</span><span id="line-2225">      }</span>
<span class="source-line-no">2226</span><span id="line-2226">    }</span>
<span class="source-line-no">2227</span><span id="line-2227">  }</span>
<span class="source-line-no">2228</span><span id="line-2228"></span>
<span class="source-line-no">2229</span><span id="line-2229">  @Override</span>
<span class="source-line-no">2230</span><span id="line-2230">  public void postOpenDeployTasks(final PostOpenDeployContext context) throws IOException {</span>
<span class="source-line-no">2231</span><span id="line-2231">    HRegion r = context.getRegion();</span>
<span class="source-line-no">2232</span><span id="line-2232">    long openProcId = context.getOpenProcId();</span>
<span class="source-line-no">2233</span><span id="line-2233">    long masterSystemTime = context.getMasterSystemTime();</span>
<span class="source-line-no">2234</span><span id="line-2234">    long initiatingMasterActiveTime = context.getInitiatingMasterActiveTime();</span>
<span class="source-line-no">2235</span><span id="line-2235">    rpcServices.checkOpen();</span>
<span class="source-line-no">2236</span><span id="line-2236">    LOG.info("Post open deploy tasks for {}, pid={}, masterSystemTime={}",</span>
<span class="source-line-no">2237</span><span id="line-2237">      r.getRegionInfo().getRegionNameAsString(), openProcId, masterSystemTime);</span>
<span class="source-line-no">2238</span><span id="line-2238">    // Do checks to see if we need to compact (references or too many files)</span>
<span class="source-line-no">2239</span><span id="line-2239">    // Skip compaction check if region is read only</span>
<span class="source-line-no">2240</span><span id="line-2240">    if (!r.isReadOnly()) {</span>
<span class="source-line-no">2241</span><span id="line-2241">      for (HStore s : r.stores.values()) {</span>
<span class="source-line-no">2242</span><span id="line-2242">        if (s.hasReferences() || s.needsCompaction()) {</span>
<span class="source-line-no">2243</span><span id="line-2243">          this.compactSplitThread.requestSystemCompaction(r, s, "Opening Region");</span>
<span class="source-line-no">2244</span><span id="line-2244">        }</span>
<span class="source-line-no">2245</span><span id="line-2245">      }</span>
<span class="source-line-no">2246</span><span id="line-2246">    }</span>
<span class="source-line-no">2247</span><span id="line-2247">    long openSeqNum = r.getOpenSeqNum();</span>
<span class="source-line-no">2248</span><span id="line-2248">    if (openSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">2249</span><span id="line-2249">      // If we opened a region, we should have read some sequence number from it.</span>
<span class="source-line-no">2250</span><span id="line-2250">      LOG.error(</span>
<span class="source-line-no">2251</span><span id="line-2251">        "No sequence number found when opening " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2252</span><span id="line-2252">      openSeqNum = 0;</span>
<span class="source-line-no">2253</span><span id="line-2253">    }</span>
<span class="source-line-no">2254</span><span id="line-2254"></span>
<span class="source-line-no">2255</span><span id="line-2255">    // Notify master</span>
<span class="source-line-no">2256</span><span id="line-2256">    if (</span>
<span class="source-line-no">2257</span><span id="line-2257">      !reportRegionStateTransition(new RegionStateTransitionContext(TransitionCode.OPENED,</span>
<span class="source-line-no">2258</span><span id="line-2258">        openSeqNum, openProcId, masterSystemTime, r.getRegionInfo(), initiatingMasterActiveTime))</span>
<span class="source-line-no">2259</span><span id="line-2259">    ) {</span>
<span class="source-line-no">2260</span><span id="line-2260">      throw new IOException(</span>
<span class="source-line-no">2261</span><span id="line-2261">        "Failed to report opened region to master: " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2262</span><span id="line-2262">    }</span>
<span class="source-line-no">2263</span><span id="line-2263"></span>
<span class="source-line-no">2264</span><span id="line-2264">    triggerFlushInPrimaryRegion(r);</span>
<span class="source-line-no">2265</span><span id="line-2265"></span>
<span class="source-line-no">2266</span><span id="line-2266">    LOG.debug("Finished post open deploy task for " + r.getRegionInfo().getRegionNameAsString());</span>
<span class="source-line-no">2267</span><span id="line-2267">  }</span>
<span class="source-line-no">2268</span><span id="line-2268"></span>
<span class="source-line-no">2269</span><span id="line-2269">  /**</span>
<span class="source-line-no">2270</span><span id="line-2270">   * Helper method for use in tests. Skip the region transition report when there's no master around</span>
<span class="source-line-no">2271</span><span id="line-2271">   * to receive it.</span>
<span class="source-line-no">2272</span><span id="line-2272">   */</span>
<span class="source-line-no">2273</span><span id="line-2273">  private boolean skipReportingTransition(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2274</span><span id="line-2274">    final TransitionCode code = context.getCode();</span>
<span class="source-line-no">2275</span><span id="line-2275">    final long openSeqNum = context.getOpenSeqNum();</span>
<span class="source-line-no">2276</span><span id="line-2276">    long masterSystemTime = context.getMasterSystemTime();</span>
<span class="source-line-no">2277</span><span id="line-2277">    final RegionInfo[] hris = context.getHris();</span>
<span class="source-line-no">2278</span><span id="line-2278"></span>
<span class="source-line-no">2279</span><span id="line-2279">    if (code == TransitionCode.OPENED) {</span>
<span class="source-line-no">2280</span><span id="line-2280">      Preconditions.checkArgument(hris != null &amp;&amp; hris.length == 1);</span>
<span class="source-line-no">2281</span><span id="line-2281">      if (hris[0].isMetaRegion()) {</span>
<span class="source-line-no">2282</span><span id="line-2282">        LOG.warn(</span>
<span class="source-line-no">2283</span><span id="line-2283">          "meta table location is stored in master local store, so we can not skip reporting");</span>
<span class="source-line-no">2284</span><span id="line-2284">        return false;</span>
<span class="source-line-no">2285</span><span id="line-2285">      } else {</span>
<span class="source-line-no">2286</span><span id="line-2286">        try {</span>
<span class="source-line-no">2287</span><span id="line-2287">          MetaTableAccessor.updateRegionLocation(asyncClusterConnection.toConnection(), hris[0],</span>
<span class="source-line-no">2288</span><span id="line-2288">            serverName, openSeqNum, masterSystemTime);</span>
<span class="source-line-no">2289</span><span id="line-2289">        } catch (IOException e) {</span>
<span class="source-line-no">2290</span><span id="line-2290">          LOG.info("Failed to update meta", e);</span>
<span class="source-line-no">2291</span><span id="line-2291">          return false;</span>
<span class="source-line-no">2292</span><span id="line-2292">        }</span>
<span class="source-line-no">2293</span><span id="line-2293">      }</span>
<span class="source-line-no">2294</span><span id="line-2294">    }</span>
<span class="source-line-no">2295</span><span id="line-2295">    return true;</span>
<span class="source-line-no">2296</span><span id="line-2296">  }</span>
<span class="source-line-no">2297</span><span id="line-2297"></span>
<span class="source-line-no">2298</span><span id="line-2298">  private ReportRegionStateTransitionRequest</span>
<span class="source-line-no">2299</span><span id="line-2299">    createReportRegionStateTransitionRequest(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2300</span><span id="line-2300">    final TransitionCode code = context.getCode();</span>
<span class="source-line-no">2301</span><span id="line-2301">    final long openSeqNum = context.getOpenSeqNum();</span>
<span class="source-line-no">2302</span><span id="line-2302">    final RegionInfo[] hris = context.getHris();</span>
<span class="source-line-no">2303</span><span id="line-2303">    final long[] procIds = context.getProcIds();</span>
<span class="source-line-no">2304</span><span id="line-2304"></span>
<span class="source-line-no">2305</span><span id="line-2305">    ReportRegionStateTransitionRequest.Builder builder =</span>
<span class="source-line-no">2306</span><span id="line-2306">      ReportRegionStateTransitionRequest.newBuilder();</span>
<span class="source-line-no">2307</span><span id="line-2307">    builder.setServer(ProtobufUtil.toServerName(serverName));</span>
<span class="source-line-no">2308</span><span id="line-2308">    RegionStateTransition.Builder transition = builder.addTransitionBuilder();</span>
<span class="source-line-no">2309</span><span id="line-2309">    transition.setTransitionCode(code);</span>
<span class="source-line-no">2310</span><span id="line-2310">    if (code == TransitionCode.OPENED &amp;&amp; openSeqNum &gt;= 0) {</span>
<span class="source-line-no">2311</span><span id="line-2311">      transition.setOpenSeqNum(openSeqNum);</span>
<span class="source-line-no">2312</span><span id="line-2312">    }</span>
<span class="source-line-no">2313</span><span id="line-2313">    for (RegionInfo hri : hris) {</span>
<span class="source-line-no">2314</span><span id="line-2314">      transition.addRegionInfo(ProtobufUtil.toRegionInfo(hri));</span>
<span class="source-line-no">2315</span><span id="line-2315">    }</span>
<span class="source-line-no">2316</span><span id="line-2316">    for (long procId : procIds) {</span>
<span class="source-line-no">2317</span><span id="line-2317">      transition.addProcId(procId);</span>
<span class="source-line-no">2318</span><span id="line-2318">    }</span>
<span class="source-line-no">2319</span><span id="line-2319">    transition.setInitiatingMasterActiveTime(context.getInitiatingMasterActiveTime());</span>
<span class="source-line-no">2320</span><span id="line-2320"></span>
<span class="source-line-no">2321</span><span id="line-2321">    return builder.build();</span>
<span class="source-line-no">2322</span><span id="line-2322">  }</span>
<span class="source-line-no">2323</span><span id="line-2323"></span>
<span class="source-line-no">2324</span><span id="line-2324">  @Override</span>
<span class="source-line-no">2325</span><span id="line-2325">  public boolean reportRegionStateTransition(final RegionStateTransitionContext context) {</span>
<span class="source-line-no">2326</span><span id="line-2326">    if (TEST_SKIP_REPORTING_TRANSITION) {</span>
<span class="source-line-no">2327</span><span id="line-2327">      return skipReportingTransition(context);</span>
<span class="source-line-no">2328</span><span id="line-2328">    }</span>
<span class="source-line-no">2329</span><span id="line-2329">    final ReportRegionStateTransitionRequest request =</span>
<span class="source-line-no">2330</span><span id="line-2330">      createReportRegionStateTransitionRequest(context);</span>
<span class="source-line-no">2331</span><span id="line-2331"></span>
<span class="source-line-no">2332</span><span id="line-2332">    int tries = 0;</span>
<span class="source-line-no">2333</span><span id="line-2333">    long pauseTime = this.retryPauseTime;</span>
<span class="source-line-no">2334</span><span id="line-2334">    // Keep looping till we get an error. We want to send reports even though server is going down.</span>
<span class="source-line-no">2335</span><span id="line-2335">    // Only go down if clusterConnection is null. It is set to null almost as last thing as the</span>
<span class="source-line-no">2336</span><span id="line-2336">    // HRegionServer does down.</span>
<span class="source-line-no">2337</span><span id="line-2337">    while (this.asyncClusterConnection != null &amp;&amp; !this.asyncClusterConnection.isClosed()) {</span>
<span class="source-line-no">2338</span><span id="line-2338">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2339</span><span id="line-2339">      try {</span>
<span class="source-line-no">2340</span><span id="line-2340">        if (rss == null) {</span>
<span class="source-line-no">2341</span><span id="line-2341">          createRegionServerStatusStub();</span>
<span class="source-line-no">2342</span><span id="line-2342">          continue;</span>
<span class="source-line-no">2343</span><span id="line-2343">        }</span>
<span class="source-line-no">2344</span><span id="line-2344">        ReportRegionStateTransitionResponse response =</span>
<span class="source-line-no">2345</span><span id="line-2345">          rss.reportRegionStateTransition(null, request);</span>
<span class="source-line-no">2346</span><span id="line-2346">        if (response.hasErrorMessage()) {</span>
<span class="source-line-no">2347</span><span id="line-2347">          LOG.info("TRANSITION FAILED " + request + ": " + response.getErrorMessage());</span>
<span class="source-line-no">2348</span><span id="line-2348">          break;</span>
<span class="source-line-no">2349</span><span id="line-2349">        }</span>
<span class="source-line-no">2350</span><span id="line-2350">        // Log if we had to retry else don't log unless TRACE. We want to</span>
<span class="source-line-no">2351</span><span id="line-2351">        // know if were successful after an attempt showed in logs as failed.</span>
<span class="source-line-no">2352</span><span id="line-2352">        if (tries &gt; 0 || LOG.isTraceEnabled()) {</span>
<span class="source-line-no">2353</span><span id="line-2353">          LOG.info("TRANSITION REPORTED " + request);</span>
<span class="source-line-no">2354</span><span id="line-2354">        }</span>
<span class="source-line-no">2355</span><span id="line-2355">        // NOTE: Return mid-method!!!</span>
<span class="source-line-no">2356</span><span id="line-2356">        return true;</span>
<span class="source-line-no">2357</span><span id="line-2357">      } catch (ServiceException se) {</span>
<span class="source-line-no">2358</span><span id="line-2358">        IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">2359</span><span id="line-2359">        boolean pause = ioe instanceof ServerNotRunningYetException</span>
<span class="source-line-no">2360</span><span id="line-2360">          || ioe instanceof PleaseHoldException || ioe instanceof CallQueueTooBigException;</span>
<span class="source-line-no">2361</span><span id="line-2361">        if (pause) {</span>
<span class="source-line-no">2362</span><span id="line-2362">          // Do backoff else we flood the Master with requests.</span>
<span class="source-line-no">2363</span><span id="line-2363">          pauseTime = ConnectionUtils.getPauseTime(this.retryPauseTime, tries);</span>
<span class="source-line-no">2364</span><span id="line-2364">        } else {</span>
<span class="source-line-no">2365</span><span id="line-2365">          pauseTime = this.retryPauseTime; // Reset.</span>
<span class="source-line-no">2366</span><span id="line-2366">        }</span>
<span class="source-line-no">2367</span><span id="line-2367">        LOG.info("Failed report transition " + TextFormat.shortDebugString(request) + "; retry (#"</span>
<span class="source-line-no">2368</span><span id="line-2368">          + tries + ")"</span>
<span class="source-line-no">2369</span><span id="line-2369">          + (pause</span>
<span class="source-line-no">2370</span><span id="line-2370">            ? " after " + pauseTime + "ms delay (Master is coming online...)."</span>
<span class="source-line-no">2371</span><span id="line-2371">            : " immediately."),</span>
<span class="source-line-no">2372</span><span id="line-2372">          ioe);</span>
<span class="source-line-no">2373</span><span id="line-2373">        if (pause) {</span>
<span class="source-line-no">2374</span><span id="line-2374">          Threads.sleep(pauseTime);</span>
<span class="source-line-no">2375</span><span id="line-2375">        }</span>
<span class="source-line-no">2376</span><span id="line-2376">        tries++;</span>
<span class="source-line-no">2377</span><span id="line-2377">        if (rssStub == rss) {</span>
<span class="source-line-no">2378</span><span id="line-2378">          rssStub = null;</span>
<span class="source-line-no">2379</span><span id="line-2379">        }</span>
<span class="source-line-no">2380</span><span id="line-2380">      }</span>
<span class="source-line-no">2381</span><span id="line-2381">    }</span>
<span class="source-line-no">2382</span><span id="line-2382">    return false;</span>
<span class="source-line-no">2383</span><span id="line-2383">  }</span>
<span class="source-line-no">2384</span><span id="line-2384"></span>
<span class="source-line-no">2385</span><span id="line-2385">  /**</span>
<span class="source-line-no">2386</span><span id="line-2386">   * Trigger a flush in the primary region replica if this region is a secondary replica. Does not</span>
<span class="source-line-no">2387</span><span id="line-2387">   * block this thread. See RegionReplicaFlushHandler for details.</span>
<span class="source-line-no">2388</span><span id="line-2388">   */</span>
<span class="source-line-no">2389</span><span id="line-2389">  private void triggerFlushInPrimaryRegion(final HRegion region) {</span>
<span class="source-line-no">2390</span><span id="line-2390">    if (ServerRegionReplicaUtil.isDefaultReplica(region.getRegionInfo())) {</span>
<span class="source-line-no">2391</span><span id="line-2391">      return;</span>
<span class="source-line-no">2392</span><span id="line-2392">    }</span>
<span class="source-line-no">2393</span><span id="line-2393">    TableName tn = region.getTableDescriptor().getTableName();</span>
<span class="source-line-no">2394</span><span id="line-2394">    if (</span>
<span class="source-line-no">2395</span><span id="line-2395">      !ServerRegionReplicaUtil.isRegionReplicaReplicationEnabled(region.conf, tn)</span>
<span class="source-line-no">2396</span><span id="line-2396">        || !ServerRegionReplicaUtil.isRegionReplicaWaitForPrimaryFlushEnabled(region.conf) ||</span>
<span class="source-line-no">2397</span><span id="line-2397">        // If the memstore replication not setup, we do not have to wait for observing a flush event</span>
<span class="source-line-no">2398</span><span id="line-2398">        // from primary before starting to serve reads, because gaps from replication is not</span>
<span class="source-line-no">2399</span><span id="line-2399">        // applicable,this logic is from</span>
<span class="source-line-no">2400</span><span id="line-2400">        // TableDescriptorBuilder.ModifyableTableDescriptor.setRegionMemStoreReplication by</span>
<span class="source-line-no">2401</span><span id="line-2401">        // HBASE-13063</span>
<span class="source-line-no">2402</span><span id="line-2402">        !region.getTableDescriptor().hasRegionMemStoreReplication()</span>
<span class="source-line-no">2403</span><span id="line-2403">    ) {</span>
<span class="source-line-no">2404</span><span id="line-2404">      region.setReadsEnabled(true);</span>
<span class="source-line-no">2405</span><span id="line-2405">      return;</span>
<span class="source-line-no">2406</span><span id="line-2406">    }</span>
<span class="source-line-no">2407</span><span id="line-2407"></span>
<span class="source-line-no">2408</span><span id="line-2408">    region.setReadsEnabled(false); // disable reads before marking the region as opened.</span>
<span class="source-line-no">2409</span><span id="line-2409">    // RegionReplicaFlushHandler might reset this.</span>
<span class="source-line-no">2410</span><span id="line-2410"></span>
<span class="source-line-no">2411</span><span id="line-2411">    // Submit it to be handled by one of the handlers so that we do not block OpenRegionHandler</span>
<span class="source-line-no">2412</span><span id="line-2412">    if (this.executorService != null) {</span>
<span class="source-line-no">2413</span><span id="line-2413">      this.executorService.submit(new RegionReplicaFlushHandler(this, region));</span>
<span class="source-line-no">2414</span><span id="line-2414">    } else {</span>
<span class="source-line-no">2415</span><span id="line-2415">      LOG.info("Executor is null; not running flush of primary region replica for {}",</span>
<span class="source-line-no">2416</span><span id="line-2416">        region.getRegionInfo());</span>
<span class="source-line-no">2417</span><span id="line-2417">    }</span>
<span class="source-line-no">2418</span><span id="line-2418">  }</span>
<span class="source-line-no">2419</span><span id="line-2419"></span>
<span class="source-line-no">2420</span><span id="line-2420">  @InterfaceAudience.Private</span>
<span class="source-line-no">2421</span><span id="line-2421">  public RSRpcServices getRSRpcServices() {</span>
<span class="source-line-no">2422</span><span id="line-2422">    return rpcServices;</span>
<span class="source-line-no">2423</span><span id="line-2423">  }</span>
<span class="source-line-no">2424</span><span id="line-2424"></span>
<span class="source-line-no">2425</span><span id="line-2425">  /**</span>
<span class="source-line-no">2426</span><span id="line-2426">   * Cause the server to exit without closing the regions it is serving, the log it is using and</span>
<span class="source-line-no">2427</span><span id="line-2427">   * without notifying the master. Used unit testing and on catastrophic events such as HDFS is</span>
<span class="source-line-no">2428</span><span id="line-2428">   * yanked out from under hbase or we OOME. the reason we are aborting the exception that caused</span>
<span class="source-line-no">2429</span><span id="line-2429">   * the abort, or null</span>
<span class="source-line-no">2430</span><span id="line-2430">   */</span>
<span class="source-line-no">2431</span><span id="line-2431">  @Override</span>
<span class="source-line-no">2432</span><span id="line-2432">  public void abort(String reason, Throwable cause) {</span>
<span class="source-line-no">2433</span><span id="line-2433">    if (!setAbortRequested()) {</span>
<span class="source-line-no">2434</span><span id="line-2434">      // Abort already in progress, ignore the new request.</span>
<span class="source-line-no">2435</span><span id="line-2435">      LOG.debug("Abort already in progress. Ignoring the current request with reason: {}", reason);</span>
<span class="source-line-no">2436</span><span id="line-2436">      return;</span>
<span class="source-line-no">2437</span><span id="line-2437">    }</span>
<span class="source-line-no">2438</span><span id="line-2438">    String msg = "***** ABORTING region server " + this + ": " + reason + " *****";</span>
<span class="source-line-no">2439</span><span id="line-2439">    if (cause != null) {</span>
<span class="source-line-no">2440</span><span id="line-2440">      LOG.error(HBaseMarkers.FATAL, msg, cause);</span>
<span class="source-line-no">2441</span><span id="line-2441">    } else {</span>
<span class="source-line-no">2442</span><span id="line-2442">      LOG.error(HBaseMarkers.FATAL, msg);</span>
<span class="source-line-no">2443</span><span id="line-2443">    }</span>
<span class="source-line-no">2444</span><span id="line-2444">    // HBASE-4014: show list of coprocessors that were loaded to help debug</span>
<span class="source-line-no">2445</span><span id="line-2445">    // regionserver crashes.Note that we're implicitly using</span>
<span class="source-line-no">2446</span><span id="line-2446">    // java.util.HashSet's toString() method to print the coprocessor names.</span>
<span class="source-line-no">2447</span><span id="line-2447">    LOG.error(HBaseMarkers.FATAL,</span>
<span class="source-line-no">2448</span><span id="line-2448">      "RegionServer abort: loaded coprocessors are: " + CoprocessorHost.getLoadedCoprocessors());</span>
<span class="source-line-no">2449</span><span id="line-2449">    // Try and dump metrics if abort -- might give clue as to how fatal came about....</span>
<span class="source-line-no">2450</span><span id="line-2450">    try {</span>
<span class="source-line-no">2451</span><span id="line-2451">      LOG.info("Dump of metrics as JSON on abort: " + DumpRegionServerMetrics.dumpMetrics());</span>
<span class="source-line-no">2452</span><span id="line-2452">    } catch (MalformedObjectNameException | IOException e) {</span>
<span class="source-line-no">2453</span><span id="line-2453">      LOG.warn("Failed dumping metrics", e);</span>
<span class="source-line-no">2454</span><span id="line-2454">    }</span>
<span class="source-line-no">2455</span><span id="line-2455"></span>
<span class="source-line-no">2456</span><span id="line-2456">    // Do our best to report our abort to the master, but this may not work</span>
<span class="source-line-no">2457</span><span id="line-2457">    try {</span>
<span class="source-line-no">2458</span><span id="line-2458">      if (cause != null) {</span>
<span class="source-line-no">2459</span><span id="line-2459">        msg += "\nCause:\n" + Throwables.getStackTraceAsString(cause);</span>
<span class="source-line-no">2460</span><span id="line-2460">      }</span>
<span class="source-line-no">2461</span><span id="line-2461">      // Report to the master but only if we have already registered with the master.</span>
<span class="source-line-no">2462</span><span id="line-2462">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2463</span><span id="line-2463">      if (rss != null &amp;&amp; this.serverName != null) {</span>
<span class="source-line-no">2464</span><span id="line-2464">        ReportRSFatalErrorRequest.Builder builder = ReportRSFatalErrorRequest.newBuilder();</span>
<span class="source-line-no">2465</span><span id="line-2465">        builder.setServer(ProtobufUtil.toServerName(this.serverName));</span>
<span class="source-line-no">2466</span><span id="line-2466">        builder.setErrorMessage(msg);</span>
<span class="source-line-no">2467</span><span id="line-2467">        rss.reportRSFatalError(null, builder.build());</span>
<span class="source-line-no">2468</span><span id="line-2468">      }</span>
<span class="source-line-no">2469</span><span id="line-2469">    } catch (Throwable t) {</span>
<span class="source-line-no">2470</span><span id="line-2470">      LOG.warn("Unable to report fatal error to master", t);</span>
<span class="source-line-no">2471</span><span id="line-2471">    }</span>
<span class="source-line-no">2472</span><span id="line-2472"></span>
<span class="source-line-no">2473</span><span id="line-2473">    scheduleAbortTimer();</span>
<span class="source-line-no">2474</span><span id="line-2474">    // shutdown should be run as the internal user</span>
<span class="source-line-no">2475</span><span id="line-2475">    stop(reason, true, null);</span>
<span class="source-line-no">2476</span><span id="line-2476">  }</span>
<span class="source-line-no">2477</span><span id="line-2477"></span>
<span class="source-line-no">2478</span><span id="line-2478">  /*</span>
<span class="source-line-no">2479</span><span id="line-2479">   * Simulate a kill -9 of this server. Exits w/o closing regions or cleaninup logs but it does</span>
<span class="source-line-no">2480</span><span id="line-2480">   * close socket in case want to bring up server on old hostname+port immediately.</span>
<span class="source-line-no">2481</span><span id="line-2481">   */</span>
<span class="source-line-no">2482</span><span id="line-2482">  @InterfaceAudience.Private</span>
<span class="source-line-no">2483</span><span id="line-2483">  protected void kill() {</span>
<span class="source-line-no">2484</span><span id="line-2484">    this.killed = true;</span>
<span class="source-line-no">2485</span><span id="line-2485">    abort("Simulated kill");</span>
<span class="source-line-no">2486</span><span id="line-2486">  }</span>
<span class="source-line-no">2487</span><span id="line-2487"></span>
<span class="source-line-no">2488</span><span id="line-2488">  // Limits the time spent in the shutdown process.</span>
<span class="source-line-no">2489</span><span id="line-2489">  private void scheduleAbortTimer() {</span>
<span class="source-line-no">2490</span><span id="line-2490">    if (this.abortMonitor == null) {</span>
<span class="source-line-no">2491</span><span id="line-2491">      this.abortMonitor = new Timer("Abort regionserver monitor", true);</span>
<span class="source-line-no">2492</span><span id="line-2492">      TimerTask abortTimeoutTask = null;</span>
<span class="source-line-no">2493</span><span id="line-2493">      try {</span>
<span class="source-line-no">2494</span><span id="line-2494">        Constructor&lt;? extends TimerTask&gt; timerTaskCtor =</span>
<span class="source-line-no">2495</span><span id="line-2495">          Class.forName(conf.get(ABORT_TIMEOUT_TASK, SystemExitWhenAbortTimeout.class.getName()))</span>
<span class="source-line-no">2496</span><span id="line-2496">            .asSubclass(TimerTask.class).getDeclaredConstructor();</span>
<span class="source-line-no">2497</span><span id="line-2497">        timerTaskCtor.setAccessible(true);</span>
<span class="source-line-no">2498</span><span id="line-2498">        abortTimeoutTask = timerTaskCtor.newInstance();</span>
<span class="source-line-no">2499</span><span id="line-2499">      } catch (Exception e) {</span>
<span class="source-line-no">2500</span><span id="line-2500">        LOG.warn("Initialize abort timeout task failed", e);</span>
<span class="source-line-no">2501</span><span id="line-2501">      }</span>
<span class="source-line-no">2502</span><span id="line-2502">      if (abortTimeoutTask != null) {</span>
<span class="source-line-no">2503</span><span id="line-2503">        abortMonitor.schedule(abortTimeoutTask, conf.getLong(ABORT_TIMEOUT, DEFAULT_ABORT_TIMEOUT));</span>
<span class="source-line-no">2504</span><span id="line-2504">      }</span>
<span class="source-line-no">2505</span><span id="line-2505">    }</span>
<span class="source-line-no">2506</span><span id="line-2506">  }</span>
<span class="source-line-no">2507</span><span id="line-2507"></span>
<span class="source-line-no">2508</span><span id="line-2508">  /**</span>
<span class="source-line-no">2509</span><span id="line-2509">   * Wait on all threads to finish. Presumption is that all closes and stops have already been</span>
<span class="source-line-no">2510</span><span id="line-2510">   * called.</span>
<span class="source-line-no">2511</span><span id="line-2511">   */</span>
<span class="source-line-no">2512</span><span id="line-2512">  protected void stopServiceThreads() {</span>
<span class="source-line-no">2513</span><span id="line-2513">    // clean up the scheduled chores</span>
<span class="source-line-no">2514</span><span id="line-2514">    stopChoreService();</span>
<span class="source-line-no">2515</span><span id="line-2515">    if (bootstrapNodeManager != null) {</span>
<span class="source-line-no">2516</span><span id="line-2516">      bootstrapNodeManager.stop();</span>
<span class="source-line-no">2517</span><span id="line-2517">    }</span>
<span class="source-line-no">2518</span><span id="line-2518">    if (this.cacheFlusher != null) {</span>
<span class="source-line-no">2519</span><span id="line-2519">      this.cacheFlusher.shutdown();</span>
<span class="source-line-no">2520</span><span id="line-2520">    }</span>
<span class="source-line-no">2521</span><span id="line-2521">    if (this.walRoller != null) {</span>
<span class="source-line-no">2522</span><span id="line-2522">      this.walRoller.close();</span>
<span class="source-line-no">2523</span><span id="line-2523">    }</span>
<span class="source-line-no">2524</span><span id="line-2524">    if (this.compactSplitThread != null) {</span>
<span class="source-line-no">2525</span><span id="line-2525">      this.compactSplitThread.join();</span>
<span class="source-line-no">2526</span><span id="line-2526">    }</span>
<span class="source-line-no">2527</span><span id="line-2527">    stopExecutorService();</span>
<span class="source-line-no">2528</span><span id="line-2528">    if (sameReplicationSourceAndSink &amp;&amp; this.replicationSourceHandler != null) {</span>
<span class="source-line-no">2529</span><span id="line-2529">      this.replicationSourceHandler.stopReplicationService();</span>
<span class="source-line-no">2530</span><span id="line-2530">    } else {</span>
<span class="source-line-no">2531</span><span id="line-2531">      if (this.replicationSourceHandler != null) {</span>
<span class="source-line-no">2532</span><span id="line-2532">        this.replicationSourceHandler.stopReplicationService();</span>
<span class="source-line-no">2533</span><span id="line-2533">      }</span>
<span class="source-line-no">2534</span><span id="line-2534">      if (this.replicationSinkHandler != null) {</span>
<span class="source-line-no">2535</span><span id="line-2535">        this.replicationSinkHandler.stopReplicationService();</span>
<span class="source-line-no">2536</span><span id="line-2536">      }</span>
<span class="source-line-no">2537</span><span id="line-2537">    }</span>
<span class="source-line-no">2538</span><span id="line-2538">  }</span>
<span class="source-line-no">2539</span><span id="line-2539"></span>
<span class="source-line-no">2540</span><span id="line-2540">  /** Returns Return the object that implements the replication source executorService. */</span>
<span class="source-line-no">2541</span><span id="line-2541">  @Override</span>
<span class="source-line-no">2542</span><span id="line-2542">  public ReplicationSourceService getReplicationSourceService() {</span>
<span class="source-line-no">2543</span><span id="line-2543">    return replicationSourceHandler;</span>
<span class="source-line-no">2544</span><span id="line-2544">  }</span>
<span class="source-line-no">2545</span><span id="line-2545"></span>
<span class="source-line-no">2546</span><span id="line-2546">  /** Returns Return the object that implements the replication sink executorService. */</span>
<span class="source-line-no">2547</span><span id="line-2547">  public ReplicationSinkService getReplicationSinkService() {</span>
<span class="source-line-no">2548</span><span id="line-2548">    return replicationSinkHandler;</span>
<span class="source-line-no">2549</span><span id="line-2549">  }</span>
<span class="source-line-no">2550</span><span id="line-2550"></span>
<span class="source-line-no">2551</span><span id="line-2551">  /**</span>
<span class="source-line-no">2552</span><span id="line-2552">   * Get the current master from ZooKeeper and open the RPC connection to it. To get a fresh</span>
<span class="source-line-no">2553</span><span id="line-2553">   * connection, the current rssStub must be null. Method will block until a master is available.</span>
<span class="source-line-no">2554</span><span id="line-2554">   * You can break from this block by requesting the server stop.</span>
<span class="source-line-no">2555</span><span id="line-2555">   * @return master + port, or null if server has been stopped</span>
<span class="source-line-no">2556</span><span id="line-2556">   */</span>
<span class="source-line-no">2557</span><span id="line-2557">  private synchronized ServerName createRegionServerStatusStub() {</span>
<span class="source-line-no">2558</span><span id="line-2558">    // Create RS stub without refreshing the master node from ZK, use cached data</span>
<span class="source-line-no">2559</span><span id="line-2559">    return createRegionServerStatusStub(false);</span>
<span class="source-line-no">2560</span><span id="line-2560">  }</span>
<span class="source-line-no">2561</span><span id="line-2561"></span>
<span class="source-line-no">2562</span><span id="line-2562">  /**</span>
<span class="source-line-no">2563</span><span id="line-2563">   * Get the current master from ZooKeeper and open the RPC connection to it. To get a fresh</span>
<span class="source-line-no">2564</span><span id="line-2564">   * connection, the current rssStub must be null. Method will block until a master is available.</span>
<span class="source-line-no">2565</span><span id="line-2565">   * You can break from this block by requesting the server stop.</span>
<span class="source-line-no">2566</span><span id="line-2566">   * @param refresh If true then master address will be read from ZK, otherwise use cached data</span>
<span class="source-line-no">2567</span><span id="line-2567">   * @return master + port, or null if server has been stopped</span>
<span class="source-line-no">2568</span><span id="line-2568">   */</span>
<span class="source-line-no">2569</span><span id="line-2569">  @InterfaceAudience.Private</span>
<span class="source-line-no">2570</span><span id="line-2570">  protected synchronized ServerName createRegionServerStatusStub(boolean refresh) {</span>
<span class="source-line-no">2571</span><span id="line-2571">    if (rssStub != null) {</span>
<span class="source-line-no">2572</span><span id="line-2572">      return masterAddressTracker.getMasterAddress();</span>
<span class="source-line-no">2573</span><span id="line-2573">    }</span>
<span class="source-line-no">2574</span><span id="line-2574">    ServerName sn = null;</span>
<span class="source-line-no">2575</span><span id="line-2575">    long previousLogTime = 0;</span>
<span class="source-line-no">2576</span><span id="line-2576">    RegionServerStatusService.BlockingInterface intRssStub = null;</span>
<span class="source-line-no">2577</span><span id="line-2577">    LockService.BlockingInterface intLockStub = null;</span>
<span class="source-line-no">2578</span><span id="line-2578">    boolean interrupted = false;</span>
<span class="source-line-no">2579</span><span id="line-2579">    try {</span>
<span class="source-line-no">2580</span><span id="line-2580">      while (keepLooping()) {</span>
<span class="source-line-no">2581</span><span id="line-2581">        sn = this.masterAddressTracker.getMasterAddress(refresh);</span>
<span class="source-line-no">2582</span><span id="line-2582">        if (sn == null) {</span>
<span class="source-line-no">2583</span><span id="line-2583">          if (!keepLooping()) {</span>
<span class="source-line-no">2584</span><span id="line-2584">            // give up with no connection.</span>
<span class="source-line-no">2585</span><span id="line-2585">            LOG.debug("No master found and cluster is stopped; bailing out");</span>
<span class="source-line-no">2586</span><span id="line-2586">            return null;</span>
<span class="source-line-no">2587</span><span id="line-2587">          }</span>
<span class="source-line-no">2588</span><span id="line-2588">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">2589</span><span id="line-2589">            LOG.debug("No master found; retry");</span>
<span class="source-line-no">2590</span><span id="line-2590">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2591</span><span id="line-2591">          }</span>
<span class="source-line-no">2592</span><span id="line-2592">          refresh = true; // let's try pull it from ZK directly</span>
<span class="source-line-no">2593</span><span id="line-2593">          if (sleepInterrupted(200)) {</span>
<span class="source-line-no">2594</span><span id="line-2594">            interrupted = true;</span>
<span class="source-line-no">2595</span><span id="line-2595">          }</span>
<span class="source-line-no">2596</span><span id="line-2596">          continue;</span>
<span class="source-line-no">2597</span><span id="line-2597">        }</span>
<span class="source-line-no">2598</span><span id="line-2598">        try {</span>
<span class="source-line-no">2599</span><span id="line-2599">          BlockingRpcChannel channel = this.rpcClient.createBlockingRpcChannel(sn,</span>
<span class="source-line-no">2600</span><span id="line-2600">            userProvider.getCurrent(), shortOperationTimeout);</span>
<span class="source-line-no">2601</span><span id="line-2601">          intRssStub = RegionServerStatusService.newBlockingStub(channel);</span>
<span class="source-line-no">2602</span><span id="line-2602">          intLockStub = LockService.newBlockingStub(channel);</span>
<span class="source-line-no">2603</span><span id="line-2603">          break;</span>
<span class="source-line-no">2604</span><span id="line-2604">        } catch (IOException e) {</span>
<span class="source-line-no">2605</span><span id="line-2605">          if (EnvironmentEdgeManager.currentTime() &gt; (previousLogTime + 1000)) {</span>
<span class="source-line-no">2606</span><span id="line-2606">            e = e instanceof RemoteException ? ((RemoteException) e).unwrapRemoteException() : e;</span>
<span class="source-line-no">2607</span><span id="line-2607">            if (e instanceof ServerNotRunningYetException) {</span>
<span class="source-line-no">2608</span><span id="line-2608">              LOG.info("Master isn't available yet, retrying");</span>
<span class="source-line-no">2609</span><span id="line-2609">            } else {</span>
<span class="source-line-no">2610</span><span id="line-2610">              LOG.warn("Unable to connect to master. Retrying. Error was:", e);</span>
<span class="source-line-no">2611</span><span id="line-2611">            }</span>
<span class="source-line-no">2612</span><span id="line-2612">            previousLogTime = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2613</span><span id="line-2613">          }</span>
<span class="source-line-no">2614</span><span id="line-2614">          if (sleepInterrupted(200)) {</span>
<span class="source-line-no">2615</span><span id="line-2615">            interrupted = true;</span>
<span class="source-line-no">2616</span><span id="line-2616">          }</span>
<span class="source-line-no">2617</span><span id="line-2617">        }</span>
<span class="source-line-no">2618</span><span id="line-2618">      }</span>
<span class="source-line-no">2619</span><span id="line-2619">    } finally {</span>
<span class="source-line-no">2620</span><span id="line-2620">      if (interrupted) {</span>
<span class="source-line-no">2621</span><span id="line-2621">        Thread.currentThread().interrupt();</span>
<span class="source-line-no">2622</span><span id="line-2622">      }</span>
<span class="source-line-no">2623</span><span id="line-2623">    }</span>
<span class="source-line-no">2624</span><span id="line-2624">    this.rssStub = intRssStub;</span>
<span class="source-line-no">2625</span><span id="line-2625">    this.lockStub = intLockStub;</span>
<span class="source-line-no">2626</span><span id="line-2626">    return sn;</span>
<span class="source-line-no">2627</span><span id="line-2627">  }</span>
<span class="source-line-no">2628</span><span id="line-2628"></span>
<span class="source-line-no">2629</span><span id="line-2629">  /**</span>
<span class="source-line-no">2630</span><span id="line-2630">   * @return True if we should break loop because cluster is going down or this server has been</span>
<span class="source-line-no">2631</span><span id="line-2631">   *         stopped or hdfs has gone bad.</span>
<span class="source-line-no">2632</span><span id="line-2632">   */</span>
<span class="source-line-no">2633</span><span id="line-2633">  private boolean keepLooping() {</span>
<span class="source-line-no">2634</span><span id="line-2634">    return !this.stopped &amp;&amp; isClusterUp();</span>
<span class="source-line-no">2635</span><span id="line-2635">  }</span>
<span class="source-line-no">2636</span><span id="line-2636"></span>
<span class="source-line-no">2637</span><span id="line-2637">  /*</span>
<span class="source-line-no">2638</span><span id="line-2638">   * Let the master know we're here Run initialization using parameters passed us by the master.</span>
<span class="source-line-no">2639</span><span id="line-2639">   * @return A Map of key/value configurations we got from the Master else null if we failed to</span>
<span class="source-line-no">2640</span><span id="line-2640">   * register.</span>
<span class="source-line-no">2641</span><span id="line-2641">   */</span>
<span class="source-line-no">2642</span><span id="line-2642">  private RegionServerStartupResponse reportForDuty() throws IOException {</span>
<span class="source-line-no">2643</span><span id="line-2643">    if (this.masterless) {</span>
<span class="source-line-no">2644</span><span id="line-2644">      return RegionServerStartupResponse.getDefaultInstance();</span>
<span class="source-line-no">2645</span><span id="line-2645">    }</span>
<span class="source-line-no">2646</span><span id="line-2646">    ServerName masterServerName = createRegionServerStatusStub(true);</span>
<span class="source-line-no">2647</span><span id="line-2647">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2648</span><span id="line-2648">    if (masterServerName == null || rss == null) {</span>
<span class="source-line-no">2649</span><span id="line-2649">      return null;</span>
<span class="source-line-no">2650</span><span id="line-2650">    }</span>
<span class="source-line-no">2651</span><span id="line-2651">    RegionServerStartupResponse result = null;</span>
<span class="source-line-no">2652</span><span id="line-2652">    try {</span>
<span class="source-line-no">2653</span><span id="line-2653">      rpcServices.requestCount.reset();</span>
<span class="source-line-no">2654</span><span id="line-2654">      rpcServices.rpcGetRequestCount.reset();</span>
<span class="source-line-no">2655</span><span id="line-2655">      rpcServices.rpcScanRequestCount.reset();</span>
<span class="source-line-no">2656</span><span id="line-2656">      rpcServices.rpcFullScanRequestCount.reset();</span>
<span class="source-line-no">2657</span><span id="line-2657">      rpcServices.rpcMultiRequestCount.reset();</span>
<span class="source-line-no">2658</span><span id="line-2658">      rpcServices.rpcMutateRequestCount.reset();</span>
<span class="source-line-no">2659</span><span id="line-2659">      LOG.info("reportForDuty to master=" + masterServerName + " with port="</span>
<span class="source-line-no">2660</span><span id="line-2660">        + rpcServices.getSocketAddress().getPort() + ", startcode=" + this.startcode);</span>
<span class="source-line-no">2661</span><span id="line-2661">      long now = EnvironmentEdgeManager.currentTime();</span>
<span class="source-line-no">2662</span><span id="line-2662">      int port = rpcServices.getSocketAddress().getPort();</span>
<span class="source-line-no">2663</span><span id="line-2663">      RegionServerStartupRequest.Builder request = RegionServerStartupRequest.newBuilder();</span>
<span class="source-line-no">2664</span><span id="line-2664">      if (!StringUtils.isBlank(useThisHostnameInstead)) {</span>
<span class="source-line-no">2665</span><span id="line-2665">        request.setUseThisHostnameInstead(useThisHostnameInstead);</span>
<span class="source-line-no">2666</span><span id="line-2666">      }</span>
<span class="source-line-no">2667</span><span id="line-2667">      request.setPort(port);</span>
<span class="source-line-no">2668</span><span id="line-2668">      request.setServerStartCode(this.startcode);</span>
<span class="source-line-no">2669</span><span id="line-2669">      request.setServerCurrentTime(now);</span>
<span class="source-line-no">2670</span><span id="line-2670">      result = rss.regionServerStartup(null, request.build());</span>
<span class="source-line-no">2671</span><span id="line-2671">    } catch (ServiceException se) {</span>
<span class="source-line-no">2672</span><span id="line-2672">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">2673</span><span id="line-2673">      if (ioe instanceof ClockOutOfSyncException) {</span>
<span class="source-line-no">2674</span><span id="line-2674">        LOG.error(HBaseMarkers.FATAL, "Master rejected startup because clock is out of sync", ioe);</span>
<span class="source-line-no">2675</span><span id="line-2675">        // Re-throw IOE will cause RS to abort</span>
<span class="source-line-no">2676</span><span id="line-2676">        throw ioe;</span>
<span class="source-line-no">2677</span><span id="line-2677">      } else if (ioe instanceof DecommissionedHostRejectedException) {</span>
<span class="source-line-no">2678</span><span id="line-2678">        LOG.error(HBaseMarkers.FATAL,</span>
<span class="source-line-no">2679</span><span id="line-2679">          "Master rejected startup because the host is considered decommissioned", ioe);</span>
<span class="source-line-no">2680</span><span id="line-2680">        // Re-throw IOE will cause RS to abort</span>
<span class="source-line-no">2681</span><span id="line-2681">        throw ioe;</span>
<span class="source-line-no">2682</span><span id="line-2682">      } else if (ioe instanceof ServerNotRunningYetException) {</span>
<span class="source-line-no">2683</span><span id="line-2683">        LOG.debug("Master is not running yet");</span>
<span class="source-line-no">2684</span><span id="line-2684">      } else {</span>
<span class="source-line-no">2685</span><span id="line-2685">        LOG.warn("error telling master we are up", se);</span>
<span class="source-line-no">2686</span><span id="line-2686">      }</span>
<span class="source-line-no">2687</span><span id="line-2687">      rssStub = null;</span>
<span class="source-line-no">2688</span><span id="line-2688">    }</span>
<span class="source-line-no">2689</span><span id="line-2689">    return result;</span>
<span class="source-line-no">2690</span><span id="line-2690">  }</span>
<span class="source-line-no">2691</span><span id="line-2691"></span>
<span class="source-line-no">2692</span><span id="line-2692">  @Override</span>
<span class="source-line-no">2693</span><span id="line-2693">  public RegionStoreSequenceIds getLastSequenceId(byte[] encodedRegionName) {</span>
<span class="source-line-no">2694</span><span id="line-2694">    try {</span>
<span class="source-line-no">2695</span><span id="line-2695">      GetLastFlushedSequenceIdRequest req =</span>
<span class="source-line-no">2696</span><span id="line-2696">        RequestConverter.buildGetLastFlushedSequenceIdRequest(encodedRegionName);</span>
<span class="source-line-no">2697</span><span id="line-2697">      RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">2698</span><span id="line-2698">      if (rss == null) { // Try to connect one more time</span>
<span class="source-line-no">2699</span><span id="line-2699">        createRegionServerStatusStub();</span>
<span class="source-line-no">2700</span><span id="line-2700">        rss = rssStub;</span>
<span class="source-line-no">2701</span><span id="line-2701">        if (rss == null) {</span>
<span class="source-line-no">2702</span><span id="line-2702">          // Still no luck, we tried</span>
<span class="source-line-no">2703</span><span id="line-2703">          LOG.warn("Unable to connect to the master to check " + "the last flushed sequence id");</span>
<span class="source-line-no">2704</span><span id="line-2704">          return RegionStoreSequenceIds.newBuilder().setLastFlushedSequenceId(HConstants.NO_SEQNUM)</span>
<span class="source-line-no">2705</span><span id="line-2705">            .build();</span>
<span class="source-line-no">2706</span><span id="line-2706">        }</span>
<span class="source-line-no">2707</span><span id="line-2707">      }</span>
<span class="source-line-no">2708</span><span id="line-2708">      GetLastFlushedSequenceIdResponse resp = rss.getLastFlushedSequenceId(null, req);</span>
<span class="source-line-no">2709</span><span id="line-2709">      return RegionStoreSequenceIds.newBuilder()</span>
<span class="source-line-no">2710</span><span id="line-2710">        .setLastFlushedSequenceId(resp.getLastFlushedSequenceId())</span>
<span class="source-line-no">2711</span><span id="line-2711">        .addAllStoreSequenceId(resp.getStoreLastFlushedSequenceIdList()).build();</span>
<span class="source-line-no">2712</span><span id="line-2712">    } catch (ServiceException e) {</span>
<span class="source-line-no">2713</span><span id="line-2713">      LOG.warn("Unable to connect to the master to check the last flushed sequence id", e);</span>
<span class="source-line-no">2714</span><span id="line-2714">      return RegionStoreSequenceIds.newBuilder().setLastFlushedSequenceId(HConstants.NO_SEQNUM)</span>
<span class="source-line-no">2715</span><span id="line-2715">        .build();</span>
<span class="source-line-no">2716</span><span id="line-2716">    }</span>
<span class="source-line-no">2717</span><span id="line-2717">  }</span>
<span class="source-line-no">2718</span><span id="line-2718"></span>
<span class="source-line-no">2719</span><span id="line-2719">  /**</span>
<span class="source-line-no">2720</span><span id="line-2720">   * Close meta region if we carry it</span>
<span class="source-line-no">2721</span><span id="line-2721">   * @param abort Whether we're running an abort.</span>
<span class="source-line-no">2722</span><span id="line-2722">   */</span>
<span class="source-line-no">2723</span><span id="line-2723">  private void closeMetaTableRegions(final boolean abort) {</span>
<span class="source-line-no">2724</span><span id="line-2724">    HRegion meta = null;</span>
<span class="source-line-no">2725</span><span id="line-2725">    this.onlineRegionsLock.writeLock().lock();</span>
<span class="source-line-no">2726</span><span id="line-2726">    try {</span>
<span class="source-line-no">2727</span><span id="line-2727">      for (Map.Entry&lt;String, HRegion&gt; e : onlineRegions.entrySet()) {</span>
<span class="source-line-no">2728</span><span id="line-2728">        RegionInfo hri = e.getValue().getRegionInfo();</span>
<span class="source-line-no">2729</span><span id="line-2729">        if (hri.isMetaRegion()) {</span>
<span class="source-line-no">2730</span><span id="line-2730">          meta = e.getValue();</span>
<span class="source-line-no">2731</span><span id="line-2731">        }</span>
<span class="source-line-no">2732</span><span id="line-2732">        if (meta != null) {</span>
<span class="source-line-no">2733</span><span id="line-2733">          break;</span>
<span class="source-line-no">2734</span><span id="line-2734">        }</span>
<span class="source-line-no">2735</span><span id="line-2735">      }</span>
<span class="source-line-no">2736</span><span id="line-2736">    } finally {</span>
<span class="source-line-no">2737</span><span id="line-2737">      this.onlineRegionsLock.writeLock().unlock();</span>
<span class="source-line-no">2738</span><span id="line-2738">    }</span>
<span class="source-line-no">2739</span><span id="line-2739">    if (meta != null) {</span>
<span class="source-line-no">2740</span><span id="line-2740">      closeRegionIgnoreErrors(meta.getRegionInfo(), abort);</span>
<span class="source-line-no">2741</span><span id="line-2741">    }</span>
<span class="source-line-no">2742</span><span id="line-2742">  }</span>
<span class="source-line-no">2743</span><span id="line-2743"></span>
<span class="source-line-no">2744</span><span id="line-2744">  /**</span>
<span class="source-line-no">2745</span><span id="line-2745">   * Schedule closes on all user regions. Should be safe calling multiple times because it wont'</span>
<span class="source-line-no">2746</span><span id="line-2746">   * close regions that are already closed or that are closing.</span>
<span class="source-line-no">2747</span><span id="line-2747">   * @param abort Whether we're running an abort.</span>
<span class="source-line-no">2748</span><span id="line-2748">   */</span>
<span class="source-line-no">2749</span><span id="line-2749">  private void closeUserRegions(final boolean abort) {</span>
<span class="source-line-no">2750</span><span id="line-2750">    this.onlineRegionsLock.writeLock().lock();</span>
<span class="source-line-no">2751</span><span id="line-2751">    try {</span>
<span class="source-line-no">2752</span><span id="line-2752">      for (Map.Entry&lt;String, HRegion&gt; e : this.onlineRegions.entrySet()) {</span>
<span class="source-line-no">2753</span><span id="line-2753">        HRegion r = e.getValue();</span>
<span class="source-line-no">2754</span><span id="line-2754">        if (!r.getRegionInfo().isMetaRegion() &amp;&amp; r.isAvailable()) {</span>
<span class="source-line-no">2755</span><span id="line-2755">          // Don't update zk with this close transition; pass false.</span>
<span class="source-line-no">2756</span><span id="line-2756">          closeRegionIgnoreErrors(r.getRegionInfo(), abort);</span>
<span class="source-line-no">2757</span><span id="line-2757">        }</span>
<span class="source-line-no">2758</span><span id="line-2758">      }</span>
<span class="source-line-no">2759</span><span id="line-2759">    } finally {</span>
<span class="source-line-no">2760</span><span id="line-2760">      this.onlineRegionsLock.writeLock().unlock();</span>
<span class="source-line-no">2761</span><span id="line-2761">    }</span>
<span class="source-line-no">2762</span><span id="line-2762">  }</span>
<span class="source-line-no">2763</span><span id="line-2763"></span>
<span class="source-line-no">2764</span><span id="line-2764">  protected Map&lt;String, HRegion&gt; getOnlineRegions() {</span>
<span class="source-line-no">2765</span><span id="line-2765">    return this.onlineRegions;</span>
<span class="source-line-no">2766</span><span id="line-2766">  }</span>
<span class="source-line-no">2767</span><span id="line-2767"></span>
<span class="source-line-no">2768</span><span id="line-2768">  public int getNumberOfOnlineRegions() {</span>
<span class="source-line-no">2769</span><span id="line-2769">    return this.onlineRegions.size();</span>
<span class="source-line-no">2770</span><span id="line-2770">  }</span>
<span class="source-line-no">2771</span><span id="line-2771"></span>
<span class="source-line-no">2772</span><span id="line-2772">  /**</span>
<span class="source-line-no">2773</span><span id="line-2773">   * For tests, web ui and metrics. This method will only work if HRegionServer is in the same JVM</span>
<span class="source-line-no">2774</span><span id="line-2774">   * as client; HRegion cannot be serialized to cross an rpc.</span>
<span class="source-line-no">2775</span><span id="line-2775">   */</span>
<span class="source-line-no">2776</span><span id="line-2776">  public Collection&lt;HRegion&gt; getOnlineRegionsLocalContext() {</span>
<span class="source-line-no">2777</span><span id="line-2777">    Collection&lt;HRegion&gt; regions = this.onlineRegions.values();</span>
<span class="source-line-no">2778</span><span id="line-2778">    return Collections.unmodifiableCollection(regions);</span>
<span class="source-line-no">2779</span><span id="line-2779">  }</span>
<span class="source-line-no">2780</span><span id="line-2780"></span>
<span class="source-line-no">2781</span><span id="line-2781">  @Override</span>
<span class="source-line-no">2782</span><span id="line-2782">  public void addRegion(HRegion region) {</span>
<span class="source-line-no">2783</span><span id="line-2783">    this.onlineRegions.put(region.getRegionInfo().getEncodedName(), region);</span>
<span class="source-line-no">2784</span><span id="line-2784">    configurationManager.registerObserver(region);</span>
<span class="source-line-no">2785</span><span id="line-2785">  }</span>
<span class="source-line-no">2786</span><span id="line-2786"></span>
<span class="source-line-no">2787</span><span id="line-2787">  private void addRegion(SortedMap&lt;Long, Collection&lt;HRegion&gt;&gt; sortedRegions, HRegion region,</span>
<span class="source-line-no">2788</span><span id="line-2788">    long size) {</span>
<span class="source-line-no">2789</span><span id="line-2789">    if (!sortedRegions.containsKey(size)) {</span>
<span class="source-line-no">2790</span><span id="line-2790">      sortedRegions.put(size, new ArrayList&lt;&gt;());</span>
<span class="source-line-no">2791</span><span id="line-2791">    }</span>
<span class="source-line-no">2792</span><span id="line-2792">    sortedRegions.get(size).add(region);</span>
<span class="source-line-no">2793</span><span id="line-2793">  }</span>
<span class="source-line-no">2794</span><span id="line-2794"></span>
<span class="source-line-no">2795</span><span id="line-2795">  /**</span>
<span class="source-line-no">2796</span><span id="line-2796">   * @return A new Map of online regions sorted by region off-heap size with the first entry being</span>
<span class="source-line-no">2797</span><span id="line-2797">   *         the biggest.</span>
<span class="source-line-no">2798</span><span id="line-2798">   */</span>
<span class="source-line-no">2799</span><span id="line-2799">  SortedMap&lt;Long, Collection&lt;HRegion&gt;&gt; getCopyOfOnlineRegionsSortedByOffHeapSize() {</span>
<span class="source-line-no">2800</span><span id="line-2800">    // we'll sort the regions in reverse</span>
<span class="source-line-no">2801</span><span id="line-2801">    SortedMap&lt;Long, Collection&lt;HRegion&gt;&gt; sortedRegions = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span>
<span class="source-line-no">2802</span><span id="line-2802">    // Copy over all regions. Regions are sorted by size with biggest first.</span>
<span class="source-line-no">2803</span><span id="line-2803">    for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">2804</span><span id="line-2804">      addRegion(sortedRegions, region, region.getMemStoreOffHeapSize());</span>
<span class="source-line-no">2805</span><span id="line-2805">    }</span>
<span class="source-line-no">2806</span><span id="line-2806">    return sortedRegions;</span>
<span class="source-line-no">2807</span><span id="line-2807">  }</span>
<span class="source-line-no">2808</span><span id="line-2808"></span>
<span class="source-line-no">2809</span><span id="line-2809">  /**</span>
<span class="source-line-no">2810</span><span id="line-2810">   * @return A new Map of online regions sorted by region heap size with the first entry being the</span>
<span class="source-line-no">2811</span><span id="line-2811">   *         biggest.</span>
<span class="source-line-no">2812</span><span id="line-2812">   */</span>
<span class="source-line-no">2813</span><span id="line-2813">  SortedMap&lt;Long, Collection&lt;HRegion&gt;&gt; getCopyOfOnlineRegionsSortedByOnHeapSize() {</span>
<span class="source-line-no">2814</span><span id="line-2814">    // we'll sort the regions in reverse</span>
<span class="source-line-no">2815</span><span id="line-2815">    SortedMap&lt;Long, Collection&lt;HRegion&gt;&gt; sortedRegions = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span>
<span class="source-line-no">2816</span><span id="line-2816">    // Copy over all regions. Regions are sorted by size with biggest first.</span>
<span class="source-line-no">2817</span><span id="line-2817">    for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">2818</span><span id="line-2818">      addRegion(sortedRegions, region, region.getMemStoreHeapSize());</span>
<span class="source-line-no">2819</span><span id="line-2819">    }</span>
<span class="source-line-no">2820</span><span id="line-2820">    return sortedRegions;</span>
<span class="source-line-no">2821</span><span id="line-2821">  }</span>
<span class="source-line-no">2822</span><span id="line-2822"></span>
<span class="source-line-no">2823</span><span id="line-2823">  /** Returns reference to FlushRequester */</span>
<span class="source-line-no">2824</span><span id="line-2824">  @Override</span>
<span class="source-line-no">2825</span><span id="line-2825">  public FlushRequester getFlushRequester() {</span>
<span class="source-line-no">2826</span><span id="line-2826">    return this.cacheFlusher;</span>
<span class="source-line-no">2827</span><span id="line-2827">  }</span>
<span class="source-line-no">2828</span><span id="line-2828"></span>
<span class="source-line-no">2829</span><span id="line-2829">  @Override</span>
<span class="source-line-no">2830</span><span id="line-2830">  public CompactionRequester getCompactionRequestor() {</span>
<span class="source-line-no">2831</span><span id="line-2831">    return this.compactSplitThread;</span>
<span class="source-line-no">2832</span><span id="line-2832">  }</span>
<span class="source-line-no">2833</span><span id="line-2833"></span>
<span class="source-line-no">2834</span><span id="line-2834">  @Override</span>
<span class="source-line-no">2835</span><span id="line-2835">  public LeaseManager getLeaseManager() {</span>
<span class="source-line-no">2836</span><span id="line-2836">    return leaseManager;</span>
<span class="source-line-no">2837</span><span id="line-2837">  }</span>
<span class="source-line-no">2838</span><span id="line-2838"></span>
<span class="source-line-no">2839</span><span id="line-2839">  /** Returns {@code true} when the data file system is available, {@code false} otherwise. */</span>
<span class="source-line-no">2840</span><span id="line-2840">  boolean isDataFileSystemOk() {</span>
<span class="source-line-no">2841</span><span id="line-2841">    return this.dataFsOk;</span>
<span class="source-line-no">2842</span><span id="line-2842">  }</span>
<span class="source-line-no">2843</span><span id="line-2843"></span>
<span class="source-line-no">2844</span><span id="line-2844">  public RegionServerCoprocessorHost getRegionServerCoprocessorHost() {</span>
<span class="source-line-no">2845</span><span id="line-2845">    return this.rsHost;</span>
<span class="source-line-no">2846</span><span id="line-2846">  }</span>
<span class="source-line-no">2847</span><span id="line-2847"></span>
<span class="source-line-no">2848</span><span id="line-2848">  @Override</span>
<span class="source-line-no">2849</span><span id="line-2849">  public ConcurrentMap&lt;byte[], Boolean&gt; getRegionsInTransitionInRS() {</span>
<span class="source-line-no">2850</span><span id="line-2850">    return this.regionsInTransitionInRS;</span>
<span class="source-line-no">2851</span><span id="line-2851">  }</span>
<span class="source-line-no">2852</span><span id="line-2852"></span>
<span class="source-line-no">2853</span><span id="line-2853">  @Override</span>
<span class="source-line-no">2854</span><span id="line-2854">  public RegionServerRpcQuotaManager getRegionServerRpcQuotaManager() {</span>
<span class="source-line-no">2855</span><span id="line-2855">    return rsQuotaManager;</span>
<span class="source-line-no">2856</span><span id="line-2856">  }</span>
<span class="source-line-no">2857</span><span id="line-2857"></span>
<span class="source-line-no">2858</span><span id="line-2858">  //</span>
<span class="source-line-no">2859</span><span id="line-2859">  // Main program and support routines</span>
<span class="source-line-no">2860</span><span id="line-2860">  //</span>
<span class="source-line-no">2861</span><span id="line-2861">  /**</span>
<span class="source-line-no">2862</span><span id="line-2862">   * Load the replication executorService objects, if any</span>
<span class="source-line-no">2863</span><span id="line-2863">   */</span>
<span class="source-line-no">2864</span><span id="line-2864">  private static void createNewReplicationInstance(Configuration conf, HRegionServer server,</span>
<span class="source-line-no">2865</span><span id="line-2865">    FileSystem walFs, Path walDir, Path oldWALDir, WALFactory walFactory) throws IOException {</span>
<span class="source-line-no">2866</span><span id="line-2866">    // read in the name of the source replication class from the config file.</span>
<span class="source-line-no">2867</span><span id="line-2867">    String sourceClassname = conf.get(HConstants.REPLICATION_SOURCE_SERVICE_CLASSNAME,</span>
<span class="source-line-no">2868</span><span id="line-2868">      HConstants.REPLICATION_SERVICE_CLASSNAME_DEFAULT);</span>
<span class="source-line-no">2869</span><span id="line-2869"></span>
<span class="source-line-no">2870</span><span id="line-2870">    // read in the name of the sink replication class from the config file.</span>
<span class="source-line-no">2871</span><span id="line-2871">    String sinkClassname = conf.get(HConstants.REPLICATION_SINK_SERVICE_CLASSNAME,</span>
<span class="source-line-no">2872</span><span id="line-2872">      HConstants.REPLICATION_SINK_SERVICE_CLASSNAME_DEFAULT);</span>
<span class="source-line-no">2873</span><span id="line-2873"></span>
<span class="source-line-no">2874</span><span id="line-2874">    // If both the sink and the source class names are the same, then instantiate</span>
<span class="source-line-no">2875</span><span id="line-2875">    // only one object.</span>
<span class="source-line-no">2876</span><span id="line-2876">    if (sourceClassname.equals(sinkClassname)) {</span>
<span class="source-line-no">2877</span><span id="line-2877">      server.replicationSourceHandler = newReplicationInstance(sourceClassname,</span>
<span class="source-line-no">2878</span><span id="line-2878">        ReplicationSourceService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">2879</span><span id="line-2879">      server.replicationSinkHandler = (ReplicationSinkService) server.replicationSourceHandler;</span>
<span class="source-line-no">2880</span><span id="line-2880">      server.sameReplicationSourceAndSink = true;</span>
<span class="source-line-no">2881</span><span id="line-2881">    } else {</span>
<span class="source-line-no">2882</span><span id="line-2882">      server.replicationSourceHandler = newReplicationInstance(sourceClassname,</span>
<span class="source-line-no">2883</span><span id="line-2883">        ReplicationSourceService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">2884</span><span id="line-2884">      server.replicationSinkHandler = newReplicationInstance(sinkClassname,</span>
<span class="source-line-no">2885</span><span id="line-2885">        ReplicationSinkService.class, conf, server, walFs, walDir, oldWALDir, walFactory);</span>
<span class="source-line-no">2886</span><span id="line-2886">      server.sameReplicationSourceAndSink = false;</span>
<span class="source-line-no">2887</span><span id="line-2887">    }</span>
<span class="source-line-no">2888</span><span id="line-2888">  }</span>
<span class="source-line-no">2889</span><span id="line-2889"></span>
<span class="source-line-no">2890</span><span id="line-2890">  private static &lt;T extends ReplicationService&gt; T newReplicationInstance(String classname,</span>
<span class="source-line-no">2891</span><span id="line-2891">    Class&lt;T&gt; xface, Configuration conf, HRegionServer server, FileSystem walFs, Path logDir,</span>
<span class="source-line-no">2892</span><span id="line-2892">    Path oldLogDir, WALFactory walFactory) throws IOException {</span>
<span class="source-line-no">2893</span><span id="line-2893">    final Class&lt;? extends T&gt; clazz;</span>
<span class="source-line-no">2894</span><span id="line-2894">    try {</span>
<span class="source-line-no">2895</span><span id="line-2895">      ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="source-line-no">2896</span><span id="line-2896">      clazz = Class.forName(classname, true, classLoader).asSubclass(xface);</span>
<span class="source-line-no">2897</span><span id="line-2897">    } catch (java.lang.ClassNotFoundException nfe) {</span>
<span class="source-line-no">2898</span><span id="line-2898">      throw new IOException("Could not find class for " + classname);</span>
<span class="source-line-no">2899</span><span id="line-2899">    }</span>
<span class="source-line-no">2900</span><span id="line-2900">    T service = ReflectionUtils.newInstance(clazz, conf);</span>
<span class="source-line-no">2901</span><span id="line-2901">    service.initialize(server, walFs, logDir, oldLogDir, walFactory);</span>
<span class="source-line-no">2902</span><span id="line-2902">    return service;</span>
<span class="source-line-no">2903</span><span id="line-2903">  }</span>
<span class="source-line-no">2904</span><span id="line-2904"></span>
<span class="source-line-no">2905</span><span id="line-2905">  public Map&lt;String, ReplicationStatus&gt; getWalGroupsReplicationStatus() {</span>
<span class="source-line-no">2906</span><span id="line-2906">    Map&lt;String, ReplicationStatus&gt; walGroupsReplicationStatus = new TreeMap&lt;&gt;();</span>
<span class="source-line-no">2907</span><span id="line-2907">    if (!this.isOnline()) {</span>
<span class="source-line-no">2908</span><span id="line-2908">      return walGroupsReplicationStatus;</span>
<span class="source-line-no">2909</span><span id="line-2909">    }</span>
<span class="source-line-no">2910</span><span id="line-2910">    List&lt;ReplicationSourceInterface&gt; allSources = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">2911</span><span id="line-2911">    allSources.addAll(replicationSourceHandler.getReplicationManager().getSources());</span>
<span class="source-line-no">2912</span><span id="line-2912">    allSources.addAll(replicationSourceHandler.getReplicationManager().getOldSources());</span>
<span class="source-line-no">2913</span><span id="line-2913">    for (ReplicationSourceInterface source : allSources) {</span>
<span class="source-line-no">2914</span><span id="line-2914">      walGroupsReplicationStatus.putAll(source.getWalGroupStatus());</span>
<span class="source-line-no">2915</span><span id="line-2915">    }</span>
<span class="source-line-no">2916</span><span id="line-2916">    return walGroupsReplicationStatus;</span>
<span class="source-line-no">2917</span><span id="line-2917">  }</span>
<span class="source-line-no">2918</span><span id="line-2918"></span>
<span class="source-line-no">2919</span><span id="line-2919">  /**</span>
<span class="source-line-no">2920</span><span id="line-2920">   * Utility for constructing an instance of the passed HRegionServer class.</span>
<span class="source-line-no">2921</span><span id="line-2921">   */</span>
<span class="source-line-no">2922</span><span id="line-2922">  static HRegionServer constructRegionServer(final Class&lt;? extends HRegionServer&gt; regionServerClass,</span>
<span class="source-line-no">2923</span><span id="line-2923">    final Configuration conf) {</span>
<span class="source-line-no">2924</span><span id="line-2924">    try {</span>
<span class="source-line-no">2925</span><span id="line-2925">      Constructor&lt;? extends HRegionServer&gt; c =</span>
<span class="source-line-no">2926</span><span id="line-2926">        regionServerClass.getConstructor(Configuration.class);</span>
<span class="source-line-no">2927</span><span id="line-2927">      return c.newInstance(conf);</span>
<span class="source-line-no">2928</span><span id="line-2928">    } catch (Exception e) {</span>
<span class="source-line-no">2929</span><span id="line-2929">      throw new RuntimeException(</span>
<span class="source-line-no">2930</span><span id="line-2930">        "Failed construction of " + "Regionserver: " + regionServerClass.toString(), e);</span>
<span class="source-line-no">2931</span><span id="line-2931">    }</span>
<span class="source-line-no">2932</span><span id="line-2932">  }</span>
<span class="source-line-no">2933</span><span id="line-2933"></span>
<span class="source-line-no">2934</span><span id="line-2934">  /**</span>
<span class="source-line-no">2935</span><span id="line-2935">   * @see org.apache.hadoop.hbase.regionserver.HRegionServerCommandLine</span>
<span class="source-line-no">2936</span><span id="line-2936">   */</span>
<span class="source-line-no">2937</span><span id="line-2937">  public static void main(String[] args) {</span>
<span class="source-line-no">2938</span><span id="line-2938">    LOG.info("STARTING executorService " + HRegionServer.class.getSimpleName());</span>
<span class="source-line-no">2939</span><span id="line-2939">    VersionInfo.logVersion();</span>
<span class="source-line-no">2940</span><span id="line-2940">    Configuration conf = HBaseConfiguration.create();</span>
<span class="source-line-no">2941</span><span id="line-2941">    @SuppressWarnings("unchecked")</span>
<span class="source-line-no">2942</span><span id="line-2942">    Class&lt;? extends HRegionServer&gt; regionServerClass = (Class&lt;? extends HRegionServer&gt;) conf</span>
<span class="source-line-no">2943</span><span id="line-2943">      .getClass(HConstants.REGION_SERVER_IMPL, HRegionServer.class);</span>
<span class="source-line-no">2944</span><span id="line-2944"></span>
<span class="source-line-no">2945</span><span id="line-2945">    new HRegionServerCommandLine(regionServerClass).doMain(args);</span>
<span class="source-line-no">2946</span><span id="line-2946">  }</span>
<span class="source-line-no">2947</span><span id="line-2947"></span>
<span class="source-line-no">2948</span><span id="line-2948">  /**</span>
<span class="source-line-no">2949</span><span id="line-2949">   * Gets the online regions of the specified table. This method looks at the in-memory</span>
<span class="source-line-no">2950</span><span id="line-2950">   * onlineRegions. It does not go to &lt;code&gt;hbase:meta&lt;/code&gt;. Only returns &lt;em&gt;online&lt;/em&gt; regions.</span>
<span class="source-line-no">2951</span><span id="line-2951">   * If a region on this table has been closed during a disable, etc., it will not be included in</span>
<span class="source-line-no">2952</span><span id="line-2952">   * the returned list. So, the returned list may not necessarily be ALL regions in this table, its</span>
<span class="source-line-no">2953</span><span id="line-2953">   * all the ONLINE regions in the table.</span>
<span class="source-line-no">2954</span><span id="line-2954">   * @param tableName table to limit the scope of the query</span>
<span class="source-line-no">2955</span><span id="line-2955">   * @return Online regions from &lt;code&gt;tableName&lt;/code&gt;</span>
<span class="source-line-no">2956</span><span id="line-2956">   */</span>
<span class="source-line-no">2957</span><span id="line-2957">  @Override</span>
<span class="source-line-no">2958</span><span id="line-2958">  public List&lt;HRegion&gt; getRegions(TableName tableName) {</span>
<span class="source-line-no">2959</span><span id="line-2959">    List&lt;HRegion&gt; tableRegions = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">2960</span><span id="line-2960">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">2961</span><span id="line-2961">      for (HRegion region : this.onlineRegions.values()) {</span>
<span class="source-line-no">2962</span><span id="line-2962">        RegionInfo regionInfo = region.getRegionInfo();</span>
<span class="source-line-no">2963</span><span id="line-2963">        if (regionInfo.getTable().equals(tableName)) {</span>
<span class="source-line-no">2964</span><span id="line-2964">          tableRegions.add(region);</span>
<span class="source-line-no">2965</span><span id="line-2965">        }</span>
<span class="source-line-no">2966</span><span id="line-2966">      }</span>
<span class="source-line-no">2967</span><span id="line-2967">    }</span>
<span class="source-line-no">2968</span><span id="line-2968">    return tableRegions;</span>
<span class="source-line-no">2969</span><span id="line-2969">  }</span>
<span class="source-line-no">2970</span><span id="line-2970"></span>
<span class="source-line-no">2971</span><span id="line-2971">  @Override</span>
<span class="source-line-no">2972</span><span id="line-2972">  public List&lt;HRegion&gt; getRegions() {</span>
<span class="source-line-no">2973</span><span id="line-2973">    List&lt;HRegion&gt; allRegions;</span>
<span class="source-line-no">2974</span><span id="line-2974">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">2975</span><span id="line-2975">      // Return a clone copy of the onlineRegions</span>
<span class="source-line-no">2976</span><span id="line-2976">      allRegions = new ArrayList&lt;&gt;(onlineRegions.values());</span>
<span class="source-line-no">2977</span><span id="line-2977">    }</span>
<span class="source-line-no">2978</span><span id="line-2978">    return allRegions;</span>
<span class="source-line-no">2979</span><span id="line-2979">  }</span>
<span class="source-line-no">2980</span><span id="line-2980"></span>
<span class="source-line-no">2981</span><span id="line-2981">  /**</span>
<span class="source-line-no">2982</span><span id="line-2982">   * Gets the online tables in this RS. This method looks at the in-memory onlineRegions.</span>
<span class="source-line-no">2983</span><span id="line-2983">   * @return all the online tables in this RS</span>
<span class="source-line-no">2984</span><span id="line-2984">   */</span>
<span class="source-line-no">2985</span><span id="line-2985">  public Set&lt;TableName&gt; getOnlineTables() {</span>
<span class="source-line-no">2986</span><span id="line-2986">    Set&lt;TableName&gt; tables = new HashSet&lt;&gt;();</span>
<span class="source-line-no">2987</span><span id="line-2987">    synchronized (this.onlineRegions) {</span>
<span class="source-line-no">2988</span><span id="line-2988">      for (Region region : this.onlineRegions.values()) {</span>
<span class="source-line-no">2989</span><span id="line-2989">        tables.add(region.getTableDescriptor().getTableName());</span>
<span class="source-line-no">2990</span><span id="line-2990">      }</span>
<span class="source-line-no">2991</span><span id="line-2991">    }</span>
<span class="source-line-no">2992</span><span id="line-2992">    return tables;</span>
<span class="source-line-no">2993</span><span id="line-2993">  }</span>
<span class="source-line-no">2994</span><span id="line-2994"></span>
<span class="source-line-no">2995</span><span id="line-2995">  public String[] getRegionServerCoprocessors() {</span>
<span class="source-line-no">2996</span><span id="line-2996">    TreeSet&lt;String&gt; coprocessors = new TreeSet&lt;&gt;();</span>
<span class="source-line-no">2997</span><span id="line-2997">    try {</span>
<span class="source-line-no">2998</span><span id="line-2998">      coprocessors.addAll(getWAL(null).getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">2999</span><span id="line-2999">    } catch (IOException exception) {</span>
<span class="source-line-no">3000</span><span id="line-3000">      LOG.warn("Exception attempting to fetch wal coprocessor information for the common wal; "</span>
<span class="source-line-no">3001</span><span id="line-3001">        + "skipping.");</span>
<span class="source-line-no">3002</span><span id="line-3002">      LOG.debug("Exception details for failure to fetch wal coprocessor information.", exception);</span>
<span class="source-line-no">3003</span><span id="line-3003">    }</span>
<span class="source-line-no">3004</span><span id="line-3004">    Collection&lt;HRegion&gt; regions = getOnlineRegionsLocalContext();</span>
<span class="source-line-no">3005</span><span id="line-3005">    for (HRegion region : regions) {</span>
<span class="source-line-no">3006</span><span id="line-3006">      coprocessors.addAll(region.getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">3007</span><span id="line-3007">      try {</span>
<span class="source-line-no">3008</span><span id="line-3008">        coprocessors.addAll(getWAL(region.getRegionInfo()).getCoprocessorHost().getCoprocessors());</span>
<span class="source-line-no">3009</span><span id="line-3009">      } catch (IOException exception) {</span>
<span class="source-line-no">3010</span><span id="line-3010">        LOG.warn("Exception attempting to fetch wal coprocessor information for region " + region</span>
<span class="source-line-no">3011</span><span id="line-3011">          + "; skipping.");</span>
<span class="source-line-no">3012</span><span id="line-3012">        LOG.debug("Exception details for failure to fetch wal coprocessor information.", exception);</span>
<span class="source-line-no">3013</span><span id="line-3013">      }</span>
<span class="source-line-no">3014</span><span id="line-3014">    }</span>
<span class="source-line-no">3015</span><span id="line-3015">    coprocessors.addAll(rsHost.getCoprocessors());</span>
<span class="source-line-no">3016</span><span id="line-3016">    return coprocessors.toArray(new String[0]);</span>
<span class="source-line-no">3017</span><span id="line-3017">  }</span>
<span class="source-line-no">3018</span><span id="line-3018"></span>
<span class="source-line-no">3019</span><span id="line-3019">  /**</span>
<span class="source-line-no">3020</span><span id="line-3020">   * Try to close the region, logs a warning on failure but continues.</span>
<span class="source-line-no">3021</span><span id="line-3021">   * @param region Region to close</span>
<span class="source-line-no">3022</span><span id="line-3022">   */</span>
<span class="source-line-no">3023</span><span id="line-3023">  private void closeRegionIgnoreErrors(RegionInfo region, final boolean abort) {</span>
<span class="source-line-no">3024</span><span id="line-3024">    try {</span>
<span class="source-line-no">3025</span><span id="line-3025">      if (!closeRegion(region.getEncodedName(), abort, null)) {</span>
<span class="source-line-no">3026</span><span id="line-3026">        LOG</span>
<span class="source-line-no">3027</span><span id="line-3027">          .warn("Failed to close " + region.getRegionNameAsString() + " - ignoring and continuing");</span>
<span class="source-line-no">3028</span><span id="line-3028">      }</span>
<span class="source-line-no">3029</span><span id="line-3029">    } catch (IOException e) {</span>
<span class="source-line-no">3030</span><span id="line-3030">      LOG.warn("Failed to close " + region.getRegionNameAsString() + " - ignoring and continuing",</span>
<span class="source-line-no">3031</span><span id="line-3031">        e);</span>
<span class="source-line-no">3032</span><span id="line-3032">    }</span>
<span class="source-line-no">3033</span><span id="line-3033">  }</span>
<span class="source-line-no">3034</span><span id="line-3034"></span>
<span class="source-line-no">3035</span><span id="line-3035">  /**</span>
<span class="source-line-no">3036</span><span id="line-3036">   * Close asynchronously a region, can be called from the master or internally by the regionserver</span>
<span class="source-line-no">3037</span><span id="line-3037">   * when stopping. If called from the master, the region will update the status.</span>
<span class="source-line-no">3038</span><span id="line-3038">   * &lt;p&gt;</span>
<span class="source-line-no">3039</span><span id="line-3039">   * If an opening was in progress, this method will cancel it, but will not start a new close. The</span>
<span class="source-line-no">3040</span><span id="line-3040">   * coprocessors are not called in this case. A NotServingRegionException exception is thrown.</span>
<span class="source-line-no">3041</span><span id="line-3041">   * &lt;/p&gt;</span>
<span class="source-line-no">3042</span><span id="line-3042">   * &lt;p&gt;</span>
<span class="source-line-no">3043</span><span id="line-3043">   * If a close was in progress, this new request will be ignored, and an exception thrown.</span>
<span class="source-line-no">3044</span><span id="line-3044">   * &lt;/p&gt;</span>
<span class="source-line-no">3045</span><span id="line-3045">   * &lt;p&gt;</span>
<span class="source-line-no">3046</span><span id="line-3046">   * Provides additional flag to indicate if this region blocks should be evicted from the cache.</span>
<span class="source-line-no">3047</span><span id="line-3047">   * &lt;/p&gt;</span>
<span class="source-line-no">3048</span><span id="line-3048">   * @param encodedName Region to close</span>
<span class="source-line-no">3049</span><span id="line-3049">   * @param abort       True if we are aborting</span>
<span class="source-line-no">3050</span><span id="line-3050">   * @param destination Where the Region is being moved too... maybe null if unknown.</span>
<span class="source-line-no">3051</span><span id="line-3051">   * @return True if closed a region.</span>
<span class="source-line-no">3052</span><span id="line-3052">   * @throws NotServingRegionException if the region is not online</span>
<span class="source-line-no">3053</span><span id="line-3053">   */</span>
<span class="source-line-no">3054</span><span id="line-3054">  protected boolean closeRegion(String encodedName, final boolean abort,</span>
<span class="source-line-no">3055</span><span id="line-3055">    final ServerName destination) throws NotServingRegionException {</span>
<span class="source-line-no">3056</span><span id="line-3056">    // Check for permissions to close.</span>
<span class="source-line-no">3057</span><span id="line-3057">    HRegion actualRegion = this.getRegion(encodedName);</span>
<span class="source-line-no">3058</span><span id="line-3058">    // Can be null if we're calling close on a region that's not online</span>
<span class="source-line-no">3059</span><span id="line-3059">    if ((actualRegion != null) &amp;&amp; (actualRegion.getCoprocessorHost() != null)) {</span>
<span class="source-line-no">3060</span><span id="line-3060">      try {</span>
<span class="source-line-no">3061</span><span id="line-3061">        actualRegion.getCoprocessorHost().preClose(false);</span>
<span class="source-line-no">3062</span><span id="line-3062">      } catch (IOException exp) {</span>
<span class="source-line-no">3063</span><span id="line-3063">        LOG.warn("Unable to close region: the coprocessor launched an error ", exp);</span>
<span class="source-line-no">3064</span><span id="line-3064">        return false;</span>
<span class="source-line-no">3065</span><span id="line-3065">      }</span>
<span class="source-line-no">3066</span><span id="line-3066">    }</span>
<span class="source-line-no">3067</span><span id="line-3067"></span>
<span class="source-line-no">3068</span><span id="line-3068">    // previous can come back 'null' if not in map.</span>
<span class="source-line-no">3069</span><span id="line-3069">    final Boolean previous =</span>
<span class="source-line-no">3070</span><span id="line-3070">      this.regionsInTransitionInRS.putIfAbsent(Bytes.toBytes(encodedName), Boolean.FALSE);</span>
<span class="source-line-no">3071</span><span id="line-3071"></span>
<span class="source-line-no">3072</span><span id="line-3072">    if (Boolean.TRUE.equals(previous)) {</span>
<span class="source-line-no">3073</span><span id="line-3073">      LOG.info("Received CLOSE for the region:" + encodedName + " , which we are already "</span>
<span class="source-line-no">3074</span><span id="line-3074">        + "trying to OPEN. Cancelling OPENING.");</span>
<span class="source-line-no">3075</span><span id="line-3075">      if (!regionsInTransitionInRS.replace(Bytes.toBytes(encodedName), previous, Boolean.FALSE)) {</span>
<span class="source-line-no">3076</span><span id="line-3076">        // The replace failed. That should be an exceptional case, but theoretically it can happen.</span>
<span class="source-line-no">3077</span><span id="line-3077">        // We're going to try to do a standard close then.</span>
<span class="source-line-no">3078</span><span id="line-3078">        LOG.warn("The opening for region " + encodedName + " was done before we could cancel it."</span>
<span class="source-line-no">3079</span><span id="line-3079">          + " Doing a standard close now");</span>
<span class="source-line-no">3080</span><span id="line-3080">        return closeRegion(encodedName, abort, destination);</span>
<span class="source-line-no">3081</span><span id="line-3081">      }</span>
<span class="source-line-no">3082</span><span id="line-3082">      // Let's get the region from the online region list again</span>
<span class="source-line-no">3083</span><span id="line-3083">      actualRegion = this.getRegion(encodedName);</span>
<span class="source-line-no">3084</span><span id="line-3084">      if (actualRegion == null) { // If already online, we still need to close it.</span>
<span class="source-line-no">3085</span><span id="line-3085">        LOG.info("The opening previously in progress has been cancelled by a CLOSE request.");</span>
<span class="source-line-no">3086</span><span id="line-3086">        // The master deletes the znode when it receives this exception.</span>
<span class="source-line-no">3087</span><span id="line-3087">        throw new NotServingRegionException(</span>
<span class="source-line-no">3088</span><span id="line-3088">          "The region " + encodedName + " was opening but not yet served. Opening is cancelled.");</span>
<span class="source-line-no">3089</span><span id="line-3089">      }</span>
<span class="source-line-no">3090</span><span id="line-3090">    } else if (previous == null) {</span>
<span class="source-line-no">3091</span><span id="line-3091">      LOG.info("Received CLOSE for {}", encodedName);</span>
<span class="source-line-no">3092</span><span id="line-3092">    } else if (Boolean.FALSE.equals(previous)) {</span>
<span class="source-line-no">3093</span><span id="line-3093">      LOG.info("Received CLOSE for the region: " + encodedName</span>
<span class="source-line-no">3094</span><span id="line-3094">        + ", which we are already trying to CLOSE, but not completed yet");</span>
<span class="source-line-no">3095</span><span id="line-3095">      return true;</span>
<span class="source-line-no">3096</span><span id="line-3096">    }</span>
<span class="source-line-no">3097</span><span id="line-3097"></span>
<span class="source-line-no">3098</span><span id="line-3098">    if (actualRegion == null) {</span>
<span class="source-line-no">3099</span><span id="line-3099">      LOG.debug("Received CLOSE for a region which is not online, and we're not opening.");</span>
<span class="source-line-no">3100</span><span id="line-3100">      this.regionsInTransitionInRS.remove(Bytes.toBytes(encodedName));</span>
<span class="source-line-no">3101</span><span id="line-3101">      // The master deletes the znode when it receives this exception.</span>
<span class="source-line-no">3102</span><span id="line-3102">      throw new NotServingRegionException(</span>
<span class="source-line-no">3103</span><span id="line-3103">        "The region " + encodedName + " is not online, and is not opening.");</span>
<span class="source-line-no">3104</span><span id="line-3104">    }</span>
<span class="source-line-no">3105</span><span id="line-3105"></span>
<span class="source-line-no">3106</span><span id="line-3106">    CloseRegionHandler crh;</span>
<span class="source-line-no">3107</span><span id="line-3107">    final RegionInfo hri = actualRegion.getRegionInfo();</span>
<span class="source-line-no">3108</span><span id="line-3108">    if (hri.isMetaRegion()) {</span>
<span class="source-line-no">3109</span><span id="line-3109">      crh = new CloseMetaHandler(this, this, hri, abort);</span>
<span class="source-line-no">3110</span><span id="line-3110">    } else {</span>
<span class="source-line-no">3111</span><span id="line-3111">      crh = new CloseRegionHandler(this, this, hri, abort, destination);</span>
<span class="source-line-no">3112</span><span id="line-3112">    }</span>
<span class="source-line-no">3113</span><span id="line-3113">    this.executorService.submit(crh);</span>
<span class="source-line-no">3114</span><span id="line-3114">    return true;</span>
<span class="source-line-no">3115</span><span id="line-3115">  }</span>
<span class="source-line-no">3116</span><span id="line-3116"></span>
<span class="source-line-no">3117</span><span id="line-3117">  /**</span>
<span class="source-line-no">3118</span><span id="line-3118">   * @return HRegion for the passed binary &lt;code&gt;regionName&lt;/code&gt; or null if named region is not</span>
<span class="source-line-no">3119</span><span id="line-3119">   *         member of the online regions.</span>
<span class="source-line-no">3120</span><span id="line-3120">   */</span>
<span class="source-line-no">3121</span><span id="line-3121">  public HRegion getOnlineRegion(final byte[] regionName) {</span>
<span class="source-line-no">3122</span><span id="line-3122">    String encodedRegionName = RegionInfo.encodeRegionName(regionName);</span>
<span class="source-line-no">3123</span><span id="line-3123">    return this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3124</span><span id="line-3124">  }</span>
<span class="source-line-no">3125</span><span id="line-3125"></span>
<span class="source-line-no">3126</span><span id="line-3126">  @Override</span>
<span class="source-line-no">3127</span><span id="line-3127">  public HRegion getRegion(final String encodedRegionName) {</span>
<span class="source-line-no">3128</span><span id="line-3128">    return this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3129</span><span id="line-3129">  }</span>
<span class="source-line-no">3130</span><span id="line-3130"></span>
<span class="source-line-no">3131</span><span id="line-3131">  @Override</span>
<span class="source-line-no">3132</span><span id="line-3132">  public boolean removeRegion(final HRegion r, ServerName destination) {</span>
<span class="source-line-no">3133</span><span id="line-3133">    HRegion toReturn = this.onlineRegions.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3134</span><span id="line-3134">    metricsRegionServerImpl.requestsCountCache.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3135</span><span id="line-3135">    if (destination != null) {</span>
<span class="source-line-no">3136</span><span id="line-3136">      long closeSeqNum = r.getMaxFlushedSeqId();</span>
<span class="source-line-no">3137</span><span id="line-3137">      if (closeSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">3138</span><span id="line-3138">        // No edits in WAL for this region; get the sequence number when the region was opened.</span>
<span class="source-line-no">3139</span><span id="line-3139">        closeSeqNum = r.getOpenSeqNum();</span>
<span class="source-line-no">3140</span><span id="line-3140">        if (closeSeqNum == HConstants.NO_SEQNUM) {</span>
<span class="source-line-no">3141</span><span id="line-3141">          closeSeqNum = 0;</span>
<span class="source-line-no">3142</span><span id="line-3142">        }</span>
<span class="source-line-no">3143</span><span id="line-3143">      }</span>
<span class="source-line-no">3144</span><span id="line-3144">      boolean selfMove = ServerName.isSameAddress(destination, this.getServerName());</span>
<span class="source-line-no">3145</span><span id="line-3145">      addToMovedRegions(r.getRegionInfo().getEncodedName(), destination, closeSeqNum, selfMove);</span>
<span class="source-line-no">3146</span><span id="line-3146">      if (selfMove) {</span>
<span class="source-line-no">3147</span><span id="line-3147">        this.regionServerAccounting.getRetainedRegionRWRequestsCnt().put(</span>
<span class="source-line-no">3148</span><span id="line-3148">          r.getRegionInfo().getEncodedName(),</span>
<span class="source-line-no">3149</span><span id="line-3149">          new Pair&lt;&gt;(r.getReadRequestsCount(), r.getWriteRequestsCount()));</span>
<span class="source-line-no">3150</span><span id="line-3150">      }</span>
<span class="source-line-no">3151</span><span id="line-3151">    }</span>
<span class="source-line-no">3152</span><span id="line-3152">    this.regionFavoredNodesMap.remove(r.getRegionInfo().getEncodedName());</span>
<span class="source-line-no">3153</span><span id="line-3153">    configurationManager.deregisterObserver(r);</span>
<span class="source-line-no">3154</span><span id="line-3154">    return toReturn != null;</span>
<span class="source-line-no">3155</span><span id="line-3155">  }</span>
<span class="source-line-no">3156</span><span id="line-3156"></span>
<span class="source-line-no">3157</span><span id="line-3157">  /**</span>
<span class="source-line-no">3158</span><span id="line-3158">   * Protected Utility method for safely obtaining an HRegion handle.</span>
<span class="source-line-no">3159</span><span id="line-3159">   * @param regionName Name of online {@link HRegion} to return</span>
<span class="source-line-no">3160</span><span id="line-3160">   * @return {@link HRegion} for &lt;code&gt;regionName&lt;/code&gt;</span>
<span class="source-line-no">3161</span><span id="line-3161">   */</span>
<span class="source-line-no">3162</span><span id="line-3162">  protected HRegion getRegion(final byte[] regionName) throws NotServingRegionException {</span>
<span class="source-line-no">3163</span><span id="line-3163">    String encodedRegionName = RegionInfo.encodeRegionName(regionName);</span>
<span class="source-line-no">3164</span><span id="line-3164">    return getRegionByEncodedName(regionName, encodedRegionName);</span>
<span class="source-line-no">3165</span><span id="line-3165">  }</span>
<span class="source-line-no">3166</span><span id="line-3166"></span>
<span class="source-line-no">3167</span><span id="line-3167">  public HRegion getRegionByEncodedName(String encodedRegionName) throws NotServingRegionException {</span>
<span class="source-line-no">3168</span><span id="line-3168">    return getRegionByEncodedName(null, encodedRegionName);</span>
<span class="source-line-no">3169</span><span id="line-3169">  }</span>
<span class="source-line-no">3170</span><span id="line-3170"></span>
<span class="source-line-no">3171</span><span id="line-3171">  private HRegion getRegionByEncodedName(byte[] regionName, String encodedRegionName)</span>
<span class="source-line-no">3172</span><span id="line-3172">    throws NotServingRegionException {</span>
<span class="source-line-no">3173</span><span id="line-3173">    HRegion region = this.onlineRegions.get(encodedRegionName);</span>
<span class="source-line-no">3174</span><span id="line-3174">    if (region == null) {</span>
<span class="source-line-no">3175</span><span id="line-3175">      MovedRegionInfo moveInfo = getMovedRegion(encodedRegionName);</span>
<span class="source-line-no">3176</span><span id="line-3176">      if (moveInfo != null) {</span>
<span class="source-line-no">3177</span><span id="line-3177">        throw new RegionMovedException(moveInfo.getServerName(), moveInfo.getSeqNum());</span>
<span class="source-line-no">3178</span><span id="line-3178">      }</span>
<span class="source-line-no">3179</span><span id="line-3179">      Boolean isOpening = this.regionsInTransitionInRS.get(Bytes.toBytes(encodedRegionName));</span>
<span class="source-line-no">3180</span><span id="line-3180">      String regionNameStr =</span>
<span class="source-line-no">3181</span><span id="line-3181">        regionName == null ? encodedRegionName : Bytes.toStringBinary(regionName);</span>
<span class="source-line-no">3182</span><span id="line-3182">      if (isOpening != null &amp;&amp; isOpening) {</span>
<span class="source-line-no">3183</span><span id="line-3183">        throw new RegionOpeningException(</span>
<span class="source-line-no">3184</span><span id="line-3184">          "Region " + regionNameStr + " is opening on " + this.serverName);</span>
<span class="source-line-no">3185</span><span id="line-3185">      }</span>
<span class="source-line-no">3186</span><span id="line-3186">      throw new NotServingRegionException(</span>
<span class="source-line-no">3187</span><span id="line-3187">        "" + regionNameStr + " is not online on " + this.serverName);</span>
<span class="source-line-no">3188</span><span id="line-3188">    }</span>
<span class="source-line-no">3189</span><span id="line-3189">    return region;</span>
<span class="source-line-no">3190</span><span id="line-3190">  }</span>
<span class="source-line-no">3191</span><span id="line-3191"></span>
<span class="source-line-no">3192</span><span id="line-3192">  /**</span>
<span class="source-line-no">3193</span><span id="line-3193">   * Cleanup after Throwable caught invoking method. Converts &lt;code&gt;t&lt;/code&gt; to IOE if it isn't</span>
<span class="source-line-no">3194</span><span id="line-3194">   * already.</span>
<span class="source-line-no">3195</span><span id="line-3195">   * @param t   Throwable</span>
<span class="source-line-no">3196</span><span id="line-3196">   * @param msg Message to log in error. Can be null.</span>
<span class="source-line-no">3197</span><span id="line-3197">   * @return Throwable converted to an IOE; methods can only let out IOEs.</span>
<span class="source-line-no">3198</span><span id="line-3198">   */</span>
<span class="source-line-no">3199</span><span id="line-3199">  private Throwable cleanup(final Throwable t, final String msg) {</span>
<span class="source-line-no">3200</span><span id="line-3200">    // Don't log as error if NSRE; NSRE is 'normal' operation.</span>
<span class="source-line-no">3201</span><span id="line-3201">    if (t instanceof NotServingRegionException) {</span>
<span class="source-line-no">3202</span><span id="line-3202">      LOG.debug("NotServingRegionException; " + t.getMessage());</span>
<span class="source-line-no">3203</span><span id="line-3203">      return t;</span>
<span class="source-line-no">3204</span><span id="line-3204">    }</span>
<span class="source-line-no">3205</span><span id="line-3205">    Throwable e = t instanceof RemoteException ? ((RemoteException) t).unwrapRemoteException() : t;</span>
<span class="source-line-no">3206</span><span id="line-3206">    if (msg == null) {</span>
<span class="source-line-no">3207</span><span id="line-3207">      LOG.error("", e);</span>
<span class="source-line-no">3208</span><span id="line-3208">    } else {</span>
<span class="source-line-no">3209</span><span id="line-3209">      LOG.error(msg, e);</span>
<span class="source-line-no">3210</span><span id="line-3210">    }</span>
<span class="source-line-no">3211</span><span id="line-3211">    if (!rpcServices.checkOOME(t)) {</span>
<span class="source-line-no">3212</span><span id="line-3212">      checkFileSystem();</span>
<span class="source-line-no">3213</span><span id="line-3213">    }</span>
<span class="source-line-no">3214</span><span id="line-3214">    return t;</span>
<span class="source-line-no">3215</span><span id="line-3215">  }</span>
<span class="source-line-no">3216</span><span id="line-3216"></span>
<span class="source-line-no">3217</span><span id="line-3217">  /**</span>
<span class="source-line-no">3218</span><span id="line-3218">   * @param msg Message to put in new IOE if passed &lt;code&gt;t&lt;/code&gt; is not an IOE</span>
<span class="source-line-no">3219</span><span id="line-3219">   * @return Make &lt;code&gt;t&lt;/code&gt; an IOE if it isn't already.</span>
<span class="source-line-no">3220</span><span id="line-3220">   */</span>
<span class="source-line-no">3221</span><span id="line-3221">  private IOException convertThrowableToIOE(final Throwable t, final String msg) {</span>
<span class="source-line-no">3222</span><span id="line-3222">    return (t instanceof IOException ? (IOException) t</span>
<span class="source-line-no">3223</span><span id="line-3223">      : msg == null || msg.length() == 0 ? new IOException(t)</span>
<span class="source-line-no">3224</span><span id="line-3224">      : new IOException(msg, t));</span>
<span class="source-line-no">3225</span><span id="line-3225">  }</span>
<span class="source-line-no">3226</span><span id="line-3226"></span>
<span class="source-line-no">3227</span><span id="line-3227">  /**</span>
<span class="source-line-no">3228</span><span id="line-3228">   * Checks to see if the file system is still accessible. If not, sets abortRequested and</span>
<span class="source-line-no">3229</span><span id="line-3229">   * stopRequested</span>
<span class="source-line-no">3230</span><span id="line-3230">   * @return false if file system is not available</span>
<span class="source-line-no">3231</span><span id="line-3231">   */</span>
<span class="source-line-no">3232</span><span id="line-3232">  boolean checkFileSystem() {</span>
<span class="source-line-no">3233</span><span id="line-3233">    if (this.dataFsOk &amp;&amp; this.dataFs != null) {</span>
<span class="source-line-no">3234</span><span id="line-3234">      try {</span>
<span class="source-line-no">3235</span><span id="line-3235">        FSUtils.checkFileSystemAvailable(this.dataFs);</span>
<span class="source-line-no">3236</span><span id="line-3236">      } catch (IOException e) {</span>
<span class="source-line-no">3237</span><span id="line-3237">        abort("File System not available", e);</span>
<span class="source-line-no">3238</span><span id="line-3238">        this.dataFsOk = false;</span>
<span class="source-line-no">3239</span><span id="line-3239">      }</span>
<span class="source-line-no">3240</span><span id="line-3240">    }</span>
<span class="source-line-no">3241</span><span id="line-3241">    return this.dataFsOk;</span>
<span class="source-line-no">3242</span><span id="line-3242">  }</span>
<span class="source-line-no">3243</span><span id="line-3243"></span>
<span class="source-line-no">3244</span><span id="line-3244">  @Override</span>
<span class="source-line-no">3245</span><span id="line-3245">  public void updateRegionFavoredNodesMapping(String encodedRegionName,</span>
<span class="source-line-no">3246</span><span id="line-3246">    List&lt;org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName&gt; favoredNodes) {</span>
<span class="source-line-no">3247</span><span id="line-3247">    Address[] addr = new Address[favoredNodes.size()];</span>
<span class="source-line-no">3248</span><span id="line-3248">    // Refer to the comment on the declaration of regionFavoredNodesMap on why</span>
<span class="source-line-no">3249</span><span id="line-3249">    // it is a map of region name to Address[]</span>
<span class="source-line-no">3250</span><span id="line-3250">    for (int i = 0; i &lt; favoredNodes.size(); i++) {</span>
<span class="source-line-no">3251</span><span id="line-3251">      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(), favoredNodes.get(i).getPort());</span>
<span class="source-line-no">3252</span><span id="line-3252">    }</span>
<span class="source-line-no">3253</span><span id="line-3253">    regionFavoredNodesMap.put(encodedRegionName, addr);</span>
<span class="source-line-no">3254</span><span id="line-3254">  }</span>
<span class="source-line-no">3255</span><span id="line-3255"></span>
<span class="source-line-no">3256</span><span id="line-3256">  /**</span>
<span class="source-line-no">3257</span><span id="line-3257">   * Return the favored nodes for a region given its encoded name. Look at the comment around</span>
<span class="source-line-no">3258</span><span id="line-3258">   * {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[] here.</span>
<span class="source-line-no">3259</span><span id="line-3259">   * @param encodedRegionName the encoded region name.</span>
<span class="source-line-no">3260</span><span id="line-3260">   * @return array of favored locations</span>
<span class="source-line-no">3261</span><span id="line-3261">   */</span>
<span class="source-line-no">3262</span><span id="line-3262">  @Override</span>
<span class="source-line-no">3263</span><span id="line-3263">  public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {</span>
<span class="source-line-no">3264</span><span id="line-3264">    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));</span>
<span class="source-line-no">3265</span><span id="line-3265">  }</span>
<span class="source-line-no">3266</span><span id="line-3266"></span>
<span class="source-line-no">3267</span><span id="line-3267">  @Override</span>
<span class="source-line-no">3268</span><span id="line-3268">  public ServerNonceManager getNonceManager() {</span>
<span class="source-line-no">3269</span><span id="line-3269">    return this.nonceManager;</span>
<span class="source-line-no">3270</span><span id="line-3270">  }</span>
<span class="source-line-no">3271</span><span id="line-3271"></span>
<span class="source-line-no">3272</span><span id="line-3272">  private static class MovedRegionInfo {</span>
<span class="source-line-no">3273</span><span id="line-3273">    private final ServerName serverName;</span>
<span class="source-line-no">3274</span><span id="line-3274">    private final long seqNum;</span>
<span class="source-line-no">3275</span><span id="line-3275"></span>
<span class="source-line-no">3276</span><span id="line-3276">    MovedRegionInfo(ServerName serverName, long closeSeqNum) {</span>
<span class="source-line-no">3277</span><span id="line-3277">      this.serverName = serverName;</span>
<span class="source-line-no">3278</span><span id="line-3278">      this.seqNum = closeSeqNum;</span>
<span class="source-line-no">3279</span><span id="line-3279">    }</span>
<span class="source-line-no">3280</span><span id="line-3280"></span>
<span class="source-line-no">3281</span><span id="line-3281">    public ServerName getServerName() {</span>
<span class="source-line-no">3282</span><span id="line-3282">      return serverName;</span>
<span class="source-line-no">3283</span><span id="line-3283">    }</span>
<span class="source-line-no">3284</span><span id="line-3284"></span>
<span class="source-line-no">3285</span><span id="line-3285">    public long getSeqNum() {</span>
<span class="source-line-no">3286</span><span id="line-3286">      return seqNum;</span>
<span class="source-line-no">3287</span><span id="line-3287">    }</span>
<span class="source-line-no">3288</span><span id="line-3288">  }</span>
<span class="source-line-no">3289</span><span id="line-3289"></span>
<span class="source-line-no">3290</span><span id="line-3290">  /**</span>
<span class="source-line-no">3291</span><span id="line-3291">   * We need a timeout. If not there is a risk of giving a wrong information: this would double the</span>
<span class="source-line-no">3292</span><span id="line-3292">   * number of network calls instead of reducing them.</span>
<span class="source-line-no">3293</span><span id="line-3293">   */</span>
<span class="source-line-no">3294</span><span id="line-3294">  private static final int TIMEOUT_REGION_MOVED = (2 * 60 * 1000);</span>
<span class="source-line-no">3295</span><span id="line-3295"></span>
<span class="source-line-no">3296</span><span id="line-3296">  private void addToMovedRegions(String encodedName, ServerName destination, long closeSeqNum,</span>
<span class="source-line-no">3297</span><span id="line-3297">    boolean selfMove) {</span>
<span class="source-line-no">3298</span><span id="line-3298">    if (selfMove) {</span>
<span class="source-line-no">3299</span><span id="line-3299">      LOG.warn("Not adding moved region record: " + encodedName + " to self.");</span>
<span class="source-line-no">3300</span><span id="line-3300">      return;</span>
<span class="source-line-no">3301</span><span id="line-3301">    }</span>
<span class="source-line-no">3302</span><span id="line-3302">    LOG.info("Adding " + encodedName + " move to " + destination + " record at close sequenceid="</span>
<span class="source-line-no">3303</span><span id="line-3303">      + closeSeqNum);</span>
<span class="source-line-no">3304</span><span id="line-3304">    movedRegionInfoCache.put(encodedName, new MovedRegionInfo(destination, closeSeqNum));</span>
<span class="source-line-no">3305</span><span id="line-3305">  }</span>
<span class="source-line-no">3306</span><span id="line-3306"></span>
<span class="source-line-no">3307</span><span id="line-3307">  void removeFromMovedRegions(String encodedName) {</span>
<span class="source-line-no">3308</span><span id="line-3308">    movedRegionInfoCache.invalidate(encodedName);</span>
<span class="source-line-no">3309</span><span id="line-3309">  }</span>
<span class="source-line-no">3310</span><span id="line-3310"></span>
<span class="source-line-no">3311</span><span id="line-3311">  @InterfaceAudience.Private</span>
<span class="source-line-no">3312</span><span id="line-3312">  public MovedRegionInfo getMovedRegion(String encodedRegionName) {</span>
<span class="source-line-no">3313</span><span id="line-3313">    return movedRegionInfoCache.getIfPresent(encodedRegionName);</span>
<span class="source-line-no">3314</span><span id="line-3314">  }</span>
<span class="source-line-no">3315</span><span id="line-3315"></span>
<span class="source-line-no">3316</span><span id="line-3316">  @InterfaceAudience.Private</span>
<span class="source-line-no">3317</span><span id="line-3317">  public int movedRegionCacheExpiredTime() {</span>
<span class="source-line-no">3318</span><span id="line-3318">    return TIMEOUT_REGION_MOVED;</span>
<span class="source-line-no">3319</span><span id="line-3319">  }</span>
<span class="source-line-no">3320</span><span id="line-3320"></span>
<span class="source-line-no">3321</span><span id="line-3321">  private String getMyEphemeralNodePath() {</span>
<span class="source-line-no">3322</span><span id="line-3322">    return zooKeeper.getZNodePaths().getRsPath(serverName);</span>
<span class="source-line-no">3323</span><span id="line-3323">  }</span>
<span class="source-line-no">3324</span><span id="line-3324"></span>
<span class="source-line-no">3325</span><span id="line-3325">  private boolean isHealthCheckerConfigured() {</span>
<span class="source-line-no">3326</span><span id="line-3326">    String healthScriptLocation = this.conf.get(HConstants.HEALTH_SCRIPT_LOC);</span>
<span class="source-line-no">3327</span><span id="line-3327">    return org.apache.commons.lang3.StringUtils.isNotBlank(healthScriptLocation);</span>
<span class="source-line-no">3328</span><span id="line-3328">  }</span>
<span class="source-line-no">3329</span><span id="line-3329"></span>
<span class="source-line-no">3330</span><span id="line-3330">  /** Returns the underlying {@link CompactSplit} for the servers */</span>
<span class="source-line-no">3331</span><span id="line-3331">  public CompactSplit getCompactSplitThread() {</span>
<span class="source-line-no">3332</span><span id="line-3332">    return this.compactSplitThread;</span>
<span class="source-line-no">3333</span><span id="line-3333">  }</span>
<span class="source-line-no">3334</span><span id="line-3334"></span>
<span class="source-line-no">3335</span><span id="line-3335">  CoprocessorServiceResponse execRegionServerService(</span>
<span class="source-line-no">3336</span><span id="line-3336">    @SuppressWarnings("UnusedParameters") final RpcController controller,</span>
<span class="source-line-no">3337</span><span id="line-3337">    final CoprocessorServiceRequest serviceRequest) throws ServiceException {</span>
<span class="source-line-no">3338</span><span id="line-3338">    try {</span>
<span class="source-line-no">3339</span><span id="line-3339">      ServerRpcController serviceController = new ServerRpcController();</span>
<span class="source-line-no">3340</span><span id="line-3340">      CoprocessorServiceCall call = serviceRequest.getCall();</span>
<span class="source-line-no">3341</span><span id="line-3341">      String serviceName = call.getServiceName();</span>
<span class="source-line-no">3342</span><span id="line-3342">      Service service = coprocessorServiceHandlers.get(serviceName);</span>
<span class="source-line-no">3343</span><span id="line-3343">      if (service == null) {</span>
<span class="source-line-no">3344</span><span id="line-3344">        throw new UnknownProtocolException(null,</span>
<span class="source-line-no">3345</span><span id="line-3345">          "No registered coprocessor executorService found for " + serviceName);</span>
<span class="source-line-no">3346</span><span id="line-3346">      }</span>
<span class="source-line-no">3347</span><span id="line-3347">      ServiceDescriptor serviceDesc = service.getDescriptorForType();</span>
<span class="source-line-no">3348</span><span id="line-3348"></span>
<span class="source-line-no">3349</span><span id="line-3349">      String methodName = call.getMethodName();</span>
<span class="source-line-no">3350</span><span id="line-3350">      MethodDescriptor methodDesc = serviceDesc.findMethodByName(methodName);</span>
<span class="source-line-no">3351</span><span id="line-3351">      if (methodDesc == null) {</span>
<span class="source-line-no">3352</span><span id="line-3352">        throw new UnknownProtocolException(service.getClass(),</span>
<span class="source-line-no">3353</span><span id="line-3353">          "Unknown method " + methodName + " called on executorService " + serviceName);</span>
<span class="source-line-no">3354</span><span id="line-3354">      }</span>
<span class="source-line-no">3355</span><span id="line-3355"></span>
<span class="source-line-no">3356</span><span id="line-3356">      Message request = CoprocessorRpcUtils.getRequest(service, methodDesc, call.getRequest());</span>
<span class="source-line-no">3357</span><span id="line-3357">      final Message.Builder responseBuilder =</span>
<span class="source-line-no">3358</span><span id="line-3358">        service.getResponsePrototype(methodDesc).newBuilderForType();</span>
<span class="source-line-no">3359</span><span id="line-3359">      service.callMethod(methodDesc, serviceController, request, message -&gt; {</span>
<span class="source-line-no">3360</span><span id="line-3360">        if (message != null) {</span>
<span class="source-line-no">3361</span><span id="line-3361">          responseBuilder.mergeFrom(message);</span>
<span class="source-line-no">3362</span><span id="line-3362">        }</span>
<span class="source-line-no">3363</span><span id="line-3363">      });</span>
<span class="source-line-no">3364</span><span id="line-3364">      IOException exception = CoprocessorRpcUtils.getControllerException(serviceController);</span>
<span class="source-line-no">3365</span><span id="line-3365">      if (exception != null) {</span>
<span class="source-line-no">3366</span><span id="line-3366">        throw exception;</span>
<span class="source-line-no">3367</span><span id="line-3367">      }</span>
<span class="source-line-no">3368</span><span id="line-3368">      return CoprocessorRpcUtils.getResponse(responseBuilder.build(), HConstants.EMPTY_BYTE_ARRAY);</span>
<span class="source-line-no">3369</span><span id="line-3369">    } catch (IOException ie) {</span>
<span class="source-line-no">3370</span><span id="line-3370">      throw new ServiceException(ie);</span>
<span class="source-line-no">3371</span><span id="line-3371">    }</span>
<span class="source-line-no">3372</span><span id="line-3372">  }</span>
<span class="source-line-no">3373</span><span id="line-3373"></span>
<span class="source-line-no">3374</span><span id="line-3374">  /**</span>
<span class="source-line-no">3375</span><span id="line-3375">   * May be null if this is a master which not carry table.</span>
<span class="source-line-no">3376</span><span id="line-3376">   * @return The block cache instance used by the regionserver.</span>
<span class="source-line-no">3377</span><span id="line-3377">   */</span>
<span class="source-line-no">3378</span><span id="line-3378">  @Override</span>
<span class="source-line-no">3379</span><span id="line-3379">  public Optional&lt;BlockCache&gt; getBlockCache() {</span>
<span class="source-line-no">3380</span><span id="line-3380">    return Optional.ofNullable(this.blockCache);</span>
<span class="source-line-no">3381</span><span id="line-3381">  }</span>
<span class="source-line-no">3382</span><span id="line-3382"></span>
<span class="source-line-no">3383</span><span id="line-3383">  /**</span>
<span class="source-line-no">3384</span><span id="line-3384">   * May be null if this is a master which not carry table.</span>
<span class="source-line-no">3385</span><span id="line-3385">   * @return The cache for mob files used by the regionserver.</span>
<span class="source-line-no">3386</span><span id="line-3386">   */</span>
<span class="source-line-no">3387</span><span id="line-3387">  @Override</span>
<span class="source-line-no">3388</span><span id="line-3388">  public Optional&lt;MobFileCache&gt; getMobFileCache() {</span>
<span class="source-line-no">3389</span><span id="line-3389">    return Optional.ofNullable(this.mobFileCache);</span>
<span class="source-line-no">3390</span><span id="line-3390">  }</span>
<span class="source-line-no">3391</span><span id="line-3391"></span>
<span class="source-line-no">3392</span><span id="line-3392">  CacheEvictionStats clearRegionBlockCache(Region region) {</span>
<span class="source-line-no">3393</span><span id="line-3393">    long evictedBlocks = 0;</span>
<span class="source-line-no">3394</span><span id="line-3394"></span>
<span class="source-line-no">3395</span><span id="line-3395">    for (Store store : region.getStores()) {</span>
<span class="source-line-no">3396</span><span id="line-3396">      for (StoreFile hFile : store.getStorefiles()) {</span>
<span class="source-line-no">3397</span><span id="line-3397">        evictedBlocks += blockCache.evictBlocksByHfileName(hFile.getPath().getName());</span>
<span class="source-line-no">3398</span><span id="line-3398">      }</span>
<span class="source-line-no">3399</span><span id="line-3399">    }</span>
<span class="source-line-no">3400</span><span id="line-3400"></span>
<span class="source-line-no">3401</span><span id="line-3401">    return CacheEvictionStats.builder().withEvictedBlocks(evictedBlocks).build();</span>
<span class="source-line-no">3402</span><span id="line-3402">  }</span>
<span class="source-line-no">3403</span><span id="line-3403"></span>
<span class="source-line-no">3404</span><span id="line-3404">  @Override</span>
<span class="source-line-no">3405</span><span id="line-3405">  public double getCompactionPressure() {</span>
<span class="source-line-no">3406</span><span id="line-3406">    double max = 0;</span>
<span class="source-line-no">3407</span><span id="line-3407">    for (Region region : onlineRegions.values()) {</span>
<span class="source-line-no">3408</span><span id="line-3408">      for (Store store : region.getStores()) {</span>
<span class="source-line-no">3409</span><span id="line-3409">        double normCount = store.getCompactionPressure();</span>
<span class="source-line-no">3410</span><span id="line-3410">        if (normCount &gt; max) {</span>
<span class="source-line-no">3411</span><span id="line-3411">          max = normCount;</span>
<span class="source-line-no">3412</span><span id="line-3412">        }</span>
<span class="source-line-no">3413</span><span id="line-3413">      }</span>
<span class="source-line-no">3414</span><span id="line-3414">    }</span>
<span class="source-line-no">3415</span><span id="line-3415">    return max;</span>
<span class="source-line-no">3416</span><span id="line-3416">  }</span>
<span class="source-line-no">3417</span><span id="line-3417"></span>
<span class="source-line-no">3418</span><span id="line-3418">  @Override</span>
<span class="source-line-no">3419</span><span id="line-3419">  public HeapMemoryManager getHeapMemoryManager() {</span>
<span class="source-line-no">3420</span><span id="line-3420">    return hMemManager;</span>
<span class="source-line-no">3421</span><span id="line-3421">  }</span>
<span class="source-line-no">3422</span><span id="line-3422"></span>
<span class="source-line-no">3423</span><span id="line-3423">  public MemStoreFlusher getMemStoreFlusher() {</span>
<span class="source-line-no">3424</span><span id="line-3424">    return cacheFlusher;</span>
<span class="source-line-no">3425</span><span id="line-3425">  }</span>
<span class="source-line-no">3426</span><span id="line-3426"></span>
<span class="source-line-no">3427</span><span id="line-3427">  /**</span>
<span class="source-line-no">3428</span><span id="line-3428">   * For testing</span>
<span class="source-line-no">3429</span><span id="line-3429">   * @return whether all wal roll request finished for this regionserver</span>
<span class="source-line-no">3430</span><span id="line-3430">   */</span>
<span class="source-line-no">3431</span><span id="line-3431">  @InterfaceAudience.Private</span>
<span class="source-line-no">3432</span><span id="line-3432">  public boolean walRollRequestFinished() {</span>
<span class="source-line-no">3433</span><span id="line-3433">    return this.walRoller.walRollFinished();</span>
<span class="source-line-no">3434</span><span id="line-3434">  }</span>
<span class="source-line-no">3435</span><span id="line-3435"></span>
<span class="source-line-no">3436</span><span id="line-3436">  @Override</span>
<span class="source-line-no">3437</span><span id="line-3437">  public ThroughputController getFlushThroughputController() {</span>
<span class="source-line-no">3438</span><span id="line-3438">    return flushThroughputController;</span>
<span class="source-line-no">3439</span><span id="line-3439">  }</span>
<span class="source-line-no">3440</span><span id="line-3440"></span>
<span class="source-line-no">3441</span><span id="line-3441">  @Override</span>
<span class="source-line-no">3442</span><span id="line-3442">  public double getFlushPressure() {</span>
<span class="source-line-no">3443</span><span id="line-3443">    if (getRegionServerAccounting() == null || cacheFlusher == null) {</span>
<span class="source-line-no">3444</span><span id="line-3444">      // return 0 during RS initialization</span>
<span class="source-line-no">3445</span><span id="line-3445">      return 0.0;</span>
<span class="source-line-no">3446</span><span id="line-3446">    }</span>
<span class="source-line-no">3447</span><span id="line-3447">    return getRegionServerAccounting().getFlushPressure();</span>
<span class="source-line-no">3448</span><span id="line-3448">  }</span>
<span class="source-line-no">3449</span><span id="line-3449"></span>
<span class="source-line-no">3450</span><span id="line-3450">  @Override</span>
<span class="source-line-no">3451</span><span id="line-3451">  public void onConfigurationChange(Configuration newConf) {</span>
<span class="source-line-no">3452</span><span id="line-3452">    ThroughputController old = this.flushThroughputController;</span>
<span class="source-line-no">3453</span><span id="line-3453">    if (old != null) {</span>
<span class="source-line-no">3454</span><span id="line-3454">      old.stop("configuration change");</span>
<span class="source-line-no">3455</span><span id="line-3455">    }</span>
<span class="source-line-no">3456</span><span id="line-3456">    this.flushThroughputController = FlushThroughputControllerFactory.create(this, newConf);</span>
<span class="source-line-no">3457</span><span id="line-3457">    try {</span>
<span class="source-line-no">3458</span><span id="line-3458">      Superusers.initialize(newConf);</span>
<span class="source-line-no">3459</span><span id="line-3459">    } catch (IOException e) {</span>
<span class="source-line-no">3460</span><span id="line-3460">      LOG.warn("Failed to initialize SuperUsers on reloading of the configuration");</span>
<span class="source-line-no">3461</span><span id="line-3461">    }</span>
<span class="source-line-no">3462</span><span id="line-3462"></span>
<span class="source-line-no">3463</span><span id="line-3463">    // update region server coprocessor if the configuration has changed.</span>
<span class="source-line-no">3464</span><span id="line-3464">    if (</span>
<span class="source-line-no">3465</span><span id="line-3465">      CoprocessorConfigurationUtil.checkConfigurationChange(getConfiguration(), newConf,</span>
<span class="source-line-no">3466</span><span id="line-3466">        CoprocessorHost.REGIONSERVER_COPROCESSOR_CONF_KEY)</span>
<span class="source-line-no">3467</span><span id="line-3467">    ) {</span>
<span class="source-line-no">3468</span><span id="line-3468">      LOG.info("Update region server coprocessors because the configuration has changed");</span>
<span class="source-line-no">3469</span><span id="line-3469">      this.rsHost = new RegionServerCoprocessorHost(this, newConf);</span>
<span class="source-line-no">3470</span><span id="line-3470">    }</span>
<span class="source-line-no">3471</span><span id="line-3471">  }</span>
<span class="source-line-no">3472</span><span id="line-3472"></span>
<span class="source-line-no">3473</span><span id="line-3473">  @Override</span>
<span class="source-line-no">3474</span><span id="line-3474">  public MetricsRegionServer getMetrics() {</span>
<span class="source-line-no">3475</span><span id="line-3475">    return metricsRegionServer;</span>
<span class="source-line-no">3476</span><span id="line-3476">  }</span>
<span class="source-line-no">3477</span><span id="line-3477"></span>
<span class="source-line-no">3478</span><span id="line-3478">  @Override</span>
<span class="source-line-no">3479</span><span id="line-3479">  public SecureBulkLoadManager getSecureBulkLoadManager() {</span>
<span class="source-line-no">3480</span><span id="line-3480">    return this.secureBulkLoadManager;</span>
<span class="source-line-no">3481</span><span id="line-3481">  }</span>
<span class="source-line-no">3482</span><span id="line-3482"></span>
<span class="source-line-no">3483</span><span id="line-3483">  @Override</span>
<span class="source-line-no">3484</span><span id="line-3484">  public EntityLock regionLock(final List&lt;RegionInfo&gt; regionInfo, final String description,</span>
<span class="source-line-no">3485</span><span id="line-3485">    final Abortable abort) {</span>
<span class="source-line-no">3486</span><span id="line-3486">    final LockServiceClient client =</span>
<span class="source-line-no">3487</span><span id="line-3487">      new LockServiceClient(conf, lockStub, asyncClusterConnection.getNonceGenerator());</span>
<span class="source-line-no">3488</span><span id="line-3488">    return client.regionLock(regionInfo, description, abort);</span>
<span class="source-line-no">3489</span><span id="line-3489">  }</span>
<span class="source-line-no">3490</span><span id="line-3490"></span>
<span class="source-line-no">3491</span><span id="line-3491">  @Override</span>
<span class="source-line-no">3492</span><span id="line-3492">  public void unassign(byte[] regionName) throws IOException {</span>
<span class="source-line-no">3493</span><span id="line-3493">    FutureUtils.get(asyncClusterConnection.getAdmin().unassign(regionName, false));</span>
<span class="source-line-no">3494</span><span id="line-3494">  }</span>
<span class="source-line-no">3495</span><span id="line-3495"></span>
<span class="source-line-no">3496</span><span id="line-3496">  @Override</span>
<span class="source-line-no">3497</span><span id="line-3497">  public RegionServerSpaceQuotaManager getRegionServerSpaceQuotaManager() {</span>
<span class="source-line-no">3498</span><span id="line-3498">    return this.rsSpaceQuotaManager;</span>
<span class="source-line-no">3499</span><span id="line-3499">  }</span>
<span class="source-line-no">3500</span><span id="line-3500"></span>
<span class="source-line-no">3501</span><span id="line-3501">  @Override</span>
<span class="source-line-no">3502</span><span id="line-3502">  public boolean reportFileArchivalForQuotas(TableName tableName,</span>
<span class="source-line-no">3503</span><span id="line-3503">    Collection&lt;Entry&lt;String, Long&gt;&gt; archivedFiles) {</span>
<span class="source-line-no">3504</span><span id="line-3504">    if (TEST_SKIP_REPORTING_TRANSITION) {</span>
<span class="source-line-no">3505</span><span id="line-3505">      return false;</span>
<span class="source-line-no">3506</span><span id="line-3506">    }</span>
<span class="source-line-no">3507</span><span id="line-3507">    RegionServerStatusService.BlockingInterface rss = rssStub;</span>
<span class="source-line-no">3508</span><span id="line-3508">    if (rss == null || rsSpaceQuotaManager == null) {</span>
<span class="source-line-no">3509</span><span id="line-3509">      // the current server could be stopping.</span>
<span class="source-line-no">3510</span><span id="line-3510">      LOG.trace("Skipping file archival reporting to HMaster as stub is null");</span>
<span class="source-line-no">3511</span><span id="line-3511">      return false;</span>
<span class="source-line-no">3512</span><span id="line-3512">    }</span>
<span class="source-line-no">3513</span><span id="line-3513">    try {</span>
<span class="source-line-no">3514</span><span id="line-3514">      RegionServerStatusProtos.FileArchiveNotificationRequest request =</span>
<span class="source-line-no">3515</span><span id="line-3515">        rsSpaceQuotaManager.buildFileArchiveRequest(tableName, archivedFiles);</span>
<span class="source-line-no">3516</span><span id="line-3516">      rss.reportFileArchival(null, request);</span>
<span class="source-line-no">3517</span><span id="line-3517">    } catch (ServiceException se) {</span>
<span class="source-line-no">3518</span><span id="line-3518">      IOException ioe = ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">3519</span><span id="line-3519">      if (ioe instanceof PleaseHoldException) {</span>
<span class="source-line-no">3520</span><span id="line-3520">        if (LOG.isTraceEnabled()) {</span>
<span class="source-line-no">3521</span><span id="line-3521">          LOG.trace("Failed to report file archival(s) to Master because it is initializing."</span>
<span class="source-line-no">3522</span><span id="line-3522">            + " This will be retried.", ioe);</span>
<span class="source-line-no">3523</span><span id="line-3523">        }</span>
<span class="source-line-no">3524</span><span id="line-3524">        // The Master is coming up. Will retry the report later. Avoid re-creating the stub.</span>
<span class="source-line-no">3525</span><span id="line-3525">        return false;</span>
<span class="source-line-no">3526</span><span id="line-3526">      }</span>
<span class="source-line-no">3527</span><span id="line-3527">      if (rssStub == rss) {</span>
<span class="source-line-no">3528</span><span id="line-3528">        rssStub = null;</span>
<span class="source-line-no">3529</span><span id="line-3529">      }</span>
<span class="source-line-no">3530</span><span id="line-3530">      // re-create the stub if we failed to report the archival</span>
<span class="source-line-no">3531</span><span id="line-3531">      createRegionServerStatusStub(true);</span>
<span class="source-line-no">3532</span><span id="line-3532">      LOG.debug("Failed to report file archival(s) to Master. This will be retried.", ioe);</span>
<span class="source-line-no">3533</span><span id="line-3533">      return false;</span>
<span class="source-line-no">3534</span><span id="line-3534">    }</span>
<span class="source-line-no">3535</span><span id="line-3535">    return true;</span>
<span class="source-line-no">3536</span><span id="line-3536">  }</span>
<span class="source-line-no">3537</span><span id="line-3537"></span>
<span class="source-line-no">3538</span><span id="line-3538">  void executeProcedure(long procId, long initiatingMasterActiveTime,</span>
<span class="source-line-no">3539</span><span id="line-3539">    RSProcedureCallable callable) {</span>
<span class="source-line-no">3540</span><span id="line-3540">    executorService</span>
<span class="source-line-no">3541</span><span id="line-3541">      .submit(new RSProcedureHandler(this, procId, initiatingMasterActiveTime, callable));</span>
<span class="source-line-no">3542</span><span id="line-3542">  }</span>
<span class="source-line-no">3543</span><span id="line-3543"></span>
<span class="source-line-no">3544</span><span id="line-3544">  public void remoteProcedureComplete(long procId, long initiatingMasterActiveTime,</span>
<span class="source-line-no">3545</span><span id="line-3545">    Throwable error) {</span>
<span class="source-line-no">3546</span><span id="line-3546">    procedureResultReporter.complete(procId, initiatingMasterActiveTime, error);</span>
<span class="source-line-no">3547</span><span id="line-3547">  }</span>
<span class="source-line-no">3548</span><span id="line-3548"></span>
<span class="source-line-no">3549</span><span id="line-3549">  void reportProcedureDone(ReportProcedureDoneRequest request) throws IOException {</span>
<span class="source-line-no">3550</span><span id="line-3550">    RegionServerStatusService.BlockingInterface rss;</span>
<span class="source-line-no">3551</span><span id="line-3551">    // TODO: juggling class state with an instance variable, outside of a synchronized block :'(</span>
<span class="source-line-no">3552</span><span id="line-3552">    for (;;) {</span>
<span class="source-line-no">3553</span><span id="line-3553">      rss = rssStub;</span>
<span class="source-line-no">3554</span><span id="line-3554">      if (rss != null) {</span>
<span class="source-line-no">3555</span><span id="line-3555">        break;</span>
<span class="source-line-no">3556</span><span id="line-3556">      }</span>
<span class="source-line-no">3557</span><span id="line-3557">      createRegionServerStatusStub();</span>
<span class="source-line-no">3558</span><span id="line-3558">    }</span>
<span class="source-line-no">3559</span><span id="line-3559">    try {</span>
<span class="source-line-no">3560</span><span id="line-3560">      rss.reportProcedureDone(null, request);</span>
<span class="source-line-no">3561</span><span id="line-3561">    } catch (ServiceException se) {</span>
<span class="source-line-no">3562</span><span id="line-3562">      if (rssStub == rss) {</span>
<span class="source-line-no">3563</span><span id="line-3563">        rssStub = null;</span>
<span class="source-line-no">3564</span><span id="line-3564">      }</span>
<span class="source-line-no">3565</span><span id="line-3565">      throw ProtobufUtil.getRemoteException(se);</span>
<span class="source-line-no">3566</span><span id="line-3566">    }</span>
<span class="source-line-no">3567</span><span id="line-3567">  }</span>
<span class="source-line-no">3568</span><span id="line-3568"></span>
<span class="source-line-no">3569</span><span id="line-3569">  /**</span>
<span class="source-line-no">3570</span><span id="line-3570">   * Will ignore the open/close region procedures which already submitted or executed. When master</span>
<span class="source-line-no">3571</span><span id="line-3571">   * had unfinished open/close region procedure and restarted, new active master may send duplicate</span>
<span class="source-line-no">3572</span><span id="line-3572">   * open/close region request to regionserver. The open/close request is submitted to a thread pool</span>
<span class="source-line-no">3573</span><span id="line-3573">   * and execute. So first need a cache for submitted open/close region procedures. After the</span>
<span class="source-line-no">3574</span><span id="line-3574">   * open/close region request executed and report region transition succeed, cache it in executed</span>
<span class="source-line-no">3575</span><span id="line-3575">   * region procedures cache. See {@link #finishRegionProcedure(long)}. After report region</span>
<span class="source-line-no">3576</span><span id="line-3576">   * transition succeed, master will not send the open/close region request to regionserver again.</span>
<span class="source-line-no">3577</span><span id="line-3577">   * And we thought that the ongoing duplicate open/close region request should not be delayed more</span>
<span class="source-line-no">3578</span><span id="line-3578">   * than 600 seconds. So the executed region procedures cache will expire after 600 seconds. See</span>
<span class="source-line-no">3579</span><span id="line-3579">   * HBASE-22404 for more details.</span>
<span class="source-line-no">3580</span><span id="line-3580">   * @param procId the id of the open/close region procedure</span>
<span class="source-line-no">3581</span><span id="line-3581">   * @return true if the procedure can be submitted.</span>
<span class="source-line-no">3582</span><span id="line-3582">   */</span>
<span class="source-line-no">3583</span><span id="line-3583">  boolean submitRegionProcedure(long procId) {</span>
<span class="source-line-no">3584</span><span id="line-3584">    if (procId == -1) {</span>
<span class="source-line-no">3585</span><span id="line-3585">      return true;</span>
<span class="source-line-no">3586</span><span id="line-3586">    }</span>
<span class="source-line-no">3587</span><span id="line-3587">    // Ignore the region procedures which already submitted.</span>
<span class="source-line-no">3588</span><span id="line-3588">    Long previous = submittedRegionProcedures.putIfAbsent(procId, procId);</span>
<span class="source-line-no">3589</span><span id="line-3589">    if (previous != null) {</span>
<span class="source-line-no">3590</span><span id="line-3590">      LOG.warn("Received procedure pid={}, which already submitted, just ignore it", procId);</span>
<span class="source-line-no">3591</span><span id="line-3591">      return false;</span>
<span class="source-line-no">3592</span><span id="line-3592">    }</span>
<span class="source-line-no">3593</span><span id="line-3593">    // Ignore the region procedures which already executed.</span>
<span class="source-line-no">3594</span><span id="line-3594">    if (executedRegionProcedures.getIfPresent(procId) != null) {</span>
<span class="source-line-no">3595</span><span id="line-3595">      LOG.warn("Received procedure pid={}, which already executed, just ignore it", procId);</span>
<span class="source-line-no">3596</span><span id="line-3596">      return false;</span>
<span class="source-line-no">3597</span><span id="line-3597">    }</span>
<span class="source-line-no">3598</span><span id="line-3598">    return true;</span>
<span class="source-line-no">3599</span><span id="line-3599">  }</span>
<span class="source-line-no">3600</span><span id="line-3600"></span>
<span class="source-line-no">3601</span><span id="line-3601">  /**</span>
<span class="source-line-no">3602</span><span id="line-3602">   * See {@link #submitRegionProcedure(long)}.</span>
<span class="source-line-no">3603</span><span id="line-3603">   * @param procId the id of the open/close region procedure</span>
<span class="source-line-no">3604</span><span id="line-3604">   */</span>
<span class="source-line-no">3605</span><span id="line-3605">  public void finishRegionProcedure(long procId) {</span>
<span class="source-line-no">3606</span><span id="line-3606">    executedRegionProcedures.put(procId, procId);</span>
<span class="source-line-no">3607</span><span id="line-3607">    submittedRegionProcedures.remove(procId);</span>
<span class="source-line-no">3608</span><span id="line-3608">  }</span>
<span class="source-line-no">3609</span><span id="line-3609"></span>
<span class="source-line-no">3610</span><span id="line-3610">  /**</span>
<span class="source-line-no">3611</span><span id="line-3611">   * Force to terminate region server when abort timeout.</span>
<span class="source-line-no">3612</span><span id="line-3612">   */</span>
<span class="source-line-no">3613</span><span id="line-3613">  private static class SystemExitWhenAbortTimeout extends TimerTask {</span>
<span class="source-line-no">3614</span><span id="line-3614"></span>
<span class="source-line-no">3615</span><span id="line-3615">    public SystemExitWhenAbortTimeout() {</span>
<span class="source-line-no">3616</span><span id="line-3616">    }</span>
<span class="source-line-no">3617</span><span id="line-3617"></span>
<span class="source-line-no">3618</span><span id="line-3618">    @Override</span>
<span class="source-line-no">3619</span><span id="line-3619">    public void run() {</span>
<span class="source-line-no">3620</span><span id="line-3620">      LOG.warn("Aborting region server timed out, terminating forcibly"</span>
<span class="source-line-no">3621</span><span id="line-3621">        + " and does not wait for any running shutdown hooks or finalizers to finish their work."</span>
<span class="source-line-no">3622</span><span id="line-3622">        + " Thread dump to stdout.");</span>
<span class="source-line-no">3623</span><span id="line-3623">      Threads.printThreadInfo(System.out, "Zombie HRegionServer");</span>
<span class="source-line-no">3624</span><span id="line-3624">      Runtime.getRuntime().halt(1);</span>
<span class="source-line-no">3625</span><span id="line-3625">    }</span>
<span class="source-line-no">3626</span><span id="line-3626">  }</span>
<span class="source-line-no">3627</span><span id="line-3627"></span>
<span class="source-line-no">3628</span><span id="line-3628">  @InterfaceAudience.Private</span>
<span class="source-line-no">3629</span><span id="line-3629">  public CompactedHFilesDischarger getCompactedHFilesDischarger() {</span>
<span class="source-line-no">3630</span><span id="line-3630">    return compactedFileDischarger;</span>
<span class="source-line-no">3631</span><span id="line-3631">  }</span>
<span class="source-line-no">3632</span><span id="line-3632"></span>
<span class="source-line-no">3633</span><span id="line-3633">  /**</span>
<span class="source-line-no">3634</span><span id="line-3634">   * Return pause time configured in {@link HConstants#HBASE_RPC_SHORTOPERATION_RETRY_PAUSE_TIME}}</span>
<span class="source-line-no">3635</span><span id="line-3635">   * @return pause time</span>
<span class="source-line-no">3636</span><span id="line-3636">   */</span>
<span class="source-line-no">3637</span><span id="line-3637">  @InterfaceAudience.Private</span>
<span class="source-line-no">3638</span><span id="line-3638">  public long getRetryPauseTime() {</span>
<span class="source-line-no">3639</span><span id="line-3639">    return this.retryPauseTime;</span>
<span class="source-line-no">3640</span><span id="line-3640">  }</span>
<span class="source-line-no">3641</span><span id="line-3641"></span>
<span class="source-line-no">3642</span><span id="line-3642">  @Override</span>
<span class="source-line-no">3643</span><span id="line-3643">  public Optional&lt;ServerName&gt; getActiveMaster() {</span>
<span class="source-line-no">3644</span><span id="line-3644">    return Optional.ofNullable(masterAddressTracker.getMasterAddress());</span>
<span class="source-line-no">3645</span><span id="line-3645">  }</span>
<span class="source-line-no">3646</span><span id="line-3646"></span>
<span class="source-line-no">3647</span><span id="line-3647">  @Override</span>
<span class="source-line-no">3648</span><span id="line-3648">  public List&lt;ServerName&gt; getBackupMasters() {</span>
<span class="source-line-no">3649</span><span id="line-3649">    return masterAddressTracker.getBackupMasters();</span>
<span class="source-line-no">3650</span><span id="line-3650">  }</span>
<span class="source-line-no">3651</span><span id="line-3651"></span>
<span class="source-line-no">3652</span><span id="line-3652">  @Override</span>
<span class="source-line-no">3653</span><span id="line-3653">  public Iterator&lt;ServerName&gt; getBootstrapNodes() {</span>
<span class="source-line-no">3654</span><span id="line-3654">    return bootstrapNodeManager.getBootstrapNodes().iterator();</span>
<span class="source-line-no">3655</span><span id="line-3655">  }</span>
<span class="source-line-no">3656</span><span id="line-3656"></span>
<span class="source-line-no">3657</span><span id="line-3657">  @Override</span>
<span class="source-line-no">3658</span><span id="line-3658">  public List&lt;HRegionLocation&gt; getMetaLocations() {</span>
<span class="source-line-no">3659</span><span id="line-3659">    return metaRegionLocationCache.getMetaRegionLocations();</span>
<span class="source-line-no">3660</span><span id="line-3660">  }</span>
<span class="source-line-no">3661</span><span id="line-3661"></span>
<span class="source-line-no">3662</span><span id="line-3662">  @Override</span>
<span class="source-line-no">3663</span><span id="line-3663">  protected NamedQueueRecorder createNamedQueueRecord() {</span>
<span class="source-line-no">3664</span><span id="line-3664">    return NamedQueueRecorder.getInstance(conf);</span>
<span class="source-line-no">3665</span><span id="line-3665">  }</span>
<span class="source-line-no">3666</span><span id="line-3666"></span>
<span class="source-line-no">3667</span><span id="line-3667">  @Override</span>
<span class="source-line-no">3668</span><span id="line-3668">  protected boolean clusterMode() {</span>
<span class="source-line-no">3669</span><span id="line-3669">    // this method will be called in the constructor of super class, so we can not return masterless</span>
<span class="source-line-no">3670</span><span id="line-3670">    // directly here, as it will always be false.</span>
<span class="source-line-no">3671</span><span id="line-3671">    return !conf.getBoolean(MASTERLESS_CONFIG_NAME, false);</span>
<span class="source-line-no">3672</span><span id="line-3672">  }</span>
<span class="source-line-no">3673</span><span id="line-3673"></span>
<span class="source-line-no">3674</span><span id="line-3674">  @InterfaceAudience.Private</span>
<span class="source-line-no">3675</span><span id="line-3675">  public BrokenStoreFileCleaner getBrokenStoreFileCleaner() {</span>
<span class="source-line-no">3676</span><span id="line-3676">    return brokenStoreFileCleaner;</span>
<span class="source-line-no">3677</span><span id="line-3677">  }</span>
<span class="source-line-no">3678</span><span id="line-3678"></span>
<span class="source-line-no">3679</span><span id="line-3679">  @InterfaceAudience.Private</span>
<span class="source-line-no">3680</span><span id="line-3680">  public RSMobFileCleanerChore getRSMobFileCleanerChore() {</span>
<span class="source-line-no">3681</span><span id="line-3681">    return rsMobFileCleanerChore;</span>
<span class="source-line-no">3682</span><span id="line-3682">  }</span>
<span class="source-line-no">3683</span><span id="line-3683"></span>
<span class="source-line-no">3684</span><span id="line-3684">  RSSnapshotVerifier getRsSnapshotVerifier() {</span>
<span class="source-line-no">3685</span><span id="line-3685">    return rsSnapshotVerifier;</span>
<span class="source-line-no">3686</span><span id="line-3686">  }</span>
<span class="source-line-no">3687</span><span id="line-3687"></span>
<span class="source-line-no">3688</span><span id="line-3688">  @Override</span>
<span class="source-line-no">3689</span><span id="line-3689">  protected void stopChores() {</span>
<span class="source-line-no">3690</span><span id="line-3690">    shutdownChore(nonceManagerChore);</span>
<span class="source-line-no">3691</span><span id="line-3691">    shutdownChore(compactionChecker);</span>
<span class="source-line-no">3692</span><span id="line-3692">    shutdownChore(compactedFileDischarger);</span>
<span class="source-line-no">3693</span><span id="line-3693">    shutdownChore(periodicFlusher);</span>
<span class="source-line-no">3694</span><span id="line-3694">    shutdownChore(healthCheckChore);</span>
<span class="source-line-no">3695</span><span id="line-3695">    shutdownChore(executorStatusChore);</span>
<span class="source-line-no">3696</span><span id="line-3696">    shutdownChore(storefileRefresher);</span>
<span class="source-line-no">3697</span><span id="line-3697">    shutdownChore(fsUtilizationChore);</span>
<span class="source-line-no">3698</span><span id="line-3698">    shutdownChore(namedQueueServiceChore);</span>
<span class="source-line-no">3699</span><span id="line-3699">    shutdownChore(brokenStoreFileCleaner);</span>
<span class="source-line-no">3700</span><span id="line-3700">    shutdownChore(rsMobFileCleanerChore);</span>
<span class="source-line-no">3701</span><span id="line-3701">    shutdownChore(replicationMarkerChore);</span>
<span class="source-line-no">3702</span><span id="line-3702">  }</span>
<span class="source-line-no">3703</span><span id="line-3703"></span>
<span class="source-line-no">3704</span><span id="line-3704">  @Override</span>
<span class="source-line-no">3705</span><span id="line-3705">  public RegionReplicationBufferManager getRegionReplicationBufferManager() {</span>
<span class="source-line-no">3706</span><span id="line-3706">    return regionReplicationBufferManager;</span>
<span class="source-line-no">3707</span><span id="line-3707">  }</span>
<span class="source-line-no">3708</span><span id="line-3708">}</span>




























































</pre>
</div>
</main>
</body>
</html>
